<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Hiking and Coding</title>

<link rel="stylesheet" href="style.css" type="text/css" />

<link rel="stylesheet" href="local.css" type="text/css" />


<link rel="alternate" type="application/rss+xml" title="Hiking and Coding (RSS feed)" href="index.rss" /><link rel="alternate" type="application/atom+xml" title="Hiking and Coding (Atom feed)" href="index.atom" />


<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>

<div class="page">

<div class="pageheader">
<div class="header">
<span>
<span class="parentlinks">

</span>
<span class="title">
Hiking and Coding

</span>
</span>

</div>


<div class="actions">
<ul>


<li><a href="./recentchanges/">RecentChanges</a></li>






<li>

<a href="">Comment</a>

</li>

</ul>
</div>




</div>


<div class="sidebar">
<div><div class="calendar"><table class="month-calendar">
    <tr>
    <th class="month-calendar-arrow"><a href="./archives/2011/11/" title="November">&larr;</a></th>
    <th class="month-calendar-head" colspan="5"><a href="./archives/2011/12/" title="December">Dec 2011</a></th>
    <th class="month-calendar-arrow"></th>
    </tr>
    <tr>
        <th class="month-calendar-day-head Sunday" title="Sunday">S</th>
        <th class="month-calendar-day-head Monday" title="Monday">M</th>
        <th class="month-calendar-day-head Tuesday" title="Tuesday">T</th>
        <th class="month-calendar-day-head Wednesday" title="Wednesday">W</th>
        <th class="month-calendar-day-head Thursday" title="Thursday">T</th>
        <th class="month-calendar-day-head Friday" title="Friday">F</th>
        <th class="month-calendar-day-head Saturday" title="Saturday">S</th>
    </tr>
    <tr>
        <td class="month-calendar-day-noday Sunday">&nbsp;</td>
        <td class="month-calendar-day-noday Monday">&nbsp;</td>
        <td class="month-calendar-day-noday Tuesday">&nbsp;</td>
        <td class="month-calendar-day-noday Wednesday">&nbsp;</td>
        <td class="month-calendar-day-nolink Thursday">1</td>
        <td class="month-calendar-day-link Friday"><a href="./posts/org-ikiwiki-plugin/" title="org-ikiwiki-plugin">2</a></td>
        <td class="month-calendar-day-link Saturday"><a href="./posts/clojel/" title="clojel">3</a></td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">4</td>
        <td class="month-calendar-day-nolink Monday">5</td>
        <td class="month-calendar-day-this-day Tuesday"><a href="./posts/org-ikiwiki-plugin-2/" title="org-ikiwiki-plugin-2">6</a></td>
        <td class="month-calendar-day-future Wednesday">7</td>
        <td class="month-calendar-day-nolink Thursday">8</td>
        <td class="month-calendar-day-nolink Friday">9</td>
        <td class="month-calendar-day-nolink Saturday">10</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">11</td>
        <td class="month-calendar-day-nolink Monday">12</td>
        <td class="month-calendar-day-nolink Tuesday">13</td>
        <td class="month-calendar-day-nolink Wednesday">14</td>
        <td class="month-calendar-day-nolink Thursday">15</td>
        <td class="month-calendar-day-nolink Friday">16</td>
        <td class="month-calendar-day-nolink Saturday">17</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">18</td>
        <td class="month-calendar-day-nolink Monday">19</td>
        <td class="month-calendar-day-nolink Tuesday">20</td>
        <td class="month-calendar-day-nolink Wednesday">21</td>
        <td class="month-calendar-day-nolink Thursday">22</td>
        <td class="month-calendar-day-nolink Friday">23</td>
        <td class="month-calendar-day-nolink Saturday">24</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">25</td>
        <td class="month-calendar-day-nolink Monday">26</td>
        <td class="month-calendar-day-nolink Tuesday">27</td>
        <td class="month-calendar-day-nolink Wednesday">28</td>
        <td class="month-calendar-day-nolink Thursday">29</td>
        <td class="month-calendar-day-nolink Friday">30</td>
        <td class="month-calendar-day-nolink Saturday">31</td>
    </tr>
</table>
</div></div>

<p><a href="./archives/">Archives</a></p>

<p><a href="./tags/">Tags</a>:</p>

<ul class='list'>
<li><span class="smallPC"><a href="./tags/AT/">AT</a></span>
</li><li><span class="smallestPC"><a href="./tags/blogging/">blogging</a></span>
</li><li><span class="biggestPC"><a href="./tags/clojure/">clojure</a></span>
</li><li><span class="normalPC"><a href="./tags/clojurescript/">clojurescript</a></span>
</li><li><span class="smallPC"><a href="./tags/computational-geometry/">computational-geometry</a></span>
</li><li><span class="smallestPC"><a href="./tags/convex-hull/">convex-hull</a></span>
</li><li><span class="smallPC"><a href="./tags/emacs/">emacs</a></span>
</li><li><span class="smallestPC"><a href="./tags/email/">email</a></span>
</li><li><span class="smallPC"><a href="./tags/git/">git</a></span>
</li><li><span class="smallestPC"><a href="./tags/git-annex/">git-annex</a></span>
</li><li><span class="smallPC"><a href="./tags/hiking/">hiking</a></span>
</li><li><span class="smallPC"><a href="./tags/ikiwiki/">ikiwiki</a></span>
</li><li><span class="smallestPC"><a href="./tags/ikiwiki-org-plugin/">ikiwiki-org-plugin</a></span>
</li><li><span class="bigPC"><a href="./tags/lab-notes/">lab-notes</a></span>
</li><li><span class="smallestPC"><a href="./tags/notmuch/">notmuch</a></span>
</li><li><span class="smallPC"><a href="./tags/org-mode/">org-mode</a></span>
</li><li><span class="smallestPC"><a href="./tags/processing/">processing</a></span>
</li><li><span class="smallPC"><a href="./tags/programming-challenge/">programming-challenge</a></span>
</li><li><span class="smallPC"><a href="./tags/rationals/">rationals</a></span>
</li><li><span class="smallestPC"><a href="./tags/sort/">sort</a></span>
</li><li><span class="smallestPC"><a href="./tags/spot/">spot</a></span>
</li><li><span class="smallestPC"><a href="./tags/thrush/">thrush</a></span>
</li><li><span class="smallestPC"><a href="./tags/time-series/">time-series</a></span>
</li><li><span class="smallPC"><a href="./tags/visibility-polygon/">visibility-polygon</a></span>
</li><li><span class="smallestPC"><a href="./tags/voronoi-diagram/">voronoi-diagram</a></span>
</li></ul>

<p>Post interval:
<img src="./sidebar/sparkline-b9479b692171ccb7c09df6efec8c5c2285a91c88.png" alt="graph" /></p>

<p><a href="http://twitter.com/frogmanjack">Twitter</a>: <em>Can't connect to api.twitter.com:80 (timeout)</em> (58 posts)</p>

<div class="microblog">

<div class="inlinecontent">
frogmanjack: There is very little difference between the eyes of a heroin addict just after a fix and those of my dog as I am petting him on the chest.











</div>

<div class="microblog-header">


<span class="author">

<a href="http://twitter.com/frogmanjack">Twitter</a>

</span>


&mdash; <span class="date">Mon 05 Dec 2011 06:40:36 PM MST</span>

</div> <!--.microblog-header-->
</div> <!--.microblog-->
<div class="microblog">

<div class="inlinecontent">
frogmanjack: A sad day: another tree in our neighborhood fell. This time not naturally.











</div>

<div class="microblog-header">


<span class="author">

<a href="http://twitter.com/frogmanjack">Twitter</a>

</span>


&mdash; <span class="date">Mon 05 Dec 2011 01:54:13 PM MST</span>

</div> <!--.microblog-header-->
</div> <!--.microblog-->
<div class="microblog">

<div class="inlinecontent">
frogmanjack: Two technology-related articles that I enjoyed: http://t.co/WGcFiCzC and http://t.co/PGyepwct











</div>

<div class="microblog-header">


<span class="author">

<a href="http://twitter.com/frogmanjack">Twitter</a>

</span>


&mdash; <span class="date">Mon 05 Dec 2011 10:07:40 AM MST</span>

</div> <!--.microblog-header-->
</div> <!--.microblog-->
<div class="microblog">

<div class="inlinecontent">
frogmanjack: If you like 'These Days' by Nico http://t.co/ZhSUSLZG you might like 'Paid Programming' by that dog. http://t.co/2xBwZYYl











</div>

<div class="microblog-header">


<span class="author">

<a href="http://twitter.com/frogmanjack">Twitter</a>

</span>


&mdash; <span class="date">Fri 02 Dec 2011 05:47:18 PM MST</span>

</div> <!--.microblog-header-->
</div> <!--.microblog-->
<div class="microblog">

<div class="inlinecontent">
frogmanjack: Why is it that I don't mind i.e. and e.g., but get enraged when people use cf.?











</div>

<div class="microblog-header">


<span class="author">

<a href="http://twitter.com/frogmanjack">Twitter</a>

</span>


&mdash; <span class="date">Wed 30 Nov 2011 03:40:50 PM MST</span>

</div> <!--.microblog-header-->
</div> <!--.microblog-->


</div>


<div id="pagebody">

<div id="content">
<div  class="feedlink">

<a class="feedbutton" type="application/rss+xml" rel="alternate" title="Hiking and Coding (RSS feed)" href="index.rss">RSS</a>


<a class="feedbutton" type="application/atom+xml" rel="alternate" title="Hiking and Coding (Atom feed)" href="index.atom">Atom</a>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="./posts/org-ikiwiki-plugin-2/">Updates on the ikiwiki plugin</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Progress </h2>
<div class="outline-text-2" id="text-1">


<p>  
  Progress on the <a href="./posts/org-ikiwiki-plugin">plugin</a> is proceeding apace.  In fact, the link in the
  last sentence is a major milestone &ndash; for the first time, I can use
  what ikiwiki calls <a href="http://ikiwiki.info/ikiwiki/wikilink/">wikilinks</a>.  What would happen previously is that
  ikiwiki would stick some raw HTML into an org file when it thought
  it saw a wikilink.  Org wouldn't know what to do with this, and
  would escape the HTML so that it would show up in the browser.  This
  is the reason that I couldn't include images in the posts &ndash; they
  would get interpreted as wikilinks and then org would choke on the
  resulting HTML.
</p>
<p>
  I'm not sure that inserting local picture files works yet, but
  inserting pictures from other servers works okay.  For example, here
  is a picture of me standing at the US/Mexico border:
  <img src="https://lh5.googleusercontent.com/-JiFi6diO5zM/Tgziytt-fwI/AAAAAAAACDc/dQXeYi-7odI/s144/DSCF0494.JPG"  alt="https://lh5.googleusercontent.com/-JiFi6diO5zM/Tgziytt-fwI/AAAAAAAACDc/dQXeYi-7odI/s144/DSCF0494.JPG" />
  and here is me after hiking to the US/Canada border:
  <img src="https://lh3.googleusercontent.com/-j-b_h7_SSlo/TnyPfTGVCyI/AAAAAAAADWA/cFvVuP1QvB8/s144/DSCF0597.JPG"  alt="https://lh3.googleusercontent.com/-j-b_h7_SSlo/TnyPfTGVCyI/AAAAAAAADWA/cFvVuP1QvB8/s144/DSCF0597.JPG" />
</p>
<p>
  I think I have ironed out most of the kinks that caused things to
  hang previously when updating the site, but more testing is
  certainly needed.  Things that remain on my todo list include
  figuring out why it doesn't work when the emacs doing the compiling
  is daemonized, and testing whether locally hosted pictures work.
</p>
<p>
  Any feedback would be appreciated!
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Tue 06 Dec 2011 02:55:28 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="./tags/emacs/" rel="tag">emacs</a>

<a href="./tags/ikiwiki-org-plugin/" rel="tag">ikiwiki-org-plugin</a>

<a href="./tags/org-mode/" rel="tag">org-mode</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="./posts/clojel/">Clojure in Elisp</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Probably a bad idea&hellip; </h2>
<div class="outline-text-2" id="text-1">


<p>
  File this one in the category of crazy ideas had while running.  I
  was thinking about my new org-mode plugin that I announced <a href="http://chrismgray.github.com/posts/org-ikiwiki-plugin/">yesterday</a>
  and how hard it is to write in Emacs Lisp.  I was wishing that I
  could write it in Clojure instead.  Now, they're not <b>such</b>
  different languages &ndash; they both are evolutions of McCarthy's
  original lisp, but Clojure is a much prettier, less crufty
  language.
</p>
<p>
  Let's look at just one construct in both languages: <code>let</code>.  In both
  languages, this assigns values to variable names locally. In elisp,
  it looks like:
</p>



<pre class="src src-elisp">(<span style="color: #f0dfaf; font-weight: bold;">let*</span> ((foo bar)
       (baz foo)))
</pre>




<p>
  Instead of calling <code>let</code> there, I had to call <code>let*</code>, so that the
  results of the first assignment were known to the second assignment.
  There is also a lot of parentheses there.  (Unparenthesized
  variables become automatically initialized to <code>nil</code> I believe.  I
  don't think that's a great idea.)  Contrast this with Clojure's
  <code>let</code>.
</p>



<pre class="src src-clojure">(<span style="color: #8cd0d3;">let</span> [foo bar
      baz foo])
</pre>




<p>
  To me, that's much more readable.
</p>
<p>
  Clojure's core libraries are also much more readable than most of
  elisp.  It seems to me that elisp was designed in the days where
  computer usage was charged by the letter and has not been updated
  since.  (Don't get me wrong &ndash; I love Emacs and would rather program
  in elisp than Perl, but it has some warts.)
</p>

</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Maybe not so crazy </h2>
<div class="outline-text-2" id="text-2">


<p>
  Emacs already has a reader that can be used to turn lispy-looking
  things into lispy data structures.  Add some macros on top of that
  and you might be able to produce a <code>def</code> that's equivalent to
  Clojure's.  Since much of Clojure is written in Clojure (and all of
  Clojurescript is), defining the Clojure functions might just be a
  hop, skip, and jump away from that.
</p>
<p>
  Clojure could intern symbols into emacs (with namespaces prepended)
  and then emacs could use them.  Clojure could also call emacs
  functions directly &ndash; any symbol that isn't defined in a Clojure
  namespace would be tested to see if it exists in emacs.
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Probably pretty crazy after all </h2>
<div class="outline-text-2" id="text-3">


<p>
  One of Clojure's big selling points is its concurrency semantics.
  I don't follow emacs development very closely, but I don't think
  emacs is going to support any of that any time soon.  Also, would it
  be possible to compile the new language to elisp bytecode?  How
  would <code>recur</code> work?
</p>
<p>
  There are a lot of questions, and here I am working on a plugin for
  a combination of tools that hardly anyone uses.  But everyone has to
  scratch their own itch as they say.
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Sat 03 Dec 2011 05:32:56 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="./tags/clojure/" rel="tag">clojure</a>

<a href="./tags/emacs/" rel="tag">emacs</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="./posts/org-ikiwiki-plugin/">Plugin for org files in ikiwiki</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">A new plugin </h2>
<div class="outline-text-2" id="text-1">


<p>
  Ikiwiki users who want to write org-mode files have long only had
  one plugin for ikiwiki to convert their files to html.  That plugin
  is good as it goes, but it is somewhat limited.  Thus, I am happy to
  announce a new plugin for converting org-mode.  It is located in my
  <a href="https://github.com/chrismgray/ikiwiki-org-plugin">github repository</a>.
</p>
<p>
  It is still a bit rough around the edges, but it should be
  completely usable very soon.
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Fri 02 Dec 2011 04:29:47 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="./tags/emacs/" rel="tag">emacs</a>

<a href="./tags/ikiwiki/" rel="tag">ikiwiki</a>

<a href="./tags/ikiwiki-org-plugin/" rel="tag">ikiwiki-org-plugin</a>

<a href="./tags/org-mode/" rel="tag">org-mode</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="./posts/convex-hulls/">Convex Hulls</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Convex Hulls Three Ways </h2>
<div class="outline-text-2" id="text-1">


<p>
  Whenever I watch cooking competition shows, they always have chefs
  presenting a foodstuff cooked in multiple different ways.  Today,
  I'm doing that with algorithms.
</p>
<p>
  The algorithm in question today is the <a href="http://en.wikipedia.org/wiki/Convex_hull">convex hull</a> algorithm.  In
  order of implementation complexity, and descending order of
  theoretical running time, there is the Jarvis March, Graham's Scan,
  and Chan's Algorithm.  All three are implemented in Clojure in my
  <a href="https://github.com/chrismgray/convex-hull">github repository</a>.
</p>

</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">Jarvis March </h3>
<div class="outline-text-3" id="text-1-1">


<p>
   The simplest of the algorithms, the Jarvis March was also one of
   the first output-sensitive computational geometry algorithms.  In a
   nutshell, you first find a point that you know to be on the convex
   hull, and then you find the next point by looking at all the rest
   of the points and determining which one has a segment that has the
   property that all the rest of the points are on one side of it.
   You repeatedly find the next point using this procedure until you
   get back to the first point.  There is basically no way to
   implement this algorithm that does not have a running time of
   \(O(hn)\), where \(h\) is the number of points on the convex hull
   and \(n\) is the number of input points.
</p>
<p>
   The one implementation detail of the Jarvis March that is
   interesting is that whenever you see the concept of "finding the
   next thing" given some previous information, the Clojure
   implementation should almost always be lazy.  It turns out that
   implementing Jarvis March lazily will help in implementing Chan's
   Algorithm, so keep that in mind.
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Graham's Scan </h3>
<div class="outline-text-3" id="text-1-2">


<p>
   Graham's Scan is one of the algorithms I remember most vividly from
   the undergraduate computational geometry course that I took.  The
   professor, Godfried Toussaint, always referred to it as the "three
   coins" algorithm, so I have kept up that tradition in some of my
   function names in my implementation.
</p>
<p>
   The algorithm first makes a polygon of the input points by sorting
   them by angle about the bottom-most point.  Then it goes around the
   polygon with a stack, pushing and popping points as it goes.  If
   that sounds familiar, it should &ndash; it's the same idea as what I was
   talking about when I brought up the idea of <a href="http://chrismgray.github.com/posts/parsing-polygons/">parsing polygons</a> a week
   and a half ago. 
</p>
<p>
   Thus, I used the same polygon-parsing monad in my implementation as
   when I computed the visibility polygons last week.  It still works
   just as well.
</p>
<p>
   Since the points must be sorted, Graham's Scan takes \(\Theta(n
   \log n)\).  Sorting can be reduced to computing convex hulls, so
   computing convex hulls has a \(\Omega(n \log n)\) lower bound,
   meaning that this algorithm is optimal.
</p>
<p>
   But Chan's algorithm is better.  Weird huh?
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">Chan's Algorithm </h3>
<div class="outline-text-3" id="text-1-3">


<p>
   I must confess that I had always been a little intimidated by
   Chan's Algorithm.  It was invented by Timothy Chan, who has a
   well-earned reputation for being a genius, so I thought it would be
   really complicated.  It's not.  There is a decent <a href="http://en.wikipedia.org/wiki/Chan's_algorithm">description</a> of it
   on Wikipedia, so I won't go into the details.  The gist is that you
   combine the two previous algorithms that I discussed.  The Jarvis
   March needs to be modified so that the points can be input as a
   list of smaller convex hulls, and the next point on the convex hull
   is found by doing a binary search on the smaller convex hulls.  But
   that is really the hardest part about the algorithm.  I have put
   the whole thing below, because I think it's pretty beautiful.
</p>



<pre class="src src-clojure">(<span style="color: #f0dfaf; font-weight: bold;">defn</span> <span style="color: #8cd0d3;">chans-algorithm</span>
  <span style="color: #8fb28f;">"Finds the convex hull of a set of points by</span>
<span style="color: #8fb28f;">   the algorithm known as 'Chan's Algorithm'."</span>
  [pts]
  (<span style="color: #8cd0d3;">let</span> [bottom-pt (<span style="color: #f0dfaf;">apply</span> min-key <span style="color: #dca3a3; font-weight: bold;">:y</span> pts)]
   (<span style="color: #8cd0d3;">loop</span> [m 3] <span style="color: #708070;">; </span><span style="color: #7f9f7f;">start out with triangles</span>
     (<span style="color: #8cd0d3;">let</span> [partitioned-pts (<span style="color: #f0dfaf;">partition</span> m m [] pts)
           c-hs (<span style="color: #f0dfaf;">map</span> grahams-scan partitioned-pts)
           potential-ch (<span style="color: #f0dfaf;">take</span> m (<span style="color: #f0dfaf;">apply</span> jarvis-march pts c-hs))]
       (<span style="color: #8cd0d3;">if</span> (<span style="color: #f0dfaf;">=</span> bottom-pt (<span style="color: #f0dfaf;">last</span> potential-ch)) <span style="color: #708070;">; </span><span style="color: #7f9f7f;">assumes jarvis-march returns bottom-pt last</span>
         potential-ch
         (<span style="color: #8cd0d3;">recur</span> (<span style="color: #f0dfaf;">min</span> (<span style="color: #f0dfaf;">*</span> m m) (<span style="color: #f0dfaf;">count</span> pts))))))))
</pre>




<p>
   The great thing about Chan's Algorithm is that it is also
   output-sensitive.  But instead of being \(O(nh)\) (which is
   \(O(n^2)\) in the worst case), it is \(O(n \log h)\), which is at
   least as good as Graham's Scan, but often better.  It is also quite
   simple to implement, given decent implementations of Jarvis March
   and Graham's Scan.  
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Conclusion </h2>
<div class="outline-text-2" id="text-2">


<p>
  Convex hull algorithms are great.  If I was ever to teach a
  computational geometry course (admittedly that's looking like a long
  shot now), I might start and finish the course with them.  The
  progression from the ultra-simple Jarvis March to the
  more-complicated Chan's Algorithm is really nice, and there are
  interesting new things to talk about the whole way.  They also show
  that computational geometry is not so hard to do in a functional
  style.  In fact, using laziness is what makes the implementation of
  Chan's Algorithm so simple.  So this might make a nice talk to give
  people who are already into functional programming as well.
</p>
<p>
  The next thing I have in mind for this project is to animate the
  algorithms.  Viewing the output of algorithms is already pretty easy
  using Processing, but I would like to be able to see them as they
  are operating.  It would be great if I could do that without
  changing the code too much.  I have a couple of ideas, but I'm not
  sure if they'll work yet.
</p>
<p>
  Also, it is slightly embarrassing to admit, but my blogging system
  seems to not support putting images in posts.  So I am going to have
  to figure out how to work around (or even fix) that before I can
  show any results.
</p>





</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Wed 30 Nov 2011 11:06:31 AM MST</span>
</span>


<span class="tags">
Tags:

<a href="./tags/clojure/" rel="tag">clojure</a>

<a href="./tags/computational-geometry/" rel="tag">computational-geometry</a>

<a href="./tags/convex-hull/" rel="tag">convex-hull</a>

<a href="./tags/ikiwiki/" rel="tag">ikiwiki</a>

<a href="./tags/lab-notes/" rel="tag">lab-notes</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="./posts/hiking/mid-maine/">Mid-Maine</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Leaving Monson </h2>
<div class="outline-text-2" id="text-1">


<p>
  When I last left my hiking tale, Picker, Grinner, Frosty and I had
  just gotten to Monson in time for breakfast.  We were hustled into
  showers and given clean clothes to put on while ours were in the
  washer.  We decided to stay in Monson for the rest of the day.  A
  bit of hiking terminology: a <i>zero</i> is a day in which no walking is
  done.  What we were doing is called a <i>nearo</i> (sometimes written
  <i>near-0</i>), short for near-zero.  It's one of the most enjoyable ways
  to spend a day.  You only need to pay for one night at the hostel or
  hotel, but you have all the fun of a town day.
</p>
<p>
  Anyway, breakfast was great &ndash; unlimited pancakes, eggs, and some of
  the best home fries I had on the trail.  The big event of the day
  was the World Cup final.  The town of Monson is extremely small.
  There was one bar and one convenience store as well as the hostel we
  were staying at, named Shaw's.  We watched the final at the bar.  I
  was disappointed that the Netherlands lost, but I remember it being
  a really dirty game, so I guess the better team won in the end.
</p>
<p>
  Frosty got a six-pack of beer for us to split, and it was through
  this beer that we met Wounded Knee.  The four of us had taken a seat
  to chat and drink the beer, when Wounded Knee showed up with one of
  the beers in his hand.  He began regaling us with hiking stories and
  bad jokes.  Later, we figured that he probably thought he was paying
  for the beer by telling us his great stories.  I think we would have
  been happier if he had just taken the beer and left us alone.
  (Cruel, but true &ndash; at least he did provide an excellent topic of
  conversation over the next month.)
</p>
<p>
  After a rather fitful sleep, Picker, Grinner, and I left Frosty in
  Monson.  He wanted to stay another day to rest after the 100-mile
  wilderness.  Unfortunately, it was the last time we would see him on
  our hike &ndash; he got a stress fracture in his foot and stopped about
  50 miles later.
</p>
<p>
  As we were being driven back to the trail, we were given a warning
  about a "bahd hikeah" (a bad hiker in the heavy Northeastern accent
  that is common in Maine).  He had apparently chosen to swim a
  dangerous river for which a ferry is provided after heaping abuse on
  the ferry operator.  He would not be served in Monson &ndash; my first
  hint that there is a little network of hostel operators up and down
  the trail.  We actually did cross paths with the guy, and he looked
  more like a motorcycle enthusiast than a hiker, but other than that,
  there was no indication that he was really a bad guy.
</p>
<p>
  The next day, Grinner was not feeling great.  I think it was for
  this reason that we did not go very far.  On the subsequent day, it
  became clear that Grinner was really sick.  Luckily, they had a cell
  phone with them, and were able to call Shaw's.  Grinner was picked
  up, and as she left, she told me to take care of Picker.  Which
  showed that she hadn't lost her sense of humor, because Picker is a
  bad-ass Army veteran who had been in Iraq.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Without Grinner </h2>
<div class="outline-text-2" id="text-2">


<p>
  Picker was obviously concerned about his wife, so we made a plan to
  get to the next town as quickly as possible.  We got to the Kennebec
  river (the one with the ferry) unfortunately after the ferry had
  stopped for the night.  Partly to give myself something to do, and
  partly to cheer Picker up, I decided to find us some sodas.  The
  small town of Caratunk is near the trail at that point, but it
  didn't even have a convenience store, so I had to hitchhike to a
  small resort that had vending machines.  It was my first time
  hitching a ride, and I was glad that it worked out well.
</p>
<p>
  The next day, we caught the first ferry across the river.  When one
  imagines a ferry, it is usually a fairly large boat.  This was not.
  It was a small canoe, operated by a local hippie.  I helped row us
  across the river, and we set out as fast as possible.  That was our
  first twenty-mile day.  The scenery was great, with a nice waterfall
  near the trail, but we were in a rush to see Grinner again.  Near
  the end of the day, the trail was rerouted, adding an extra couple
  of miles to our day.  We were quite glad to get to the campsite on
  the North side of Little Bigelow Mountain.
</p>
<p>
  This put us only about 15 miles from Stratton, where we assumed that
  Grinner would be.  However, there were two big climbs between here
  and there.  We must have gotten to the top of the first fairly early
  in the morning.  We crossed a road in which someone had <a href="https://picasaweb.google.com/lh/photo/2Qwgtnn5g3HJZgZp52HULHIQdffm0dM4kWIdDklkn2s?feat=directlink">painted</a>
  "2000 mi.", meaning that we still had two thousand miles to go --
  even after almost two weeks of hiking.
</p>
<p>
  When we got to the camp site five miles from Stratton, there was a
  decision to make.  We had done 10 miles, but it had been 10 hard
  miles.  The rest of the way to the road would be all downhill, and
  there would be no more camping possibilities.  Picker left the
  decision up to me, but I could tell that he really wanted to go on.
  After a rest for my back (which still hadn't gotten as strong as
  would get), I decided that we should try to get to the road.  We
  also talked to a northbounder who said that the trail was pretty
  easy and that we could make it.  At that point, I had not learned to
  mistrust everything northbounders say.
</p>
<p>
  I would have done well to mistrust the northbounder.  The descent
  was really difficult.  However, I did see a <a href="https://picasaweb.google.com/lh/photo/bBFYuVIz4Xp42kq3LKPhEHIQdffm0dM4kWIdDklkn2s?feat=directlink">beaver</a>, so that made it
  kind of worth it.  When we got within two miles of the road, Picker
  started running.  I trotted along behind him, and we got to the road
  within thirty minutes.  We called the Stratton motel and were
  heartened to find that Grinner was already there.  She was feeling
  better, which was a huge relief.
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Stratton </h2>
<div class="outline-text-2" id="text-3">


<p>
  Since we had gone faster than expected between Monson and Stratton,
  and since Grinner still wasn't 100%, I decided to take an actual
  zero in Stratton.  I got a ride to Rangeley to get some better shoes
  and <a href="http://www.amazon.com/gp/product/B001Q1P0K2/ref=as_li_ss_tl?ie=UTF8&amp;tag=hikiandcodi-20&amp;linkCode=as2&amp;camp=217145&amp;creative=399373&amp;creativeASIN=B001Q1P0K2">hiking poles</a> at the outfitter there.  I still have those poles
  after more than 4000 miles, so I feel comfortable recommending
  them.
</p>
<p>
  The other big event from our zero day in Stratton is that we found a
  lady that was selling pies from her house.  She didn't have the
  proper food license to sell slices, so we were forced to buy a whole
  cheesecake.  We had no choice in the matter.  I think we showed
  great restraint by not eating the entire cheesecake in one sitting
  &ndash; we saved some for breakfast the next day.
</p>
<p>
  Oh, and one final story from Stratton.  We had caught up to Wounded
  Knee by getting there a day earlier than scheduled.  During
  conversation, he mentioned that he had an injury that he needed some
  help putting a bandage on.  Somehow, I was volunteered to help him
  out.  It turned out that he had a really bad chafe on his bum and
  couldn't quite see it to put the bandage on himself.  So I got to
  help out with that.  Blech.
</p>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Next time </h2>
<div class="outline-text-2" id="text-4">


<p>
  In the next installment, we go through Southern Maine.  This
  includes some of the most scenic and dangerous parts of the trail,
  including the <a href="http://en.wikipedia.org/wiki/Mahoosuc_Notch">Mahoosuc Notch</a>.
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Mon 28 Nov 2011 09:52:35 AM MST</span>
</span>


<span class="tags">
Tags:

<a href="./tags/AT/" rel="tag">AT</a>

<a href="./tags/hiking/" rel="tag">hiking</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="./posts/clojure-sorting/">Lazy Sorting in Clojure</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Penance </h2>
<div class="outline-text-2" id="text-1">


<p>
  In a job interview last week I said a couple of things related to
  sorting in Clojure that turned out to be incorrect when I checked
  them.  This is my way of making up for them &ndash; if I can make them
  true, then no one will notice.  Though to be fair, I'm sure that I'm
  the only one that thinks that way.
</p>
<p>
  The first thing I said was that heap-sort is my favorite sorting
  algorithm, but then I declined to implement it, preferring to
  implement merge-sort instead.  I think this is actually pretty
  reasonable in an interview situation &ndash; heap-sort is a conceptually
  more difficult sorting algorithm, so being able to remember it on
  the spot is more difficult.  The second thing I said was that
  Clojure itself uses heap-sort and that given its love affair with
  laziness that it would not be unreasonable to assume that <code>(first   (sort lst))</code> was a linear-time operation.  I might have read
  something like this on a mailing list or IRC, but it is not
  correct.  Clojure currently uses Java's <code>sort</code> function, which is a
  slightly-modified merge-sort.  There is not much point in making
  that algorithm lazy, because getting the first element from the
  sorted list requires \(O(n \log n)\) time anyway.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Heap Sort </h2>
<div class="outline-text-2" id="text-2">


<p>
  For those that are not familiar with it, heap-sort is something that
  is usually taught in a second-year undergraduate Computer Science
  class.  So it's not <b>that</b> difficult an algorithm, but it does
  require some thinking, and there is some fancy analysis that goes
  into part of it.  For a full discussion, see the <a href="http://www.amazon.com/gp/product/0262033844/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;tag=hikiandcodi-20&amp;linkCode=as2&amp;camp=217145&amp;creative=399369&amp;creativeASIN=0262033844">Introduction to Algorithms</a> book by Cormen, Lieserson, Rivest, and Stein.
</p>

</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">Heap </h3>
<div class="outline-text-3" id="text-2-1">


<p>
   To start with, a <i>heap</i> is conceptually a tree where values are
   stored at the nodes.  The largest value of all the values stored in
   subtrees is stored at the root and the two descendant trees are
   heaps.  Heaps are usually required to be as close to balanced as
   possible &ndash; if any level of the tree has leaves, they are all
   bunched to the right, and all the rest of the leaves are at the
   next level.
</p>
<p>
   Such a tree is usually implemented as an array, where the child
   nodes of a node can be obtained by some simple arithmetic on the
   index of the node in the array.
</p>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2">Building a Heap </h3>
<div class="outline-text-3" id="text-2-2">


<p>
   Given the definition, there is an intuitive algorithm for building
   such a heap on a set of numbers: first find the largest number in
   your set and have it be the root of the heap, then split the rest
   of the numbers in half, and recursively make heaps on those sets.
</p>
<p>
   Such an algorithm is clearly correct, but it is also clearly
   \(\Theta(n \log n)\).  We can do better with a bottom-up algorithm.
   If we continue imagining the heap as a tree, we start by putting
   the input numbers into the tree willy-nilly.  This clearly does not
   satisfy the heap properties laid out above.  However, some of it
   does satisfy the heap properties &ndash; the leaves of the tree are
   trivially heaps.  If we go up one level from the leaves, we can fix
   the trees rooted there by exchanging the root of the tree with its
   largest child (or not exchanging it if it's already the largest of
   the three).  Higher levels are a bit more difficult, because if the
   root of a tree is exchanged, then we must make sure to fix the tree
   that it ends up being the root of.  You can imagine the root of a
   tree traveling down the heap until it is larger than both of its
   children.
</p>
<p>
   The correctness of this algorithm is a bit harder to see and it
   also appears to take \(O(n \log n)\) time.  It does, but there is a
   slightly more sophisticated analysis that shows that it is really
   \(\Theta(n)\).  I won't go into the analysis, but a hint is that
   most of the values don't actually travel very far in the tree.  
</p>
</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3">Using a heap to sort </h3>
<div class="outline-text-3" id="text-2-3">


<p>
   With the heap properties in mind, we can easily see how to get the
   largest value of a set of numbers &ndash; just take the top element from
   the heap.  How can we use the heap properties to sort?  Well, we
   want the largest number, then the largest number that remains, then
   the largest number that remains after that, and so on.  So if we
   can take the largest number from the heap and then fix the heap so
   that it retains the heap properties, then we'd be done.
</p>
<p>
   We just devised a way to fix heaps when building the heap, so we
   use that.  What we do is to take the very last node in the heap
   (which is not necessarily the smallest, but it doesn't hurt to
   think about it as the smallest) and put that at the top of the
   heap.  The resulting tree is clearly not a heap, but if we call the
   algorithm to fix heaps on the root of the tree, then we end up with
   a heap again.  The node that we put on top of the heap might end up
   traveling all the way to the bottom, so this update takes
   \(\Theta(\log n)\) time.  Thus if we sort the entire input set, we
   have a \(\Theta(n \log n)\) algorithm.
</p>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4">Advantages </h3>
<div class="outline-text-3" id="text-2-4">


<p>
   That's the best we can do theoretically, which is great, but the
   Java <code>sort</code> algorithm is also \(\Theta(n \log n)\), so why is there
   any advantage to using heap-sort?  In a language where laziness is
   embraced (such as Clojure), heap-sort can be made lazy.  That is,
   the next element of the sorted list can be computed only when it is
   needed.  Since the build-heap procedure described above takes
   linear time, getting the first element from the sorted list takes
   \(O(n)\) time.  Each subsequent element then takes \(O(\log n)\)
   time.  Thus, if only a small number of elements from the sorted
   list are needed, then this lazy version of heap-sort is
   theoretically faster than other sorts.
</p>
<p>
   I can think of situations where this would actually have practical
   advantages.  For example, what if you were writing a search engine
   and wanted to obtain the \(k\) best results?  You could write an
   ad-hoc function that found the best result, removed it and recursed
   \(k - 1\) times.  Or you could just <code>(take k (heap-sort input))</code>.
   The first would take \(O(kn)\) time, whereas the second would take
   \(O(k \log n + n)\) time.  In many practical situations, \(k\) is
   \(\Omega(\log n)\), which means that the first takes \(\Omega(n
   \log n)\) time, whereas the second takes only \(O(n)\) time.
   Essentially, the first is no better than the second solution with a
   non-lazy sorting algorithm.
</p>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5">Disadvantages </h3>
<div class="outline-text-3" id="text-2-5">


<p>
   Heap-sort has some disadvantages compared to other sorts of <code>sort</code>
   algorithms.  The least theoretically significant is that the
   constants hidden in the big-O notation are higher than other
   sorting algorithms (tuned versions of quicksort can have extremely
   small constants).
</p>
<p>
   Another disadvantage can be seen when dealing with data sets so
   large that they no longer fit in the computer's main memory.
   Something like merge-sort can be modified fairly easily so that the
   number I/O operations is minimized.  I haven't thought about it too
   deeply, but this doesn't seem quite so easy with heap-sort.
   However, I think that people dealing with such large datasets
   should probably be using specialized libraries anyway, so perhaps
   that isn't too bad.
</p>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Implementation </h2>
<div class="outline-text-2" id="text-3">


<p>
  This whole discussion is a bit useless if it only remains at the
  theoretical level.  I have an implementation <a href="https://github.com/chrismgray/clojure-heap-sort">in my github repo</a> that
  implements most of the ideas that are given above.  The code is
  highly optimized so that it is somewhat competitive with the native
  Java implementation.  This makes the code on the HEAD of the
  <code>master</code> branch somewhat less than readable.  However, the first
  commit to the repository used Clojure vectors and a functional
  style, so if you would like to understand the code, you might start
  there. 
</p>
<p>
  I (unfortunately) needed to use Java arrays and mutation rather than
  the more functional style that I have gotten used to, but the
  results speak for themselves.  Finding the first few elements of a
  sorted array is significantly faster than the Java version.  Finding
  the entire sorted list is somewhat slower than the Java version, but
  not too much.  This is not surprising for a couple of reasons.
  First, heap-sort tends to have larger constants than other sorting
  methods.  Secondly, this code is one day old.  The Java sort method
  has had years to be optimized.
</p>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Conclusion </h2>
<div class="outline-text-2" id="text-4">


<p>
  It may be dreaming, but I would love to see this idea (if not this
  implementation) put into Clojure proper.  I think the advantages
  from laziness outweigh the small constant slowdown versus using
  Java's <code>sort</code>.
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Sun 27 Nov 2011 07:23:34 AM MST</span>
</span>


<span class="tags">
Tags:

<a href="./tags/clojure/" rel="tag">clojure</a>

<a href="./tags/lab-notes/" rel="tag">lab-notes</a>

<a href="./tags/sort/" rel="tag">sort</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="./posts/git-annex/">Git Annex</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Using git annex </h2>
<div class="outline-text-2" id="text-1">


<p>
  I remember being a young pup using Debian and reading the mailing
  lists.  I was always seeing the name <a href="http://joey.kitenet.net/blog/">Joey Hess</a> answering the tough
  questions.  I had great respect for him then, and it has remained to
  this day.  I have probably used his <code>unclutter</code> program for ten
  years and it has never crashed.  I recently installed <code>ikiwiki</code> to
  run this blog, <code>etckeeper</code> to track changes in my config files, and
  I figured that I should try his other recent software: <code>git-annex</code>.
</p>
<p>
  I came at it with two objectives: to be able to sync my podcasts and
  to be able to manage my media files better.  The second has worked
  really well, and the first <a href="http://git-annex.branchable.com/forum/Podcast_syncing_use-case/">is hopefully getting there soon</a>.  I will
  concentrate on the second for the moment, since that is what I have
  working the best.  There are multiple use-cases described on
  <a href="http://git-annex.branchable.com">git-annex's website</a> &ndash; I will just go through mine.
</p>
<p>
  All of my media files are on a terabyte external drive.  When I am
  at home, I have it mounted as an NFS drive on <code>/media/mybook</code>.  I
  have videos there, split into <code>tv</code> and <code>movies</code> folders, as well as
  music in the <code>music</code> folder.  All of the folders are treated the
  same, so I will just go through the procedure I used in the <code>music</code>
  folder.
</p>
<p>
  First, I set up the annex:
</p>



<pre class="example">~ $ cd /media/mybook/music
/media/mybook/music $ git init .
/media/mybook/music $ git annex init mybook-music
/media/mybook/music $ emacs .git/config
</pre>



<p>
  at this point, I set the <code>backends</code> keyword in the <code>[annex]</code> section
  to either <code>SHA1E</code> or <code>SHA256E</code>.  There is a tradeoff there between
  speed and safety &ndash; it is a bit more likely that two files hash to
  the same file with <code>SHA1E</code>, but it is faster than <code>SHA256E</code>.  The
  <code>E</code> at the end of the hash means that the filename extension is
  preserved in the hashing.  This is important for some mp3 players
  and other programs that can not tell what type a file is without an
  extension.  The next command takes a long time with a lot of files:
</p>



<pre class="example">/media/mybook/music $ git annex add .
[All the files are hashed and their contents are put into .git/annex]
[You will see that all your files are now symlinks to files in .git/annex]
/media/mybook/music $ git commit -m "Added my files"
</pre>



<p>
  Now it is possible to clone this repository back on the laptop
</p>



<pre class="example">~ $ git clone /media/mybook/music
~ $ cd music
~/music $ git annex init laptop-music
~/music $ git remote add mybook-music /media/mybook/music
~/music $ cd /media/mybook/music
/media/mybook/music $ git remote add laptop-music ~/music
</pre>



<p>
  And now all of the cool stuff can begin.  You can look inside the
  <code>~/music</code> directory and see that it appears that all your files are
  there.  However, they are not taking up any space.  What is
  happening is that they are broken symlinks to objects in
  <code>~/music/.git/annex</code>.  If I want to listen to some of the music, I
  move it over to the laptop with the following command
</p>



<pre class="example">~/music $ git annex get --from mybook-music Beatles/
</pre>



<p>
  I can now take my laptop on the plane and listen to the Beatles.
  When I'm back from my trip, I can free up the space by doing
</p>



<pre class="example">~/music $ git annex drop Beatles/
</pre>



<p>
  Suppose I obtain some new music, getting into the Rolling Stones.
  Then I can use <code>git annex add</code> to add the Stones into my collection,
  <code>git commit</code> them and <code>git pull</code> in the correct repository to
  duplicate the information.  I can then use <code>git annex copy</code> or <code>git   annex move</code> to put the files where I want them.
</p>
<p>
  For now, I have a queue of unseen videos and music that I want to
  hear on my laptop, while the bulk of my media collection sits on my
  external drive.  I can take what I want with me and not worry about
  my whole collection using up all of my hard drive.  I can see what I
  have in a particular repository with the <code>git annex find</code> command.
</p>
<p>
  As I said, there are many other uses for git-annex and features that
  I have not yet learned.  One thing that I am interested in trying
  out is using the <a href="http://git-annex.branchable.com/special_remotes/web/">web</a> as a repository.
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Wed 23 Nov 2011 08:02:00 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="./tags/git/" rel="tag">git</a>

<a href="./tags/git-annex/" rel="tag">git-annex</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="./posts/processing/">Processing</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Viewing visibility polygons </h2>
<div class="outline-text-2" id="text-1">


<p>
  I mentioned yesterday that it would be nice to see the output of my
  visibility polygon solution.  To that end, I created an extremely
  simple drawing editor using <a href="http://processing.org/">Processing</a>.  I have to say, I loved it.
</p>
<p>
  The most important feature to me is the extreme interactivity.  I
  can change functions extremely quickly with my tools &ndash; redefining a
  Clojure function is either one or two keystrokes in emacs, depending
  how I choose to do it &ndash; so I like a graphics environment that
  changes just as quickly.  This is what Processing, and in particular
  <code>clj-processing</code>, offers.  I was able to define a function that
  draws the various objects (in this case, the polygon, the point
  where the mouse is, and the visibility polygon of the mouse point
  inside the polygon).  If I wanted to make any changes to this
  function &ndash; for example, changing the color of the point where the
  mouse is &ndash; I can simply redefine the function using my emacs tools
  and the change shows up immediately on the drawing.
</p>
<p>
  I was able to use this to find a couple of minor bugs in my
  visibility-polygon-finding code, but in general, it worked really
  well on the first try.
</p>

</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">Shortcomings </h3>
<div class="outline-text-3" id="text-1-1">


<p>
   There were a couple of things that slightly bothered me about
   <code>clj-processing</code>.  First, it used quite a lot of CPU just to
   display a simple polygon without too many points.  I am probably
   using it rather navely, so it is possible that this is my problem
   and not the problem of <code>clj-processing</code>.  However, the second
   problem is just that <code>clj-processing</code> is showing its age.  I think
   it was probably one of the first Clojure libraries out there and
   much of the coding style hasn't evolved with the Clojure best
   practices that people use.  For example, some of the features do
   not work if you only <code>require</code> the library &ndash; you must <code>use</code> it.  I
   try to only <code>require</code> libraries, to avoid my namespace becoming
   overly populated, so it is frustrating when that doesn't work.
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Going forward </h2>
<div class="outline-text-2" id="text-2">


<p>
  I need to clean up the code a bit before I can put it up on github,
  but it should be there soon.  It currently needs me to explicitly
  call the function in order to find the visibility polygon.  I would
  really like it to find the visibility polygon of any point where the
  mouse is inside the polygon.  However, determining if a point is
  inside a non-convex polygon tends to be a bit harder than it
  sounds.  You can shoot a ray in one direction from a point, and
  count the number of polygon edges that it crosses &ndash; if it's even
  you are outside and if it's odd you are inside &ndash; but what happens
  if the ray crosses a vertex?  There was a good experimental paper on
  this problem at a recent EuroCG.
</p>
<p>
  So that's a slightly non-trivial problem.  I also coded an
  implementation of the Voronoi Diagram problem recently.  I should
  add a Processing UI to that as well.  I have a feeling that would be
  the easier task to do next, and I would surely discover some bugs in
  it while I did.
</p>


</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Tue 22 Nov 2011 12:29:29 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="./tags/clojure/" rel="tag">clojure</a>

<a href="./tags/lab-notes/" rel="tag">lab-notes</a>

<a href="./tags/processing/" rel="tag">processing</a>

<a href="./tags/visibility-polygon/" rel="tag">visibility-polygon</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="./posts/visibility-polygon/">Visibility Polygons</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Visibility Polygon </h2>
<div class="outline-text-2" id="text-1">


<p>
  I've put up some preliminary code for finding visibility polygons on
  my <a href="https://github.com/chrismgray/visibility-polygon">github repo</a>.  I have only tested it with one polygon, but so far
  things are looking good.  My idea from yesterday of using monads to
  "parse" the polygon seems to be paying off.  Here is the relevant
  code:
</p>



<pre class="src src-clojure">(<span style="color: #f0dfaf; font-weight: bold;">defn-</span> <span style="color: #8cd0d3;">add-new-pt</span> [poly]
  (<span style="color: #f0dfaf;">fn</span> [pt stack]
    (<span style="color: #8cd0d3;">when</span> (<span style="color: #8cd0d3;">or</span> (<span style="color: #f0dfaf;">empty?</span> stack) <span style="color: #708070;">; </span><span style="color: #7f9f7f;">First two points are guaranteed to be visible</span>
              (<span style="color: #f0dfaf;">empty?</span> (<span style="color: #f0dfaf;">rest</span> stack))
              (visible? pt (<span style="color: #f0dfaf;">first</span> poly) (<span style="color: #f0dfaf;">first</span> stack)))
      [pt (<span style="color: #f0dfaf;">rest</span> poly) (<span style="color: #f0dfaf;">cons</span> (<span style="color: #f0dfaf;">first</span> poly) stack)])))

(<span style="color: #f0dfaf; font-weight: bold;">defn-</span> <span style="color: #8cd0d3;">pop-stack</span> [poly]
  (<span style="color: #f0dfaf;">fn</span> [pt stack]
    (<span style="color: #8cd0d3;">let</span> [the-seg (seg/new-seg pt (<span style="color: #f0dfaf;">first</span> poly))
          top-seg (seg/new-seg (<span style="color: #f0dfaf;">first</span> stack) (<span style="color: #f0dfaf;">second</span> stack))]
      (<span style="color: #8cd0d3;">when</span> (pt/left-turn? (<span style="color: #f0dfaf;">second</span> stack) (<span style="color: #f0dfaf;">first</span> stack) (<span style="color: #f0dfaf;">first</span> poly))
        (<span style="color: #8cd0d3;">if</span> (seg/intersection-on-seg? the-seg top-seg)
          [pt poly (<span style="color: #f0dfaf;">cons</span> (seg/<span style="color: #dfdfbf; font-weight: bold;">intersection</span> the-seg top-seg) stack)]
          [pt poly (<span style="color: #f0dfaf;">rest</span> stack)])))))

(<span style="color: #f0dfaf; font-weight: bold;">defn-</span> <span style="color: #8cd0d3;">skip-pt</span> [poly]
  (<span style="color: #f0dfaf;">fn</span> [pt stack]
   (<span style="color: #8cd0d3;">let</span> [the-seg (seg/new-seg pt (<span style="color: #f0dfaf;">first</span> stack))
         poly-seg (seg/new-seg (<span style="color: #f0dfaf;">first</span> poly) (<span style="color: #f0dfaf;">second</span> poly))]
     (<span style="color: #8cd0d3;">when</span> (<span style="color: #f0dfaf;">not</span> (pt/left-turn? (<span style="color: #f0dfaf;">second</span> stack) (<span style="color: #f0dfaf;">first</span> stack) (<span style="color: #f0dfaf;">first</span> poly)))
       (<span style="color: #8cd0d3;">if</span> (seg/intersection-on-seg? the-seg poly-seg)
         [pt (<span style="color: #f0dfaf;">cons</span> (seg/<span style="color: #dfdfbf; font-weight: bold;">intersection</span> the-seg poly-seg) (<span style="color: #f0dfaf;">rest</span> poly)) stack]
         [pt (<span style="color: #f0dfaf;">rest</span> poly) stack])))))

(<span style="color: #f0dfaf; font-weight: bold;">defn-</span> <span style="color: #8cd0d3;">all-conditions</span> [poly]
  (with-monad polygon-parser-m
    (m-plus (add-new-pt poly) (pop-stack poly) (skip-pt poly))))
</pre>




<p>
  This defines three actions to be performed when the polygon and
  stack are in certain configurations.  The first executes when the
  next point on the polygon doesn't obscure any of the stack.  In that
  case, it removes the point from <code>poly</code> and puts it on <code>stack</code>.  The
  second executes by popping points off the stack until the next point
  on the polygon no longer obscures the stack.  The final condition
  activates when the next point on the polygon is hidden by the
  stack.  It skips the points of <code>poly</code> until it finds one that would
  be visible.  We combine the three conditions using <code>m-plus</code>, which
  is defined to try the conditions in order until one returns
  something that is not <code>nil</code>.
</p>
<p>
  Is this solution any better than a functional programming solution
  without monads?  I think it is.  First, the conditions are easy to
  see and very explicitly laid out.  Using a <code>cond</code> to accomplish the
  same thing is certainly possible, but gets more complicated as the
  number of conditions grows.  Also, we are explicitly managing state
  in this solution.  Doing so in an ad-hoc manner would be much more
  difficult.  In fact, I am not really sure how I would loop until
  there are no more points in <code>poly</code> in a solution without monads
  (especially since not all the conditions consume a point from
  <code>poly</code>).  With monads, it is quite simple:
</p>



<pre class="src src-clojure">(<span style="color: #f0dfaf; font-weight: bold;">defn-</span> <span style="color: #8cd0d3;">visibility-polygon-helper</span> [pt poly]
  ((with-monad polygon-parser-m
     (m-until empty? all-conditions poly)) pt []))
</pre>




<p>
  Doing something like that with a <code>reduce</code> seems like it would veer
  off into unreadability fairly quickly.
</p>
<p>
  Are there downsides to this solution?  I think there is at least
  one.  That is, the conditions must be functions that return functions.
  This makes them a bit more confusing than they really should be.  I
  needed to do this so that I could have a test in the <code>m-until</code>
  function above.  On the whole, though, this is a fairly cosmetic
  gripe, and can be hidden by using helper functions like the one
  above.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">On the horizon </h2>
<div class="outline-text-2" id="text-2">


<p>
  I would like to test the code quite a bit more.  However, doing so
  by drawing out polygons by hand and then figuring out their
  visibility polygons is quite tedious.  Therefore, I need some sort
  of GUI to be able to draw polygons and then I will be able to
  see whether the computed visibility polygon makes sense.
</p>
<p>
  I am thinking that it might be nice to use the <a href="https://github.com/rosado/clj-processing"><code>clj-processing</code> library</a> to do this.  Unfortunately, that library is currently only
  using Clojure 1.2.  Since I am using Clojure 1.3, that might be a
  problem.  So I might need to do some porting from 1.2 to 1.3.
  However, doing so should give me a good idea of how processing
  works, and could give a nice tool for more interactive geometry
  programs. 
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Mon 21 Nov 2011 12:44:43 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="./tags/clojure/" rel="tag">clojure</a>

<a href="./tags/computational-geometry/" rel="tag">computational-geometry</a>

<a href="./tags/lab-notes/" rel="tag">lab-notes</a>

<a href="./tags/visibility-polygon/" rel="tag">visibility-polygon</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="./posts/parsing-polygons/">Parsing Polygons</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Functional programming </h2>
<div class="outline-text-2" id="text-1">


<p>
  I've gotten a bit obsessed by functional programming over the last
  couple of years.  I have even seriously thought about writing a book
  that looks at computational geometry (which is the subject in which
  I was trained) in the light of functional programming.  Most of the
  standard computational-geometry texts these days approach the
  writing of code from an imperative standpoint.
</p>
<p>
  I think functional programming is a good way to think about
  computational geometry for a couple of reasons.  First, most
  problems in computational geometry can be expressed in a purely
  functional manner.  That is, the answers to the problems are usually
  the same given the same inputs.  Secondly, I have bought into the
  idea that parallel and distributed computing are much easier when
  state is not being modified.  Functional programming forces you to
  think this way.  While many problems in computational geometry are
  inherently sequential, not all of them are.  Using a programming
  method that allows for the easy addition of more cores seems like a
  good practice when a problem is encountered that is easily made
  parallel. 
</p>
<p>
  One of the things I have been thinking about as a final chapter for
  the book that I would like to write is the introduction of monads as
  a way to "parse" polygons.  Monads are commonly used (well, commonly
  in the functional programming world) to parse strings.  They
  generally scan through with the aid of a stack.  There are many
  algorithms that scan through the points of a polygon with a stack --
  the example that I have thought about the most is the visibility
  polygon.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Visibility polygons </h2>
<div class="outline-text-2" id="text-2">


<p>
  A <i>visibility polygon</i> is the subset of a polygon that can be "seen"
  from a point inside the polygon.  Here, we regard the segments of
  the polygon as opaque walls.
</p>
<p>
  The standard algorithm for computing the visibility polygon is not
  too difficult to implement in an imperative language.  In fact, I
  <a href="http://www.win.tue.nl/~cgray/ipelets.html">implemented</a> it already in C++ for the drawing editor <a href="http://tclab.kaist.ac.kr/ipe/">ipe</a>.  (Though I
  think that code is now obsolete since the release of ipe 7.)
</p>
<p>
  I've already tipped my hand at how I would think about implementing
  such an algorithm in a functional language.  I would use a variant
  of a monadic parser to go through the polygon and find the parts
  that are visible.  (That last sentence doesn't give much of a hint
  about how it's done, but the whole algorithm would take too much
  space to describe.  Suffice it to say that a stack is kept with the
  "currently visible" portion of the polygon always on the stack.)
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Monads </h2>
<div class="outline-text-2" id="text-3">


<p>
  I used monads <a href="http://chrismgray.github.com/posts/time-series-2/">earlier</a> to make a framework for creating and comparing
  time-series.  However, I only used a monad that was already defined
  by someone else.  I think I might need to define a monad on my own
  this time &ndash; a slightly daunting idea.  I definitely need to read
  the rest of <a href="http://intensivesystems.s3-website-us-east-1.amazonaws.com/tutorials/monads_201.html">Jim Duey's tutorial</a> to make sense of how to do it.
</p>


</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Sun 20 Nov 2011 05:58:28 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="./tags/computational-geometry/" rel="tag">computational-geometry</a>

<a href="./tags/lab-notes/" rel="tag">lab-notes</a>

<a href="./tags/visibility-polygon/" rel="tag">visibility-polygon</a>

</span>








</div>

</div>


<p>This blog is powered by <a href="http://ikiwiki.info">ikiwiki</a>.</p>

</div>

</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'hikingandcoding'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


<div id="footer" class="pagefooter">

<div id="pageinfo">




<div id="backlinks">
Links:

<a href="./comments/">comments</a>

<a href="./posts/">posts</a>


</div>






<div class="pagedate">
Last edited <span class="date">Thu 10 Nov 2011 01:12:04 PM MST</span>
<!-- Created <span class="date">Tue 08 Nov 2011 11:43:03 PM MST</span> -->
</div>

</div>


<!-- from Hiking and Coding -->
</div>

</div>

</body>
</html>
