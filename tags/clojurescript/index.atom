<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom">
<title>pages tagged clojurescript</title>
<link href="http://chrismgray.github.com//tags/clojurescript/"/>
<link href="http://chrismgray.github.com//tags/clojurescript/index.atom" rel="self" type="application/atom+xml"/>
<author>

<name>Hiking and Coding</name>

</author>




<id>http://chrismgray.github.com//tags/clojurescript/</id>

<subtitle type="html">Hiking and Coding</subtitle>
<generator uri="http://ikiwiki.info/" version="3.20120202">ikiwiki</generator>
<updated>2012-04-20T23:18:48Z</updated>
<entry>
	<title>More Clojurescript Macros</title>

	<id>http://chrismgray.github.com//posts/cljs-macros-02/</id>

	<link href="http://chrismgray.github.com//posts/cljs-macros-02/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="macros" />


	<updated>2012-04-20T23:18:48Z</updated>
	<published>2012-04-20T22:47:21Z</published>

	<content type="html" xml:lang="en">
	
&lt;p&gt;Most of my time this week was spent traveling and in meetings, but I
did have a chance to work on the Clojurescript macro system that I
have been working on.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Testing&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  Things didn&#39;t start too well for the system, since it would not run
  the simplest of tests written for it in the Clojurescript testing
  system.  My test was a macro that would take a positive integer,
  recursively decrease it until it was zero, and then output the
  zero.  (Clearly not the smartest macro in the world &amp;ndash; it was just
  meant to test recursion.)  However, I kept getting errors saying
  that the system didn&#39;t know how to test equality among numbers.
  This seemed strange until I realized that the &lt;code&gt;extend-type&lt;/code&gt; call for
  numbers wasn&#39;t getting executed because it wasn&#39;t expanded into a
  &lt;code&gt;def&lt;/code&gt;.  (I had been executing all &lt;code&gt;def&lt;/code&gt; calls, which defined all
  functions and variables, but nothing else.)
&lt;/p&gt;
&lt;p&gt;
  So I briefly flirted with executing a bunch of other special forms,
  including &lt;code&gt;set!&lt;/code&gt; and &lt;code&gt;deftype&lt;/code&gt;, but I could see that this would make
  things pretty unwieldy, and that the compiler would be doing a lot
  of confusing things, for example trying to execute a &lt;code&gt;set!&lt;/code&gt; that was
  buried deep inside a function without being able to know anything
  about the locals that it was being set to.
&lt;/p&gt;
&lt;p&gt;
  That was clearly the way of madness, so I eventually decided to
  execute every special form that was at the top level.  This worked
  really well, and the tests started passing.
&lt;/p&gt;
&lt;p&gt;
  I also added tests to make sure that the namespaces work as
  expected.  You can &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; macros from other namespaces
  just like other functions.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;What&#39;s not there (yet)&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  So far I have not added the &lt;code&gt;&amp;amp;env&lt;/code&gt; and &lt;code&gt;&amp;amp;form&lt;/code&gt; variables to macros.
  I expect that it will be necessary to add them at some point (and
  honestly not too hard).  I know they are extremely useful in some
  projects like &lt;a href=&quot;https://github.com/clojure/core.match&quot;&gt;core.match&lt;/a&gt;, but that project has already been ported
  to Clojurescript (via Clojure macros), so it might make more sense
  to leave the large macros that need those facilities to Clojure.
&lt;/p&gt;
&lt;p&gt;
  Backquoted forms don&#39;t work as nicely as in Clojure.  The reason is
  that we are using Clojure&#39;s reader, which qualifies backquoted
  symbols with their full namespace.  Unfortunately, it doesn&#39;t know
  anything about Clojurescript namespaces, so expect to need to
  qualify symbols inside backquotes.  This is an area where true
  reader macros inside Clojure would be really helpful, but we have to
  live with what we have.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;One step closer&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  &amp;hellip; to Clojure in Clojure.  Clojurescript already has a reader and a
  compiler that can compile most of itself.  The reader isn&#39;t totally
  complete &amp;ndash; it doesn&#39;t have backquote working yet for example &amp;ndash; but
  it is close.  It recently got persistent vectors and persistent
  hash-maps.  With macros added, all that&#39;s left for Clojure in
  Clojure is to finish up the reader and get rid of the calls to
  Java.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/cljs-macros-02/#comments" type="text/html" />


	<link rel="comments" href="/posts/cljs-macros-02/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Clojurescript Macros</title>

	<id>http://chrismgray.github.com//posts/cljs-macros/</id>

	<link href="http://chrismgray.github.com//posts/cljs-macros/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="macros" />


	<updated>2012-04-11T06:33:51Z</updated>
	<published>2012-04-11T05:36:33Z</published>

	<content type="html" xml:lang="en">
	
&lt;p&gt;Today I wrote a proof-of-concept implementation of a macro system for
Clojurescript.  The code is &lt;a href=&quot;https://github.com/chrismgray/clojurescript/tree/defmacro&quot;&gt;here&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
Clojurescript already had a sort of macro system in the form of
Clojure macros, but this is different &amp;ndash; the macros are written in
Clojurescript, get compiled to JavaScript, and are evaluated by a
JavaScript interpreter.  They can be mixed in with Clojurescript code
and call Clojurescript functions.  In theory, they should work with
any Clojurescript backend that implements the REPL-related protocols
(but who knows if that&#39;s true).
&lt;/p&gt;
&lt;p&gt;
So that&#39;s the big announcement.  What follows are some implementation
details and other notes.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Implementation details&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  The macros are defined by passing strings back and forth between the
  Clojurescript compiler and the Rhino JavaScript interpreter.  The
  strings from Rhino are read by Clojure using &lt;code&gt;read-string&lt;/code&gt;, so
  macros are limited to things that can be printed by Clojurescript in
  a form that Clojure can read.
&lt;/p&gt;
&lt;p&gt;
  Macros are not yet put into the correct namespaces.  I don&#39;t think
  it will be too hard to do that correctly though.
&lt;/p&gt;
&lt;p&gt;
  Rhino is a slow beast.  It adds multiple seconds to the startup time
  of the compiler.  It might be smart to scan the file for calls to
  &lt;code&gt;defmacro&lt;/code&gt; before including the macro-interpreting code.  However,
  since macro expansion requires that all functions are defined in the
  interpreter, once a &lt;code&gt;defmacro&lt;/code&gt; is hit, all the functions in the file
  preceding it (and in all &lt;code&gt;require&lt;/code&gt;&#39;d files) must be re-parsed.
&lt;/p&gt;
&lt;p&gt;
  Existing Clojure macros should still work.  If two macros have the
  same name, the Clojurescript one will take precedence, but of course
  getting namespaces working should eliminate most conflicts.
&lt;/p&gt;
&lt;p&gt;
  It should go without saying that this is completely experimental at
  this point.  Things seem like they work to me, but they might yet
  blow up in unexpected ways.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;An example&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  Here is a simple Clojurescript file which implements the &lt;code&gt;unless&lt;/code&gt;
  macro (also known as &lt;code&gt;when-not&lt;/code&gt; in Clojure, but I think giving it a
  different name shows better that it is really not using the Clojure
  macros).
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(defmacro unless
  [pred &amp;amp; body]
  `(if (not ~pred)
     (do ~@body)
     nil))

(let [a (unless true (/ 1 0) (+ 1 1))]
  a)
&lt;/pre&gt;


&lt;p&gt;
  And here is its output:
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;var a__5799 = (cljs.core.truth_(cljs.core.not.call(null,true))?(function (){(1 / 0);
return (1 + 1);
})():null);

a__5799;
&lt;/pre&gt;


&lt;p&gt;
  It&#39;s a bit ugly, but it should be obvious what&#39;s going on.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  I&#39;m pretty happy with the progress so far.  It really shows how
  flexible the Clojurescript compiler is that a macro system could be
  added in under 75 lines of code, with nearly half of that being very
  lightly modified from the compiler itself.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/cljs-macros/#comments" type="text/html" />


	<link rel="comments" href="/posts/cljs-macros/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Clojure Data Structures</title>

	<id>http://chrismgray.github.com//posts/clojure-data-structures/</id>

	<link href="http://chrismgray.github.com//posts/clojure-data-structures/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />


	<updated>2012-04-01T01:27:15Z</updated>
	<published>2012-04-01T01:27:15Z</published>

	<content type="html" xml:lang="en">
	
&lt;p&gt;This past week, I&#39;ve been knee-deep in Clojure data structures --
mostly persistent vector and hash-map.  The goal has been to provide
replacements written in pure Clojure that can be ported to
ClojureScript, but it has also been a great way to learn about how
these structures work.  So in this post, I&#39;ll try to summarize what I
learned, and give some the results of my hacking.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Vector&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I started this project inspired by a tweet by &lt;a href=&quot;https://twitter.com/#!/swannodette&quot;&gt;David Nolen&lt;/a&gt;.  I can&#39;t
  find it any more, but he mentioned that he had ported the
  persistent-vector data structure to JavaScript and that he was
  hoping to use it in ClojureScript.  That made me think: since
  the ClojureScript compiler now supports languages other than
  JavaScript as its backends, wouldn&#39;t it be helpful, at least for
  those backends, to port the data structure to pure Clojure, so that
  any ClojureScript backend could use it?
&lt;/p&gt;
&lt;p&gt;
  So I did.  The result is &lt;a href=&quot;https://github.com/chrismgray/persistent-data-structures/blob/master/src/persistent_data_structures/vector.clj&quot;&gt;here&lt;/a&gt;.  Instead of merely mechanically
  porting the Java into Clojure, I tried to really understand what was
  going on.  The gist is really simple (and has been talked about
  before): the vector is actually a tree with branching-factor 32, and
  a buffer of size 32.  When you add to the vector, you really add to
  the buffer if you can, copying the buffer before writing to it.
  When the buffer fills up, it is put in the tree, and again nodes are
  copied rather than simply written-to.
&lt;/p&gt;
&lt;p&gt;
  This procedure means that adding an element is a \(O(\log n)\)
  operation, but the constants are really good: for one thing, the
  base of the \(\log\) is 32, so the influence of the \(\log n\) in
  the overall running time is pretty small even for very large \(n\).
  For another thing, the \(\log n\) penalty is only incurred on every
  thirty-second insert.  Most inserts are constant-time.
&lt;/p&gt;
&lt;p&gt;
  Another cool feature is the way that the tree is structured.  Each
  node has its children in an array of length 32.  This means that the
  subtree that contains a given element can be found very quickly by
  simple bit operations.  To find the subtree containing element \(i\)
  in tree level \(k\), you shift \(i\) to the right by \(5k\) places
  and take the rightmost 5 bits.  This procedure would work with
  arrays that are of length of any power of 2, where you replace 5 by
  the \(\log_2\) of the length.
&lt;/p&gt;
&lt;p&gt;
  Anyway, László Török had pretty much the same idea as I did (and the
  author of gvec.clj, which is in the core distribution, had the same
  idea before either of us), and his code was better-tuned than mine,
  so it is what went into the new release of ClojureScript.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;An aside&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;


&lt;p&gt;
   When vectors are created in Clojure (but not yet in ClojureScript),
   they are created by way of a transient vector.  The idea behind this
   is that the transient vector is only around for the creation of the
   vector, so it does not need to be persistent.  Thus, it does not
   need to use the copy-on-write policy that persistent vectors use.
   In order to build a larger vector, it simply adds to an empty vector
   using the same procedure that I outlined above.
&lt;/p&gt;
&lt;p&gt;
   Theoretically at least, that is not the optimal algorithm.  The
   trees can be built from the bottom-up (much like &lt;a href=&quot;http://chrismgray.github.com//tags/clojurescript/./../../posts/clojure-sorting&quot;&gt;heaps&lt;/a&gt;), giving a
   \(O(n)\) algorithm, which also has very good constants.  I haven&#39;t
   computed the constant, but it should be less than \(1 {1 \over
   16}\).  I implemented this algorithm in Clojure, but the difference
   in constants between Clojure code and pure Java code, and the fact
   that the constants in the Java implementation are &lt;b&gt;so&lt;/b&gt; low meant
   that my implementation was slower even for very large \(n\).  I may
   one day try to port my bottom-up algorithm back to Java, but I kind
   of doubt it would make much difference.  Sometimes the
   theoretically better solution just isn&#39;t better in the real world.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Hash Maps&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I also had a look at hash maps.  The basic idea behind any hash-map
  is to store a key-value pair by first computing the &lt;i&gt;hash&lt;/i&gt; of the
  key to something much smaller &amp;ndash; in Clojure&#39;s case a 32-bit integer
  &amp;ndash; and then storing the pair in a location based on that hash.
  There are many ways that this could be done, and I had a look at the
  Java implementation used in Clojure and decided that I didn&#39;t really
  want to do much more porting.  So I came up with a couple of ideas
  that are related to Clojure&#39;s way of doing it.
&lt;/p&gt;
&lt;p&gt;
  The first idea was to make the same tree as used in the vector
  implementation, but to fill it in only as needed.  In essence, this
  was a sparse vector.  The Clojure implementation does something
  similar to this, but goes one step further by using a bit-map to
  signify which branches of the tree are actually used.  In this way,
  it can avoid copying arrays that are mostly full of placeholders.
&lt;/p&gt;
&lt;p&gt;
  The next idea was a bit more radical.  It involved making a &lt;a href=&quot;https://en.wikipedia.org/wiki/Patricia_trie&quot;&gt;radix tree&lt;/a&gt; of the input data.  Of all my experiments, this might have been
  the most successful.  In Clojure, its performance is very close to
  the built-in data structure.  In ClojureScript, for some reason it
  is much faster at storing new data than the built-in data structure
  but somewhat slower at retrieving data.  I am thinking that there
  must be some JavaScript-specific reason for this, but I haven&#39;t
  found it yet.  It could just be that the ClojureScript data
  structure is asymmetric in the opposite way (I haven&#39;t yet looked
  very deeply at it).
&lt;/p&gt;
&lt;p&gt;
  In all cases, the theoretical running times are pretty much what
  you&#39;d expect.  To either insert a new key-value pair or to find a
  key, it&#39;s basically the sum of the time needed to hash the key, a
  constant to find the place where the key is stored, and then
  something proportional to the number of other keys that have the
  same hash value that have been inserted so far.
&lt;/p&gt;
&lt;p&gt;
  In practice, large collections must be hashed each time they&#39;re
  inserted or searched for, so using them as keys is probably not a
  great idea.  In Clojure, negative numbers hash to one less than
  their absolute value, so there will probably be collisions if you
  use a large number of positive and negative numbers as keys, but
  it&#39;s not that big of a deal, since the number of collisions
  generated by this is at most two.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Conclusions&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  At the very least, this was a good way to learn what&#39;s really going
  on under the hood.  I also did a lot of tuning &amp;ndash; not only adding
  typehints, but re-implementing some lazy functions to be non-lazy --
  which is certainly good experience.  I never made a data structure
  that was faster than one of the ones implemented in Java, but I got
  pretty close in both cases.  In order to get meaningful tests, I had
  to do things in a very big way: putting millions of things in
  vectors, and querying hash-maps hundreds of thousands of times.
  Most programs will not do these operations at such scales, and most
  of the tests still took less than a second on my underpowered
  laptop.  That makes me think pretty highly of the existing data
  structures in Clojure.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/clojure-data-structures/#comments" type="text/html" />


	<link rel="comments" href="/posts/clojure-data-structures/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>SPOT Tracks</title>

	<id>http://chrismgray.github.com//posts/spot-tracks/</id>

	<link href="http://chrismgray.github.com//posts/spot-tracks/"/>






	<category term="clojurescript" />

	<category term="hiking" />

	<category term="spot" />


	<updated>2011-12-01T07:44:36Z</updated>
	<published>2011-11-16T16:20:05Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Where I was&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I finally have a Clojurescript application that works basically the
  way I want it to.  It shows a Google Map of the US onto which is
  added a series of markers.  The markers are placed at the positions
  that I sent a SPOT message on one of my hikes.  They are dropped at
  intervals that correspond to the intervals between me sending them
  out.  The whole thing takes a minute to watch.  There are a couple
  of parts where it seems like nothing is happening &amp;ndash; those are
  winter when I wasn&#39;t hiking and a period of time between when the
  SPOT stopped working and when I got the replacement.  The app is
  &lt;a href=&quot;http://chrismgray.github.com/posts/spot-tracks/view.html&quot;&gt;here&lt;/a&gt;.  The &lt;a href=&quot;https://github.com/chrismgray/spot-tracks&quot;&gt;source code&lt;/a&gt; is on my github page, but it is mostly
  unedifying. 
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/spot-tracks/#comments" type="text/html" />


	<link rel="comments" href="/posts/spot-tracks/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Scattered</title>

	<id>http://chrismgray.github.com//posts/scattered/</id>

	<link href="http://chrismgray.github.com//posts/scattered/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="email" />

	<category term="git" />

	<category term="git-annex" />

	<category term="notmuch" />

	<category term="spot" />


	<updated>2011-12-01T07:43:31Z</updated>
	<published>2011-11-14T17:11:23Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Scattered&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I am doing a bunch of things today, all fairly small.  I think it&#39;s
  because I finished working on the time series framework yesterday,
  so I&#39;m kind of at loose ends.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;New programming project&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  One thing that I would like to do is to take all the messages that I
  sent with my &lt;a href=&quot;http://findmespot.com&quot;&gt;SPOT&lt;/a&gt; device while hiking and make a small animation of
  them on Google Maps.  This would be another use of Clojurescript.
  My previous project &amp;ndash; a Clojurescript program for computing the
  Voronoi Diagram of a set of points input by a user &amp;ndash; is a bit
  stalled at the moment, so it&#39;s good to have something else to work
  on.  Also, I feel like adding points to a Google Map is something
  that Clojurescript is better suited to, rather than the fiddly
  numeric stuff that I was trying to make it do.  I will come back to
  the Voronoi Diagram at some point (hopefully fairly soon), but I am
  putting it on the back burner for the moment.
&lt;/p&gt;
&lt;p&gt;
  So far, I see two major tasks:
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-1&quot;&gt;Getting the coordinates and times of the SPOT messages&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-1&quot;&gt;


&lt;p&gt;
   Every SPOT message is an email that contains the coordinates of
   where and when the message was sent.  Parsing the email can be done
   offline, so I will probably just use Clojure for that.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-2&quot;&gt;Putting them on the Google Map&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-2&quot;&gt;


&lt;p&gt;
   The &lt;a href=&quot;http://code.google.com/apis/maps/documentation/javascript/overlays.html#Markers&quot;&gt;API&lt;/a&gt; for using Google Maps appears to be easy to use and
   well-thought-out.  There&#39;s even a way to drop the markers at
   different intervals &amp;ndash; just what I want to do.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Notmuch&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  I am also playing with the &lt;a href=&quot;http://notmuch.org&quot;&gt;notmuch&lt;/a&gt; email client.  So far I quite
  like it.  It&#39;s a heck of a lot faster than my previous mail client,
  mainly because it doesn&#39;t do as much.  Like gmail, it is optimized
  towards two operations: searching and tagging.  I never really used
  tags in gmail, because doing so involves clicking around, but it&#39;s
  much faster in notmuch.  So far, this seems like the big advantage
  for notmuch.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Git annex&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;


&lt;p&gt;
  In an effort to use all the software written by &lt;a href=&quot;http://joey.kitenet.net/&quot;&gt;Joey Hess&lt;/a&gt; (not
  really, but it seems like it), I am also trying out &lt;a href=&quot;http://git-annex.branchable.com/&quot;&gt;git annex&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
  So far, I have come up with one really compelling use case --
  syncing podcasts to my mp3 player.  My mp3 player has the problem
  that it will delete all the files on it at random times.  Thus, I
  need to keep a backup of all the files on it on my computer.
  However, when I am done listening to a podcast, I like to remove the
  file.  Hopefully, I will be able to sync the files that I remove
  myself (that is, remove them from the laptop), but not the files
  that get removed by the stupid thing crashing.
&lt;/p&gt;
&lt;p&gt;
  Another thing that I would like to do is put my music and video
  collections in git annex.  I&#39;m not sure that anything special would
  come from doing that, but it seems nice to have these things in
  version control.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/scattered/#comments" type="text/html" />


	<link rel="comments" href="/posts/scattered/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Resolving names in Clojurescript (followup)</title>

	<id>http://chrismgray.github.com//posts/cljs-name-resolving-2/</id>

	<link href="http://chrismgray.github.com//posts/cljs-name-resolving-2/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="rationals" />


	<updated>2011-12-02T16:41:31Z</updated>
	<published>2011-11-12T01:07:52Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Done!&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I was close with my guess in the last post.  What ended up working
  was
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(let [name (munge (symbol (str (-&amp;gt; env :ns :name) &quot;.&quot; (munge (str sym)))))])
&lt;/pre&gt;


&lt;p&gt;
  For some reason, &lt;code&gt;(name sym)&lt;/code&gt; would crash the compiler from the
  &lt;code&gt;parse&lt;/code&gt; method but it wouldn&#39;t from other functions caled from the
  &lt;code&gt;parse&lt;/code&gt; method.  I finally gave up worrying about that and just used
  &lt;code&gt;(str sym)&lt;/code&gt; instead, since that is guaranteed to be the same in this
  case &amp;ndash; there is an &lt;code&gt;(assert (not (namespace sym)))&lt;/code&gt; just before the
  &lt;code&gt;let&lt;/code&gt; line.  I gave up on worrying about it, but someone who knows
  more about the compiler than me might want to try to figure out why
  it is.
&lt;/p&gt;
&lt;p&gt;
  I also needed to allow names defined in &lt;code&gt;cljs.core&lt;/code&gt; but redefined in
  another namespace to be called or referred to.  This involved
  changing the &lt;code&gt;resolve-existing-var&lt;/code&gt; function.  Again, &lt;code&gt;cljs.core&lt;/code&gt; is
  hardcoded:
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(let [full-ns (if (and (core-name? env sym) (nil? (get-in @namespaces [(-&amp;gt; env :ns :name) :defs sym])))
                &#39;cljs.core
                (-&amp;gt; env :ns :name))])
&lt;/pre&gt;


&lt;p&gt;
  I added the second test: it simply asks whether the variable has
  been defined in the namespace.  If it hasn&#39;t, and the variable is
  defined in &lt;code&gt;cljs.core&lt;/code&gt;, only then is the namespace set to
  &lt;code&gt;cljs.core&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Remove the macros&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  It was also necessary to remove many of the macros from &lt;code&gt;core.clj&lt;/code&gt;
  in order to redefine the functions that I needed to in my project.
  As I noted earlier, my project is to implement rationals in
  Clojurescript, so I need to redefine most of the functions that work
  with numbers.  (At least, that is the way I am implementing it --
  there may be a better way that I don&#39;t know about.)  Many of these
  functions were implemented twice: once as a macro in &lt;code&gt;core.clj&lt;/code&gt; and
  once as a function in &lt;code&gt;core.cljs&lt;/code&gt;.  I am obviously biased towards
  being able to redefine these functions, so I think the macros should
  be removed, but at least one of the implementations is redundant.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/cljs-name-resolving-2/#comments" type="text/html" />


	<link rel="comments" href="/posts/cljs-name-resolving-2/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Resolving names in Clojurescript</title>

	<id>http://chrismgray.github.com//posts/cljs-name-resolving/</id>

	<link href="http://chrismgray.github.com//posts/cljs-name-resolving/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="rationals" />


	<updated>2011-12-02T16:39:57Z</updated>
	<published>2011-11-11T14:23:38Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Resolving names as they are compiled in Clojurescript&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I think I found the bug in the Clojurescript compiler that I was
  &lt;a href=&quot;http://chrismgray.github.com/more-rationals&quot;&gt;looking for yesterday&lt;/a&gt;.  Just to refresh the memory, when defining a
  function that has a function of the same name in &lt;code&gt;cljs.core&lt;/code&gt;, the
  compiler will assume that you are trying to redefine the function
  from &lt;code&gt;cljs.core&lt;/code&gt;, rather than the function in the namespace that you
  are actually in.  Since I am trying to redefine functions like &lt;code&gt;/&lt;/code&gt;
  and &lt;code&gt;*&lt;/code&gt;, this is a problem.
&lt;/p&gt;
&lt;p&gt;
  Let&#39;s look at the evidence.  First, there&#39;s this:
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(defmethod parse &#39;def
  [op env form name]
  (let [pfn (fn ([_ sym] {:sym sym})
              ([_ sym init] {:sym sym :init init})
              ([_ sym doc init] {:sym sym :doc doc :init init}))
        args (apply pfn form)
        sym (:sym args)]
    (assert (not (namespace sym)) &quot;Can&#39;t def ns-qualified name&quot;)
    (let [name (munge (:name (resolve-var (dissoc env :locals) sym)))])))
&lt;/pre&gt;


&lt;p&gt;
  The important line there is the last: when defining a new name,
  &lt;code&gt;resolve-var&lt;/code&gt; is called on the symbol.  Let&#39;s have a look at that
  function.  There is a &lt;code&gt;cond&lt;/code&gt;, and when none of the tests return
  true, the following is done:
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(munge (symbol (str
                (if (core-name? env sym)
                  &#39;cljs.core
                  (-&amp;gt; env :ns :name))
                &quot;.&quot; (munge (name sym)))))
&lt;/pre&gt;


&lt;p&gt;
  This is seeing if the symbol name is in &lt;code&gt;cljs.core&lt;/code&gt;, and if it is
  setting the namespace of the symbol to &lt;code&gt;cljs.core&lt;/code&gt;.  Normally that
  would be correct &amp;ndash; one doesn&#39;t want to need to &lt;code&gt;use&lt;/code&gt; &lt;code&gt;cljs.core&lt;/code&gt; in
  every file &amp;ndash; but it doesn&#39;t allow for redefinition of functions
  that are in &lt;code&gt;cljs.core&lt;/code&gt; (at least without completely shadowing
  them).
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;What to do&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  So what can we do about this?  The first thing that seems odd to me
  is that the symbol being defined is being resolved first.  Every
  symbol that is defined is defined within its own namespace, so there
  should be no need to resolve it.  That suggests that we should be
  able to take the part of &lt;code&gt;resolve-var&lt;/code&gt; that doesn&#39;t have a special
  case for &lt;code&gt;cljs.core&lt;/code&gt; and put it into the &lt;code&gt;parse&lt;/code&gt; method.  Something
  like
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(let [name (munge (:name (symbol (str (-&amp;gt; env :ns :name) &quot;.&quot; (munge (name sym))))))])
&lt;/pre&gt;


&lt;p&gt;
  might work in the &lt;code&gt;parse&lt;/code&gt; method.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/cljs-name-resolving/#comments" type="text/html" />


	<link rel="comments" href="/posts/cljs-name-resolving/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>More Rationals</title>

	<id>http://chrismgray.github.com//posts/more-rationals/</id>

	<link href="http://chrismgray.github.com//posts/more-rationals/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="rationals" />


	<updated>2011-12-01T07:42:23Z</updated>
	<published>2011-11-10T16:55:06Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;More about rationals&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  While attempting to implement &lt;a href=&quot;http://chrismgray.github.com/posts/rationals-in-cljs/&quot;&gt;support for rationals&lt;/a&gt; yesterday, I
  stumbled on what is (or at least, seems to me to be) a bug in the
  Clojure compiler itself.  That is, one can not refer to the function
  &lt;code&gt;/&lt;/code&gt; in namespaces other than &lt;code&gt;clojure.core&lt;/code&gt;.  Now, this is probably
  the first time that anyone has wanted to do this, so it&#39;s not
  surprising that no one had seen the bug before.  But what was
  surprising to me was that I could fix it fairly easily.  I submitted
  my patch, and I should be a real-life contributor to Clojure pretty
  soon.  As a person who doesn&#39;t see himself as a compiler guy, that&#39;s
  pretty exciting.
&lt;/p&gt;
&lt;p&gt;
  The next problem that I&#39;m having is that redefining the basic
  arithmetic operations does not seem to work properly in
  Clojurescript.  The compiled javascript is trying (at least as far
  as I can tell) to redefine &lt;code&gt;cljs.core/+&lt;/code&gt; rather than &lt;code&gt;rationals/+&lt;/code&gt;,
  for example.  This is the problem that I am going to try to solve
  today.  
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/more-rationals/#comments" type="text/html" />


	<link rel="comments" href="/posts/more-rationals/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Followup to the previous post</title>

	<id>http://chrismgray.github.com//posts/rationals-followup/</id>

	<link href="http://chrismgray.github.com//posts/rationals-followup/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="rationals" />


	<updated>2011-12-01T07:46:11Z</updated>
	<published>2011-11-09T22:03:16Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;A small followup&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  My previous post said that I would be using the macros defined in
  Clojurescript&#39;s &lt;code&gt;core.clj&lt;/code&gt;.  It turns out that doesn&#39;t make a lot of
  sense.  I am using the functions defined in &lt;code&gt;core.cljs&lt;/code&gt; instead.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/rationals-followup/#comments" type="text/html" />


	<link rel="comments" href="/posts/rationals-followup/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Rationals in Clojurescript</title>

	<id>http://chrismgray.github.com//posts/rationals-in-cljs/</id>

	<link href="http://chrismgray.github.com//posts/rationals-in-cljs/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="rationals" />

	<category term="voronoi-diagram" />


	<updated>2011-12-01T07:46:11Z</updated>
	<published>2011-11-09T17:13:06Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Rationals in Clojurescript&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
Last night, I uploaded some code to compute the &lt;a href=&quot;http://en.wikipedia.org/wiki/Voronoi_diagram&quot;&gt;Voronoi Diagram&lt;/a&gt; of a
set of points to &lt;a href=&quot;https://github.com/chrismgray/voronoi-diagram/&quot;&gt;github&lt;/a&gt;.  This post is not directly about that code --
I&#39;ll write about that when it is completely working &amp;ndash; but rather
about something that I noticed when I tried to convert the code to
&lt;a href=&quot;https://github.com/clojure/clojurescript&quot;&gt;Clojurescript&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
There are a few things that are known not to work in Clojurescript
that work in Clojure: I had to convert calls from &lt;code&gt;lazy-cat&lt;/code&gt; to
&lt;code&gt;concat&lt;/code&gt;, for example.  However, the one difference that really broke
things for me was the lack of support for rational arithmetic in
Clojurescript.
&lt;/p&gt;
&lt;p&gt;
One major element of my algorithm is a test to determine whether a
given point is on a given line segment.  With integer coordinates for
the sites that determine the Voronoi Diagram and the bounding box,
everything about this test can be represented as a rational number.
Since Clojure gives you rational numbers by default, while
Clojurescript simply uses Javascript&#39;s arithmetic facilities, the test
works in Clojure but not in Clojurescript.
&lt;/p&gt;
&lt;p&gt;
So what can be done about this?  Here are some options:
&lt;/p&gt;
&lt;ul&gt;
&lt;li id=&quot;sec-1-1&quot;&gt;Use floats, but more smartly&lt;br/&gt;

&lt;p&gt;
     Probably the simplest option, here we would not test for &lt;i&gt;equality&lt;/i&gt;,
     but for &lt;i&gt;almost equality&lt;/i&gt;.  That is, if the distance between two
     points is a very small number (&lt;i&gt;e.g.&lt;/i&gt; a millionth), and all of the
     input is integer, then the two points are probably the same.  This
     option is obviously not too satisfying from a theoretical
     standpoint, especially if the small number is hardcoded.  I am
     fairly sure that there has been research to determine what the exact
     value of the small number should be, but that would take the code
     out of the realm of simplicity.
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li id=&quot;sec-1-2&quot;&gt;Implement rationals in Clojurescript&lt;br/&gt;

&lt;p&gt;
     I am not sure how possible this option is.  However, it is currently
     the most appealing to me.  Rational arithmetic is not so difficult
     to implement, especially in the limited use case that I need it for:
     I am pretty sure that I could get away with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, and
     the comparison operators.  These are currently implemented as
     &lt;a href=&quot;https://github.com/clojure/clojurescript/blob/3c83c62d973b0153a9e28bea7beb73794fbf9065/src/clj/cljs/core.clj#L51&quot;&gt;macros&lt;/a&gt; in Clojurescript, which means that they take the
     Clojurescript code and change it Javascript code.  This allows
     the Clojurescript compiler to take the prefix syntax of
     Clojurescript and change it to the infix syntax of Javascript.
&lt;/p&gt;
&lt;p&gt;
     If we were to redefine the operators to be functions, we might
     have a chance to run different code given different types of
     input.  The &lt;code&gt;defmulti&lt;/code&gt; and &lt;code&gt;defmethod&lt;/code&gt; macros seem perfect for
     this.  The major question is whether it is possible to shadow the
     names of the operators but use them nevertheless.  That is, will
     I be able to add &lt;code&gt;(:require-macros [clojure.core :as core])&lt;/code&gt; to
     my namespace and then use, for example, &lt;code&gt;core/*&lt;/code&gt;?
&lt;/p&gt;
&lt;p&gt;
     The other downside, beyond the potential difficulties, is the
     fact that the generated Javascript will no longer be quite as
     pretty.  What used to be infix notation will be converted to
     function calls.  Additionally, there will be a fairly high
     penalty for doing arithmetic &amp;ndash; three or four function calls per
     arithmetic operation (assuming the polymorphic solution I have in
     mind works) rather than the current single operation.
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I am going to try to implement the rationals in Clojurescript
  first.  At the very least, I will learn a bit more about how
  multimethods work in Clojure. 
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/rationals-in-cljs/#comments" type="text/html" />


	<link rel="comments" href="/posts/rationals-in-cljs/comments.atom" type="application/atom+xml" />

</entry>

</feed>
