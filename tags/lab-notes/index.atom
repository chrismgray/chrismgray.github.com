<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom">
<title>pages tagged lab-notes</title>
<link href="http://chrismgray.github.com//tags/lab-notes/"/>
<link href="http://chrismgray.github.com//tags/lab-notes/index.atom" rel="self" type="application/atom+xml"/>
<author>

<name>Hiking and Coding</name>

</author>




<id>http://chrismgray.github.com//tags/lab-notes/</id>

<subtitle type="html">Hiking and Coding</subtitle>
<generator uri="http://ikiwiki.info/" version="3.20111106">ikiwiki</generator>
<updated>2011-11-27T19:02:44Z</updated>
<entry>
	<title>clojure-sorting</title>

	<id>http://chrismgray.github.com//posts/clojure-sorting/</id>

	<link href="http://chrismgray.github.com//posts/clojure-sorting/"/>






	<category term="clojure" />

	<category term="lab-notes" />

	<category term="sort" />


	<updated>2011-11-27T19:02:44Z</updated>
	<published>2011-11-27T14:23:34Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Penance &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  In a job interview last week I said a couple of things related to
  sorting in Clojure that turned out to be incorrect when I checked
  them.  This is my way of making up for them &amp;ndash; if I can make them
  true, then no one will notice.  Though to be fair, I&#39;m sure that I&#39;m
  the only one that thinks that way.
&lt;/p&gt;
&lt;p&gt;
  The first thing I said was that heap-sort is my favorite sorting
  algorithm, but then I declined to implement it, preferring to
  implement merge-sort instead.  I think this is actually pretty
  reasonable in an interview situation &amp;ndash; heap-sort is a conceptually
  more difficult sorting algorithm, so being able to remember it on
  the spot is more difficult.  The second thing I said was that
  Clojure itself uses heap-sort and that given its love affair with
  laziness that it would not be unreasonable to assume that &lt;code&gt;(first   (sort lst))&lt;/code&gt; was a linear-time operation.  I might have read
  something like this on a mailing list or IRC, but it is not
  correct.  Clojure currently uses Java&#39;s &lt;code&gt;sort&lt;/code&gt; function, which is a
  slightly-modified merge-sort.  There is not much point in making
  that algorithm lazy, because getting the first element from the
  sorted list requires \(O(n \log n)\) time anyway.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Heap Sort &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  For those that are not familiar with it, heap-sort is something that
  is usually taught in a second-year undergraduate Computer Science
  class.  So it&#39;s not &lt;b&gt;that&lt;/b&gt; difficult an algorithm, but it does
  require some thinking, and there is some fancy analysis that goes
  into part of it.  For a full discussion, see the &lt;a href=&quot;http://www.amazon.com/gp/product/0262033844/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;tag=hikiandcodi-20&amp;amp;linkCode=as2&amp;amp;camp=217145&amp;amp;creative=399369&amp;amp;creativeASIN=0262033844&quot;&gt;Introduction to Algorithms&lt;/a&gt; book by Cormen, Lieserson, Rivest, and Stein.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-1&quot;&gt;Heap &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-1&quot;&gt;


&lt;p&gt;
   To start with, a &lt;i&gt;heap&lt;/i&gt; is conceptually a tree where values are
   stored at the nodes.  The largest value of all the values stored in
   subtrees is stored at the root and the two descendant trees are
   heaps.  Heaps are usually required to be as close to balanced as
   possible &amp;ndash; if any level of the tree has leaves, they are all
   bunched to the right, and all the rest of the leaves are at the
   next level.
&lt;/p&gt;
&lt;p&gt;
   Such a tree is usually implemented as an array, where the child
   nodes of a node can be obtained by some simple arithmetic on the
   index of the node in the array.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-2&quot;&gt;Building a Heap &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-2&quot;&gt;


&lt;p&gt;
   Given the definition, there is an intuitive algorithm for building
   such a heap on a set of numbers: first find the largest number in
   your set and have it be the root of the heap, then split the rest
   of the numbers in half, and recursively make heaps on those sets.
&lt;/p&gt;
&lt;p&gt;
   Such an algorithm is clearly correct, but it is also clearly
   \(\Theta(n \log n)\).  We can do better with a bottom-up algorithm.
   If we continue imagining the heap as a tree, we start by putting
   the input numbers into the tree willy-nilly.  This clearly does not
   satisfy the heap properties laid out above.  However, some of it
   does satisfy the heap properties &amp;ndash; the leaves of the tree are
   trivially heaps.  If we go up one level from the leaves, we can fix
   the trees rooted there by exchanging the root of the tree with its
   largest child (or not exchanging it if it&#39;s already the largest of
   the three).  Higher levels are a bit more difficult, because if the
   root of a tree is exchanged, then we must make sure to fix the tree
   that it ends up being the root of.  You can imagine the root of a
   tree traveling down the heap until it is larger than both of its
   children.
&lt;/p&gt;
&lt;p&gt;
   The correctness of this algorithm is a bit harder to see and it
   also appears to take \(O(n \log n)\) time.  It does, but there is a
   slightly more sophisticated analysis that shows that it is really
   \(\Theta(n)\).  I won&#39;t go into the analysis, but a hint is that
   most of the values don&#39;t actually travel very far in the tree.  
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-3&quot;&gt;Using a heap to sort &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-3&quot;&gt;


&lt;p&gt;
   With the heap properties in mind, we can easily see how to get the
   largest value of a set of numbers &amp;ndash; just take the top element from
   the heap.  How can we use the heap properties to sort?  Well, we
   want the largest number, then the largest number that remains, then
   the largest number that remains after that, and so on.  So if we
   can take the largest number from the heap and then fix the heap so
   that it retains the heap properties, then we&#39;d be done.
&lt;/p&gt;
&lt;p&gt;
   We just devised a way to fix heaps when building the heap, so we
   use that.  What we do is to take the very last node in the heap
   (which is not necessarily the smallest, but it doesn&#39;t hurt to
   think about it as the smallest) and put that at the top of the
   heap.  The resulting tree is clearly not a heap, but if we call the
   algorithm to fix heaps on the root of the tree, then we end up with
   a heap again.  The node that we put on top of the heap might end up
   traveling all the way to the bottom, so this update takes
   \(\Theta(\log n)\) time.  Thus if we sort the entire input set, we
   have a \(\Theta(n \log n)\) algorithm.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-4&quot;&gt;Advantages &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-4&quot;&gt;


&lt;p&gt;
   That&#39;s the best we can do theoretically, which is great, but the
   Java &lt;code&gt;sort&lt;/code&gt; algorithm is also \(\Theta(n \log n)\), so why is there
   any advantage to using heap-sort?  In a language where laziness is
   embraced (such as Clojure), heap-sort can be made lazy.  That is,
   the next element of the sorted list can be computed only when it is
   needed.  Since the build-heap procedure described above takes
   linear time, getting the first element from the sorted list takes
   \(O(n)\) time.  Each subsequent element then takes \(O(\log n)\)
   time.  Thus, if only a small number of elements from the sorted
   list are needed, then this lazy version of heap-sort is
   theoretically faster than other sorts.
&lt;/p&gt;
&lt;p&gt;
   I can think of situations where this would actually have practical
   advantages.  For example, what if you were writing a search engine
   and wanted to obtain the \(k\) best results?  You could write an
   ad-hoc function that found the best result, removed it and recursed
   \(k - 1\) times.  Or you could just &lt;code&gt;(take k (heap-sort input))&lt;/code&gt;.
   The first would take \(O(kn)\) time, whereas the second would take
   \(O(k \log n + n)\) time.  In many practical situations, \(k\) is
   \(\Omega(\log n)\), which means that the first takes \(\Omega(n
   \log n)\) time, whereas the second takes only \(O(n)\) time.
   Essentially, the first is no better than the second solution with a
   non-lazy sorting algorithm.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-5&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-5&quot;&gt;Disadvantages &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-5&quot;&gt;


&lt;p&gt;
   Heap-sort has some disadvantages compared to other sorts of &lt;code&gt;sort&lt;/code&gt;
   algorithms.  The least theoretically significant is that the
   constants hidden in the big-O notation are higher than other
   sorting algorithms (tuned versions of quicksort can have extremely
   small constants).
&lt;/p&gt;
&lt;p&gt;
   Another disadvantage can be seen when dealing with data sets so
   large that they no longer fit in the computer&#39;s main memory.
   Something like merge-sort can be modified fairly easily so that the
   number I/O operations is minimized.  I haven&#39;t thought about it too
   deeply, but this doesn&#39;t seem quite so easy with heap-sort.
   However, I think that people dealing with such large datasets
   should probably be using specialized libraries anyway, so perhaps
   that isn&#39;t too bad.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Implementation &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  This whole discussion is a bit useless if it only remains at the
  theoretical level.  I have an implementation &lt;a href=&quot;https://github.com/chrismgray/clojure-heap-sort&quot;&gt;in my github repo&lt;/a&gt; that
  implements most of the ideas that are given above.  The code is
  highly optimized so that it is somewhat competitive with the native
  Java implementation.  This makes the code on the HEAD of the
  &lt;code&gt;master&lt;/code&gt; branch somewhat less than readable.  However, the first
  commit to the repository used Clojure vectors and a functional
  style, so if you would like to understand the code, you might start
  there. 
&lt;/p&gt;
&lt;p&gt;
  I (unfortunately) needed to use Java arrays and mutation rather than
  the more functional style that I have gotten used to, but the
  results speak for themselves.  Finding the first few elements of a
  sorted array is significantly faster than the Java version.  Finding
  the entire sorted list is somewhat slower than the Java version, but
  not too much.  This is not surprising for a couple of reasons.
  First, heap-sort tends to have larger constants than other sorting
  methods.  Secondly, this code is one day old.  The Java sort method
  has had years to be optimized.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Conclusion &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;


&lt;p&gt;
  It may be dreaming, but I would love to see this idea (if not this
  implementation) put into Clojure proper.  I think the advantages
  from laziness outweigh the small constant slowdown versus using
  Java&#39;s &lt;code&gt;sort&lt;/code&gt;.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/clojure-sorting/#comments" type="text/html" />


	<link rel="comments" href="/posts/clojure-sorting/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>processing</title>

	<id>http://chrismgray.github.com//posts/processing/</id>

	<link href="http://chrismgray.github.com//posts/processing/"/>






	<category term="clojure" />

	<category term="lab-notes" />

	<category term="processing" />

	<category term="visibility-polygon" />


	<updated>2011-11-22T21:06:52Z</updated>
	<published>2011-11-22T19:29:29Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Viewing visibility polygons &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I mentioned yesterday that it would be nice to see the output of my
  visibility polygon solution.  To that end, I created an extremely
  simple drawing editor using &lt;a href=&quot;http://processing.org/&quot;&gt;Processing&lt;/a&gt;.  I have to say, I loved it.
&lt;/p&gt;
&lt;p&gt;
  The most important feature to me is the extreme interactivity.  I
  can change functions extremely quickly with my tools &amp;ndash; redefining a
  Clojure function is either one or two keystrokes in emacs, depending
  how I choose to do it &amp;ndash; so I like a graphics environment that
  changes just as quickly.  This is what Processing, and in particular
  &lt;code&gt;clj-processing&lt;/code&gt;, offers.  I was able to define a function that
  draws the various objects (in this case, the polygon, the point
  where the mouse is, and the visibility polygon of the mouse point
  inside the polygon).  If I wanted to make any changes to this
  function &amp;ndash; for example, changing the color of the point where the
  mouse is &amp;ndash; I can simply redefine the function using my emacs tools
  and the change shows up immediately on the drawing.
&lt;/p&gt;
&lt;p&gt;
  I was able to use this to find a couple of minor bugs in my
  visibility-polygon-finding code, but in general, it worked really
  well on the first try.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;Shortcomings &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;


&lt;p&gt;
   There were a couple of things that slightly bothered me about
   &lt;code&gt;clj-processing&lt;/code&gt;.  First, it used quite a lot of CPU just to
   display a simple polygon without too many points.  I am probably
   using it rather na√Øvely, so it is possible that this is my problem
   and not the problem of &lt;code&gt;clj-processing&lt;/code&gt;.  However, the second
   problem is just that &lt;code&gt;clj-processing&lt;/code&gt; is showing its age.  I think
   it was probably one of the first Clojure libraries out there and
   much of the coding style hasn&#39;t evolved with the Clojure best
   practices that people use.  For example, some of the features do
   not work if you only &lt;code&gt;require&lt;/code&gt; the library &amp;ndash; you must &lt;code&gt;use&lt;/code&gt; it.  I
   try to only &lt;code&gt;require&lt;/code&gt; libraries, to avoid my namespace becoming
   overly populated, so it is frustrating when that doesn&#39;t work.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Going forward &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I need to clean up the code a bit before I can put it up on github,
  but it should be there soon.  It currently needs me to explicitly
  call the function in order to find the visibility polygon.  I would
  really like it to find the visibility polygon of any point where the
  mouse is inside the polygon.  However, determining if a point is
  inside a non-convex polygon tends to be a bit harder than it
  sounds.  You can shoot a ray in one direction from a point, and
  count the number of polygon edges that it crosses &amp;ndash; if it&#39;s even
  you are outside and if it&#39;s odd you are inside &amp;ndash; but what happens
  if the ray crosses a vertex?  There was a good experimental paper on
  this problem at a recent EuroCG.
&lt;/p&gt;
&lt;p&gt;
  So that&#39;s a slightly non-trivial problem.  I also coded an
  implementation of the Voronoi Diagram problem recently.  I should
  add a Processing UI to that as well.  I have a feeling that would be
  the easier task to do next, and I would surely discover some bugs in
  it while I did.
&lt;/p&gt;



&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/processing/#comments" type="text/html" />


	<link rel="comments" href="/posts/processing/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>visibility-polygon</title>

	<id>http://chrismgray.github.com//posts/visibility-polygon/</id>

	<link href="http://chrismgray.github.com//posts/visibility-polygon/"/>






	<category term="clojure" />

	<category term="computational-geometry" />

	<category term="lab-notes" />

	<category term="visibility-polygon" />


	<updated>2011-11-21T19:58:03Z</updated>
	<published>2011-11-21T19:44:43Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Visibility Polygon &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I&#39;ve put up some preliminary code for finding visibility polygons on
  my &lt;a href=&quot;https://github.com/chrismgray/visibility-polygon&quot;&gt;github repo&lt;/a&gt;.  I have only tested it with one polygon, but so far
  things are looking good.  My idea from yesterday of using monads to
  &quot;parse&quot; the polygon seems to be paying off.  Here is the relevant
  code:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(defn- add-new-pt [poly]
  (fn [pt stack]
    (when (or (empty? stack) ; First two points are guaranteed to be visible
              (empty? (rest stack))
              (visible? pt (first poly) (first stack)))
      [pt (rest poly) (cons (first poly) stack)])))

(defn- pop-stack [poly]
  (fn [pt stack]
    (let [the-seg (seg/new-seg pt (first poly))
          top-seg (seg/new-seg (first stack) (second stack))]
      (when (pt/left-turn? (second stack) (first stack) (first poly))
        (if (seg/intersection-on-seg? the-seg top-seg)
          [pt poly (cons (seg/intersection the-seg top-seg) stack)]
          [pt poly (rest stack)])))))

(defn- skip-pt [poly]
  (fn [pt stack]
   (let [the-seg (seg/new-seg pt (first stack))
         poly-seg (seg/new-seg (first poly) (second poly))]
     (when (not (pt/left-turn? (second stack) (first stack) (first poly)))
       (if (seg/intersection-on-seg? the-seg poly-seg)
         [pt (cons (seg/intersection the-seg poly-seg) (rest poly)) stack]
         [pt (rest poly) stack])))))

(defn- all-conditions [poly]
  (with-monad polygon-parser-m
    (m-plus (add-new-pt poly) (pop-stack poly) (skip-pt poly))))
&lt;/pre&gt;




&lt;p&gt;
  This defines three actions to be performed when the polygon and
  stack are in certain configurations.  The first executes when the
  next point on the polygon doesn&#39;t obscure any of the stack.  In that
  case, it removes the point from &lt;code&gt;poly&lt;/code&gt; and puts it on &lt;code&gt;stack&lt;/code&gt;.  The
  second executes by popping points off the stack until the next point
  on the polygon no longer obscures the stack.  The final condition
  activates when the next point on the polygon is hidden by the
  stack.  It skips the points of &lt;code&gt;poly&lt;/code&gt; until it finds one that would
  be visible.  We combine the three conditions using &lt;code&gt;m-plus&lt;/code&gt;, which
  is defined to try the conditions in order until one returns
  something that is not &lt;code&gt;nil&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  Is this solution any better than a functional programming solution
  without monads?  I think it is.  First, the conditions are easy to
  see and very explicitly laid out.  Using a &lt;code&gt;cond&lt;/code&gt; to accomplish the
  same thing is certainly possible, but gets more complicated as the
  number of conditions grows.  Also, we are explicitly managing state
  in this solution.  Doing so in an ad-hoc manner would be much more
  difficult.  In fact, I am not really sure how I would loop until
  there are no more points in &lt;code&gt;poly&lt;/code&gt; in a solution without monads
  (especially since not all the conditions consume a point from
  &lt;code&gt;poly&lt;/code&gt;).  With monads, it is quite simple:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(defn- visibility-polygon-helper [pt poly]
  ((with-monad polygon-parser-m
     (m-until empty? all-conditions poly)) pt []))
&lt;/pre&gt;




&lt;p&gt;
  Doing something like that with a &lt;code&gt;reduce&lt;/code&gt; seems like it would veer
  off into unreadability fairly quickly.
&lt;/p&gt;
&lt;p&gt;
  Are there downsides to this solution?  I think there is at least
  one.  That is, the conditions must be functions that return functions.
  This makes them a bit more confusing than they really should be.  I
  needed to do this so that I could have a test in the &lt;code&gt;m-until&lt;/code&gt;
  function above.  On the whole, though, this is a fairly cosmetic
  gripe, and can be hidden by using helper functions like the one
  above.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;On the horizon &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I would like to test the code quite a bit more.  However, doing so
  by drawing out polygons by hand and then figuring out their
  visibility polygons is quite tedious.  Therefore, I need some sort
  of GUI to be able to draw polygons and then I will be able to
  see whether the computed visibility polygon makes sense.
&lt;/p&gt;
&lt;p&gt;
  I am thinking that it might be nice to use the &lt;a href=&quot;https://github.com/rosado/clj-processing&quot;&gt;&lt;code&gt;clj-processing&lt;/code&gt; library&lt;/a&gt; to do this.  Unfortunately, that library is currently only
  using Clojure 1.2.  Since I am using Clojure 1.3, that might be a
  problem.  So I might need to do some porting from 1.2 to 1.3.
  However, doing so should give me a good idea of how processing
  works, and could give a nice tool for more interactive geometry
  programs. 
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/visibility-polygon/#comments" type="text/html" />


	<link rel="comments" href="/posts/visibility-polygon/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>parsing-polygons</title>

	<id>http://chrismgray.github.com//posts/parsing-polygons/</id>

	<link href="http://chrismgray.github.com//posts/parsing-polygons/"/>






	<category term="computational-geometry" />

	<category term="lab-notes" />

	<category term="visibility-polygon" />


	<updated>2011-11-21T01:16:32Z</updated>
	<published>2011-11-21T00:58:28Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Functional programming &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I&#39;ve gotten a bit obsessed by functional programming over the last
  couple of years.  I have even seriously thought about writing a book
  that looks at computational geometry (which is the subject in which
  I was trained) in the light of functional programming.  Most of the
  standard computational-geometry texts these days approach the
  writing of code from an imperative standpoint.
&lt;/p&gt;
&lt;p&gt;
  I think functional programming is a good way to think about
  computational geometry for a couple of reasons.  First, most
  problems in computational geometry can be expressed in a purely
  functional manner.  That is, the answers to the problems are usually
  the same given the same inputs.  Secondly, I have bought into the
  idea that parallel and distributed computing are much easier when
  state is not being modified.  Functional programming forces you to
  think this way.  While many problems in computational geometry are
  inherently sequential, not all of them are.  Using a programming
  method that allows for the easy addition of more cores seems like a
  good practice when a problem is encountered that is easily made
  parallel. 
&lt;/p&gt;
&lt;p&gt;
  One of the things I have been thinking about as a final chapter for
  the book that I would like to write is the introduction of monads as
  a way to &quot;parse&quot; polygons.  Monads are commonly used (well, commonly
  in the functional programming world) to parse strings.  They
  generally scan through with the aid of a stack.  There are many
  algorithms that scan through the points of a polygon with a stack --
  the example that I have thought about the most is the visibility
  polygon.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Visibility polygons &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  A &lt;i&gt;visibility polygon&lt;/i&gt; is the subset of a polygon that can be &quot;seen&quot;
  from a point inside the polygon.  Here, we regard the segments of
  the polygon as opaque walls.
&lt;/p&gt;
&lt;p&gt;
  The standard algorithm for computing the visibility polygon is not
  too difficult to implement in an imperative language.  In fact, I
  &lt;a href=&quot;http://www.win.tue.nl/~cgray/ipelets.html&quot;&gt;implemented&lt;/a&gt; it already in C++ for the drawing editor &lt;a href=&quot;http://tclab.kaist.ac.kr/ipe/&quot;&gt;ipe&lt;/a&gt;.  (Though I
  think that code is now obsolete since the release of ipe 7.)
&lt;/p&gt;
&lt;p&gt;
  I&#39;ve already tipped my hand at how I would think about implementing
  such an algorithm in a functional language.  I would use a variant
  of a monadic parser to go through the polygon and find the parts
  that are visible.  (That last sentence doesn&#39;t give much of a hint
  about how it&#39;s done, but the whole algorithm would take too much
  space to describe.  Suffice it to say that a stack is kept with the
  &quot;currently visible&quot; portion of the polygon always on the stack.)
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Monads &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  I used monads &lt;a href=&quot;http://chrismgray.github.com/posts/time-series-2/&quot;&gt;earlier&lt;/a&gt; to make a framework for creating and comparing
  time-series.  However, I only used a monad that was already defined
  by someone else.  I think I might need to define a monad on my own
  this time &amp;ndash; a slightly daunting idea.  I definitely need to read
  the rest of &lt;a href=&quot;http://intensivesystems.s3-website-us-east-1.amazonaws.com/tutorials/monads_201.html&quot;&gt;Jim Duey&#39;s tutorial&lt;/a&gt; to make sense of how to do it.
&lt;/p&gt;



&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/parsing-polygons/#comments" type="text/html" />


	<link rel="comments" href="/posts/parsing-polygons/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>cljs-name-resolving-2</title>

	<id>http://chrismgray.github.com//posts/cljs-name-resolving-2/</id>

	<link href="http://chrismgray.github.com//posts/cljs-name-resolving-2/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="rationals" />


	<updated>2011-11-12T01:28:40Z</updated>
	<published>2011-11-12T01:07:52Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Done! &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I was close with my guess in the last post.  What ended up working
  was
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(let [name (munge (symbol (str (-&amp;gt; env :ns :name) &lt;span&gt;&quot;.&quot;&lt;/span&gt; (munge (str sym)))))
&lt;/pre&gt;




&lt;p&gt;
  For some reason, &lt;code&gt;(name sym)&lt;/code&gt; would crash the compiler from the
  &lt;code&gt;parse&lt;/code&gt; method but it wouldn&#39;t from other functions caled from the
  &lt;code&gt;parse&lt;/code&gt; method.  I finally gave up worrying about that and just used
  &lt;code&gt;(str sym)&lt;/code&gt; instead, since that is guaranteed to be the same in this
  case &amp;ndash; there is an &lt;code&gt;(assert (not (namespace sym)))&lt;/code&gt; just before the
  &lt;code&gt;let&lt;/code&gt; line.  I gave up on worrying about it, but someone who knows
  more about the compiler than me might want to try to figure out why
  it is.
&lt;/p&gt;
&lt;p&gt;
  I also needed to allow names defined in &lt;code&gt;cljs.core&lt;/code&gt; but redefined in
  another namespace to be called or referred to.  This involved
  changing the &lt;code&gt;resolve-existing-var&lt;/code&gt; function.  Again, &lt;code&gt;cljs.core&lt;/code&gt; is
  hardcoded:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(let [full-ns (if (and (core-name? env sym) (nil? (get-in @namespaces [(-&amp;gt; env :ns :name) :defs sym])))
                &#39;cljs.core
                (-&amp;gt; env :ns :name))]
&lt;/pre&gt;




&lt;p&gt;
  I added the second test: it simply asks whether the variable has
  been defined in the namespace.  If it hasn&#39;t, and the variable is
  defined in &lt;code&gt;cljs.core&lt;/code&gt;, only then is the namespace set to
  &lt;code&gt;cljs.core&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Remove the macros &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  It was also necessary to remove many of the macros from &lt;code&gt;core.clj&lt;/code&gt;
  in order to redefine the functions that I needed to in my project.
  As I noted earlier, my project is to implement rationals in
  Clojurescript, so I need to redefine most of the functions that work
  with numbers.  (At least, that is the way I am implementing it --
  there may be a better way that I don&#39;t know about.)  Many of these
  functions were implemented twice: once as a macro in &lt;code&gt;core.clj&lt;/code&gt; and
  once as a function in &lt;code&gt;core.cljs&lt;/code&gt;.  I am obviously biased towards
  being able to redefine these functions, so I think the macros should
  be removed, but at least one of the implementations is redundant.
&lt;/p&gt;



&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/cljs-name-resolving-2/#comments" type="text/html" />


	<link rel="comments" href="/posts/cljs-name-resolving-2/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>cljs-name-resolving</title>

	<id>http://chrismgray.github.com//posts/cljs-name-resolving/</id>

	<link href="http://chrismgray.github.com//posts/cljs-name-resolving/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="rationals" />


	<updated>2011-11-12T01:25:21Z</updated>
	<published>2011-11-11T14:23:38Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Resolving names as they are compiled in Clojurescript &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I think I found the bug in the Clojurescript compiler that I was
  &lt;a href=&quot;http://chrismgray.github.com/more-rationals&quot;&gt;looking for yesterday&lt;/a&gt;.  Just to refresh the memory, when defining a
  function that has a function of the same name in &lt;code&gt;cljs.core&lt;/code&gt;, the
  compiler will assume that you are trying to redefine the function
  from &lt;code&gt;cljs.core&lt;/code&gt;, rather than the function in the namespace that you
  are actually in.  Since I am trying to redefine functions like &lt;code&gt;/&lt;/code&gt;
  and &lt;code&gt;*&lt;/code&gt;, this is a problem.
&lt;/p&gt;
&lt;p&gt;
  Let&#39;s look at the evidence.  First, there&#39;s this:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(defmethod parse &#39;def
  [op env form name]
  (let [pfn (fn ([_ sym] {:sym sym})
              ([_ sym init] {:sym sym :init init})
              ([_ sym doc init] {:sym sym :doc doc :init init}))
        args (apply pfn form)
        sym (:sym args)]
    (assert (not (namespace sym)) &lt;span&gt;&quot;Can&#39;t def ns-qualified name&quot;&lt;/span&gt;)
    (let [name (munge (:name (resolve-var (dissoc env :locals) sym)))
&lt;/pre&gt;




&lt;p&gt;
  The important line there is the last: when defining a new name,
  &lt;code&gt;resolve-var&lt;/code&gt; is called on the symbol.  Let&#39;s have a look at that
  function.  There is a &lt;code&gt;cond&lt;/code&gt;, and when none of the tests return
  true, the following is done:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(munge (symbol (str
                (if (core-name? env sym)
                  &#39;cljs.core
                  (-&amp;gt; env :ns :name))
                &lt;span&gt;&quot;.&quot;&lt;/span&gt; (munge (name sym))))))]
&lt;/pre&gt;




&lt;p&gt;
  This is seeing if the symbol name is in &lt;code&gt;cljs.core&lt;/code&gt;, and if it is
  setting the namespace of the symbol to &lt;code&gt;cljs.core&lt;/code&gt;.  Normally that
  would be correct &amp;ndash; one doesn&#39;t want to need to &lt;code&gt;use&lt;/code&gt; &lt;code&gt;cljs.core&lt;/code&gt; in
  every file &amp;ndash; but it doesn&#39;t allow for redefinition of functions
  that are in &lt;code&gt;cljs.core&lt;/code&gt; (at least without completely shadowing
  them).
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;What to do &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  So what can we do about this?  The first thing that seems odd to me
  is that the symbol being defined is being resolved first.  Every
  symbol that is defined is defined within its own namespace, so there
  should be no need to resolve it.  That suggests that we should be
  able to take the part of &lt;code&gt;resolve-var&lt;/code&gt; that doesn&#39;t have a special
  case for &lt;code&gt;cljs.core&lt;/code&gt; and put it into the &lt;code&gt;parse&lt;/code&gt; method.  Something
  like
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(let [name (munge (:name (symbol (str (-&amp;gt; env :ns :name) &lt;span&gt;&quot;.&quot;&lt;/span&gt; (munge (name sym))))))])
&lt;/pre&gt;




&lt;p&gt;
  might work in the &lt;code&gt;parse&lt;/code&gt; method.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/cljs-name-resolving/#comments" type="text/html" />


	<link rel="comments" href="/posts/cljs-name-resolving/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>more-rationals</title>

	<id>http://chrismgray.github.com//posts/more-rationals/</id>

	<link href="http://chrismgray.github.com//posts/more-rationals/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="rationals" />


	<updated>2011-11-12T01:24:52Z</updated>
	<published>2011-11-10T16:55:06Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;More about rationals &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  While attempting to implement &lt;a href=&quot;http://chrismgray.github.com/posts/rationals-in-cljs/&quot;&gt;support for rationals&lt;/a&gt; yesterday, I
  stumbled on what is (or at least, seems to me to be) a bug in the
  Clojure compiler itself.  That is, one can not refer to the function
  &lt;code&gt;/&lt;/code&gt; in namespaces other than &lt;code&gt;clojure.core&lt;/code&gt;.  Now, this is probably
  the first time that anyone has wanted to do this, so it&#39;s not
  surprising that no one had seen the bug before.  But what was
  surprising to me was that I could fix it fairly easily.  I submitted
  my patch, and I should be a real-life contributor to Clojure pretty
  soon.  As a person who doesn&#39;t see himself as a compiler guy, that&#39;s
  pretty exciting.
&lt;/p&gt;
&lt;p&gt;
  The next problem that I&#39;m having is that redefining the basic
  arithmetic operations does not seem to work properly in
  Clojurescript.  The compiled javascript is trying (at least as far
  as I can tell) to redefine &lt;code&gt;cljs.core/+&lt;/code&gt; rather than &lt;code&gt;rationals/+&lt;/code&gt;,
  for example.  This is the problem that I am going to try to solve
  today.  
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/more-rationals/#comments" type="text/html" />


	<link rel="comments" href="/posts/more-rationals/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>rationals-followup</title>

	<id>http://chrismgray.github.com//posts/rationals-followup/</id>

	<link href="http://chrismgray.github.com//posts/rationals-followup/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="rationals" />


	<updated>2011-11-12T01:24:45Z</updated>
	<published>2011-11-09T22:03:16Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;A small followup &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  My previous post said that I would be using the macros defined in
  Clojurescript&#39;s &lt;code&gt;core.clj&lt;/code&gt;.  It turns out that doesn&#39;t make a lot of
  sense.  I am using the functions defined in &lt;code&gt;core.cljs&lt;/code&gt; instead.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/rationals-followup/#comments" type="text/html" />


	<link rel="comments" href="/posts/rationals-followup/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>rationals-in-cljs</title>

	<id>http://chrismgray.github.com//posts/rationals-in-cljs/</id>

	<link href="http://chrismgray.github.com//posts/rationals-in-cljs/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="rationals" />

	<category term="voronoi-diagram" />


	<updated>2011-11-12T01:24:35Z</updated>
	<published>2011-11-09T17:13:06Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Rationals in Clojurescript &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
Last night, I uploaded some code to compute the &lt;a href=&quot;http://en.wikipedia.org/wiki/Voronoi_diagram&quot;&gt;Voronoi Diagram&lt;/a&gt; of a
set of points to &lt;a href=&quot;https://github.com/chrismgray/voronoi-diagram/&quot;&gt;github&lt;/a&gt;.  This post is not directly about that code --
I&#39;ll write about that when it is completely working &amp;ndash; but rather
about something that I noticed when I tried to convert the code to
&lt;a href=&quot;https://github.com/clojure/clojurescript&quot;&gt;Clojurescript&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
There are a few things that are known not to work in Clojurescript
that work in Clojure: I had to convert calls from &lt;code&gt;lazy-cat&lt;/code&gt; to
&lt;code&gt;concat&lt;/code&gt;, for example.  However, the one difference that really broke
things for me was the lack of support for rational arithmetic in
Clojurescript.
&lt;/p&gt;
&lt;p&gt;
One major element of my algorithm is a test to determine whether a
given point is on a given line segment.  With integer coordinates for
the sites that determine the Voronoi Diagram and the bounding box,
everything about this test can be represented as a rational number.
Since Clojure gives you rational numbers by default, while
Clojurescript simply uses Javascript&#39;s arithmetic facilities, the test
works in Clojure but not in Clojurescript.
&lt;/p&gt;
&lt;p&gt;
So what can be done about this?  Here are some options:
&lt;/p&gt;
&lt;ul&gt;
&lt;li id=&quot;sec-1-1&quot;&gt;Use floats, but more smartly &lt;br/&gt;

&lt;p&gt;
     Probably the simplest option, here we would not test for &lt;i&gt;equality&lt;/i&gt;,
     but for &lt;i&gt;almost equality&lt;/i&gt;.  That is, if the distance between two
     points is a very small number (&lt;i&gt;e.g.&lt;/i&gt; a millionth), and all of the
     input is integer, then the two points are probably the same.  This
     option is obviously not too satisfying from a theoretical
     standpoint, especially if the small number is hardcoded.  I am
     fairly sure that there has been research to determine what the exact
     value of the small number should be, but that would take the code
     out of the realm of simplicity.
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li id=&quot;sec-1-2&quot;&gt;Implement rationals in Clojurescript &lt;br/&gt;

&lt;p&gt;
     I am not sure how possible this option is.  However, it is currently
     the most appealing to me.  Rational arithmetic is not so difficult
     to implement, especially in the limited use case that I need it for:
     I am pretty sure that I could get away with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, and
     the comparison operators.  These are currently implemented as
     &lt;a href=&quot;https://github.com/clojure/clojurescript/blob/3c83c62d973b0153a9e28bea7beb73794fbf9065/src/clj/cljs/core.clj#L51&quot;&gt;macros&lt;/a&gt; in Clojurescript, which means that they take the
     Clojurescript code and change it Javascript code.  This allows
     the Clojurescript compiler to take the prefix syntax of
     Clojurescript and change it to the infix syntax of Javascript.
&lt;/p&gt;
&lt;p&gt;
     If we were to redefine the operators to be functions, we might
     have a chance to run different code given different types of
     input.  The &lt;code&gt;defmulti&lt;/code&gt; and &lt;code&gt;defmethod&lt;/code&gt; macros seem perfect for
     this.  The major question is whether it is possible to shadow the
     names of the operators but use them nevertheless.  That is, will
     I be able to add &lt;code&gt;(:require-macros [clojure.core :as core])&lt;/code&gt; to
     my namespace and then use, for example, &lt;code&gt;core/*&lt;/code&gt;?
&lt;/p&gt;
&lt;p&gt;
     The other downside, beyond the potential difficulties, is the
     fact that the generated Javascript will no longer be quite as
     pretty.  What used to be infix notation will be converted to
     function calls.  Additionally, there will be a fairly high
     penalty for doing arithmetic &amp;ndash; three or four function calls per
     arithmetic operation (assuming the polymorphic solution I have in
     mind works) rather than the current single operation.
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Conclusion &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I am going to try to implement the rationals in Clojurescript
  first.  At the very least, I will learn a bit more about how
  multimethods work in Clojure. 
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/rationals-in-cljs/#comments" type="text/html" />


	<link rel="comments" href="/posts/rationals-in-cljs/comments.atom" type="application/atom+xml" />

</entry>

</feed>
