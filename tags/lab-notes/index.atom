<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom">
<title>pages tagged lab-notes</title>
<link href="http://chrismgray.github.com//tags/lab-notes/"/>
<link href="http://chrismgray.github.com//tags/lab-notes/index.atom" rel="self" type="application/atom+xml"/>
<author>

<name>Hiking and Coding</name>

</author>




<id>http://chrismgray.github.com//tags/lab-notes/</id>

<subtitle type="html">Hiking and Coding</subtitle>
<generator uri="http://ikiwiki.info/" version="3.20120202">ikiwiki</generator>
<updated>2012-04-20T23:18:48Z</updated>
<entry>
	<title>More Clojurescript Macros</title>

	<id>http://chrismgray.github.com//posts/cljs-macros-02/</id>

	<link href="http://chrismgray.github.com//posts/cljs-macros-02/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="macros" />


	<updated>2012-04-20T23:18:48Z</updated>
	<published>2012-04-20T22:47:21Z</published>

	<content type="html" xml:lang="en">
	
&lt;p&gt;Most of my time this week was spent traveling and in meetings, but I
did have a chance to work on the Clojurescript macro system that I
have been working on.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Testing&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  Things didn&#39;t start too well for the system, since it would not run
  the simplest of tests written for it in the Clojurescript testing
  system.  My test was a macro that would take a positive integer,
  recursively decrease it until it was zero, and then output the
  zero.  (Clearly not the smartest macro in the world &amp;ndash; it was just
  meant to test recursion.)  However, I kept getting errors saying
  that the system didn&#39;t know how to test equality among numbers.
  This seemed strange until I realized that the &lt;code&gt;extend-type&lt;/code&gt; call for
  numbers wasn&#39;t getting executed because it wasn&#39;t expanded into a
  &lt;code&gt;def&lt;/code&gt;.  (I had been executing all &lt;code&gt;def&lt;/code&gt; calls, which defined all
  functions and variables, but nothing else.)
&lt;/p&gt;
&lt;p&gt;
  So I briefly flirted with executing a bunch of other special forms,
  including &lt;code&gt;set!&lt;/code&gt; and &lt;code&gt;deftype&lt;/code&gt;, but I could see that this would make
  things pretty unwieldy, and that the compiler would be doing a lot
  of confusing things, for example trying to execute a &lt;code&gt;set!&lt;/code&gt; that was
  buried deep inside a function without being able to know anything
  about the locals that it was being set to.
&lt;/p&gt;
&lt;p&gt;
  That was clearly the way of madness, so I eventually decided to
  execute every special form that was at the top level.  This worked
  really well, and the tests started passing.
&lt;/p&gt;
&lt;p&gt;
  I also added tests to make sure that the namespaces work as
  expected.  You can &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; macros from other namespaces
  just like other functions.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;What&#39;s not there (yet)&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  So far I have not added the &lt;code&gt;&amp;amp;env&lt;/code&gt; and &lt;code&gt;&amp;amp;form&lt;/code&gt; variables to macros.
  I expect that it will be necessary to add them at some point (and
  honestly not too hard).  I know they are extremely useful in some
  projects like &lt;a href=&quot;https://github.com/clojure/core.match&quot;&gt;core.match&lt;/a&gt;, but that project has already been ported
  to Clojurescript (via Clojure macros), so it might make more sense
  to leave the large macros that need those facilities to Clojure.
&lt;/p&gt;
&lt;p&gt;
  Backquoted forms don&#39;t work as nicely as in Clojure.  The reason is
  that we are using Clojure&#39;s reader, which qualifies backquoted
  symbols with their full namespace.  Unfortunately, it doesn&#39;t know
  anything about Clojurescript namespaces, so expect to need to
  qualify symbols inside backquotes.  This is an area where true
  reader macros inside Clojure would be really helpful, but we have to
  live with what we have.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;One step closer&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  &amp;hellip; to Clojure in Clojure.  Clojurescript already has a reader and a
  compiler that can compile most of itself.  The reader isn&#39;t totally
  complete &amp;ndash; it doesn&#39;t have backquote working yet for example &amp;ndash; but
  it is close.  It recently got persistent vectors and persistent
  hash-maps.  With macros added, all that&#39;s left for Clojure in
  Clojure is to finish up the reader and get rid of the calls to
  Java.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/cljs-macros-02/#comments" type="text/html" />


	<link rel="comments" href="/posts/cljs-macros-02/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Clojurescript Macros</title>

	<id>http://chrismgray.github.com//posts/cljs-macros/</id>

	<link href="http://chrismgray.github.com//posts/cljs-macros/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />

	<category term="macros" />


	<updated>2012-04-11T06:33:51Z</updated>
	<published>2012-04-11T05:36:33Z</published>

	<content type="html" xml:lang="en">
	
&lt;p&gt;Today I wrote a proof-of-concept implementation of a macro system for
Clojurescript.  The code is &lt;a href=&quot;https://github.com/chrismgray/clojurescript/tree/defmacro&quot;&gt;here&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
Clojurescript already had a sort of macro system in the form of
Clojure macros, but this is different &amp;ndash; the macros are written in
Clojurescript, get compiled to JavaScript, and are evaluated by a
JavaScript interpreter.  They can be mixed in with Clojurescript code
and call Clojurescript functions.  In theory, they should work with
any Clojurescript backend that implements the REPL-related protocols
(but who knows if that&#39;s true).
&lt;/p&gt;
&lt;p&gt;
So that&#39;s the big announcement.  What follows are some implementation
details and other notes.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Implementation details&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  The macros are defined by passing strings back and forth between the
  Clojurescript compiler and the Rhino JavaScript interpreter.  The
  strings from Rhino are read by Clojure using &lt;code&gt;read-string&lt;/code&gt;, so
  macros are limited to things that can be printed by Clojurescript in
  a form that Clojure can read.
&lt;/p&gt;
&lt;p&gt;
  Macros are not yet put into the correct namespaces.  I don&#39;t think
  it will be too hard to do that correctly though.
&lt;/p&gt;
&lt;p&gt;
  Rhino is a slow beast.  It adds multiple seconds to the startup time
  of the compiler.  It might be smart to scan the file for calls to
  &lt;code&gt;defmacro&lt;/code&gt; before including the macro-interpreting code.  However,
  since macro expansion requires that all functions are defined in the
  interpreter, once a &lt;code&gt;defmacro&lt;/code&gt; is hit, all the functions in the file
  preceding it (and in all &lt;code&gt;require&lt;/code&gt;&#39;d files) must be re-parsed.
&lt;/p&gt;
&lt;p&gt;
  Existing Clojure macros should still work.  If two macros have the
  same name, the Clojurescript one will take precedence, but of course
  getting namespaces working should eliminate most conflicts.
&lt;/p&gt;
&lt;p&gt;
  It should go without saying that this is completely experimental at
  this point.  Things seem like they work to me, but they might yet
  blow up in unexpected ways.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;An example&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  Here is a simple Clojurescript file which implements the &lt;code&gt;unless&lt;/code&gt;
  macro (also known as &lt;code&gt;when-not&lt;/code&gt; in Clojure, but I think giving it a
  different name shows better that it is really not using the Clojure
  macros).
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(defmacro unless
  [pred &amp;amp; body]
  `(if (not ~pred)
     (do ~@body)
     nil))

(let [a (unless true (/ 1 0) (+ 1 1))]
  a)
&lt;/pre&gt;


&lt;p&gt;
  And here is its output:
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;var a__5799 = (cljs.core.truth_(cljs.core.not.call(null,true))?(function (){(1 / 0);
return (1 + 1);
})():null);

a__5799;
&lt;/pre&gt;


&lt;p&gt;
  It&#39;s a bit ugly, but it should be obvious what&#39;s going on.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  I&#39;m pretty happy with the progress so far.  It really shows how
  flexible the Clojurescript compiler is that a macro system could be
  added in under 75 lines of code, with nearly half of that being very
  lightly modified from the compiler itself.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/cljs-macros/#comments" type="text/html" />


	<link rel="comments" href="/posts/cljs-macros/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Clojure Data Structures</title>

	<id>http://chrismgray.github.com//posts/clojure-data-structures/</id>

	<link href="http://chrismgray.github.com//posts/clojure-data-structures/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="lab-notes" />


	<updated>2012-04-01T01:27:15Z</updated>
	<published>2012-04-01T01:27:15Z</published>

	<content type="html" xml:lang="en">
	
&lt;p&gt;This past week, I&#39;ve been knee-deep in Clojure data structures --
mostly persistent vector and hash-map.  The goal has been to provide
replacements written in pure Clojure that can be ported to
ClojureScript, but it has also been a great way to learn about how
these structures work.  So in this post, I&#39;ll try to summarize what I
learned, and give some the results of my hacking.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Vector&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I started this project inspired by a tweet by &lt;a href=&quot;https://twitter.com/#!/swannodette&quot;&gt;David Nolen&lt;/a&gt;.  I can&#39;t
  find it any more, but he mentioned that he had ported the
  persistent-vector data structure to JavaScript and that he was
  hoping to use it in ClojureScript.  That made me think: since
  the ClojureScript compiler now supports languages other than
  JavaScript as its backends, wouldn&#39;t it be helpful, at least for
  those backends, to port the data structure to pure Clojure, so that
  any ClojureScript backend could use it?
&lt;/p&gt;
&lt;p&gt;
  So I did.  The result is &lt;a href=&quot;https://github.com/chrismgray/persistent-data-structures/blob/master/src/persistent_data_structures/vector.clj&quot;&gt;here&lt;/a&gt;.  Instead of merely mechanically
  porting the Java into Clojure, I tried to really understand what was
  going on.  The gist is really simple (and has been talked about
  before): the vector is actually a tree with branching-factor 32, and
  a buffer of size 32.  When you add to the vector, you really add to
  the buffer if you can, copying the buffer before writing to it.
  When the buffer fills up, it is put in the tree, and again nodes are
  copied rather than simply written-to.
&lt;/p&gt;
&lt;p&gt;
  This procedure means that adding an element is a \(O(\log n)\)
  operation, but the constants are really good: for one thing, the
  base of the \(\log\) is 32, so the influence of the \(\log n\) in
  the overall running time is pretty small even for very large \(n\).
  For another thing, the \(\log n\) penalty is only incurred on every
  thirty-second insert.  Most inserts are constant-time.
&lt;/p&gt;
&lt;p&gt;
  Another cool feature is the way that the tree is structured.  Each
  node has its children in an array of length 32.  This means that the
  subtree that contains a given element can be found very quickly by
  simple bit operations.  To find the subtree containing element \(i\)
  in tree level \(k\), you shift \(i\) to the right by \(5k\) places
  and take the rightmost 5 bits.  This procedure would work with
  arrays that are of length of any power of 2, where you replace 5 by
  the \(\log_2\) of the length.
&lt;/p&gt;
&lt;p&gt;
  Anyway, László Török had pretty much the same idea as I did (and the
  author of gvec.clj, which is in the core distribution, had the same
  idea before either of us), and his code was better-tuned than mine,
  so it is what went into the new release of ClojureScript.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;An aside&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;


&lt;p&gt;
   When vectors are created in Clojure (but not yet in ClojureScript),
   they are created by way of a transient vector.  The idea behind this
   is that the transient vector is only around for the creation of the
   vector, so it does not need to be persistent.  Thus, it does not
   need to use the copy-on-write policy that persistent vectors use.
   In order to build a larger vector, it simply adds to an empty vector
   using the same procedure that I outlined above.
&lt;/p&gt;
&lt;p&gt;
   Theoretically at least, that is not the optimal algorithm.  The
   trees can be built from the bottom-up (much like &lt;a href=&quot;http://chrismgray.github.com//tags/lab-notes/./../../posts/clojure-sorting&quot;&gt;heaps&lt;/a&gt;), giving a
   \(O(n)\) algorithm, which also has very good constants.  I haven&#39;t
   computed the constant, but it should be less than \(1 {1 \over
   16}\).  I implemented this algorithm in Clojure, but the difference
   in constants between Clojure code and pure Java code, and the fact
   that the constants in the Java implementation are &lt;b&gt;so&lt;/b&gt; low meant
   that my implementation was slower even for very large \(n\).  I may
   one day try to port my bottom-up algorithm back to Java, but I kind
   of doubt it would make much difference.  Sometimes the
   theoretically better solution just isn&#39;t better in the real world.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Hash Maps&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I also had a look at hash maps.  The basic idea behind any hash-map
  is to store a key-value pair by first computing the &lt;i&gt;hash&lt;/i&gt; of the
  key to something much smaller &amp;ndash; in Clojure&#39;s case a 32-bit integer
  &amp;ndash; and then storing the pair in a location based on that hash.
  There are many ways that this could be done, and I had a look at the
  Java implementation used in Clojure and decided that I didn&#39;t really
  want to do much more porting.  So I came up with a couple of ideas
  that are related to Clojure&#39;s way of doing it.
&lt;/p&gt;
&lt;p&gt;
  The first idea was to make the same tree as used in the vector
  implementation, but to fill it in only as needed.  In essence, this
  was a sparse vector.  The Clojure implementation does something
  similar to this, but goes one step further by using a bit-map to
  signify which branches of the tree are actually used.  In this way,
  it can avoid copying arrays that are mostly full of placeholders.
&lt;/p&gt;
&lt;p&gt;
  The next idea was a bit more radical.  It involved making a &lt;a href=&quot;https://en.wikipedia.org/wiki/Patricia_trie&quot;&gt;radix tree&lt;/a&gt; of the input data.  Of all my experiments, this might have been
  the most successful.  In Clojure, its performance is very close to
  the built-in data structure.  In ClojureScript, for some reason it
  is much faster at storing new data than the built-in data structure
  but somewhat slower at retrieving data.  I am thinking that there
  must be some JavaScript-specific reason for this, but I haven&#39;t
  found it yet.  It could just be that the ClojureScript data
  structure is asymmetric in the opposite way (I haven&#39;t yet looked
  very deeply at it).
&lt;/p&gt;
&lt;p&gt;
  In all cases, the theoretical running times are pretty much what
  you&#39;d expect.  To either insert a new key-value pair or to find a
  key, it&#39;s basically the sum of the time needed to hash the key, a
  constant to find the place where the key is stored, and then
  something proportional to the number of other keys that have the
  same hash value that have been inserted so far.
&lt;/p&gt;
&lt;p&gt;
  In practice, large collections must be hashed each time they&#39;re
  inserted or searched for, so using them as keys is probably not a
  great idea.  In Clojure, negative numbers hash to one less than
  their absolute value, so there will probably be collisions if you
  use a large number of positive and negative numbers as keys, but
  it&#39;s not that big of a deal, since the number of collisions
  generated by this is at most two.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Conclusions&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  At the very least, this was a good way to learn what&#39;s really going
  on under the hood.  I also did a lot of tuning &amp;ndash; not only adding
  typehints, but re-implementing some lazy functions to be non-lazy --
  which is certainly good experience.  I never made a data structure
  that was faster than one of the ones implemented in Java, but I got
  pretty close in both cases.  In order to get meaningful tests, I had
  to do things in a very big way: putting millions of things in
  vectors, and querying hash-maps hundreds of thousands of times.
  Most programs will not do these operations at such scales, and most
  of the tests still took less than a second on my underpowered
  laptop.  That makes me think pretty highly of the existing data
  structures in Clojure.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/clojure-data-structures/#comments" type="text/html" />


	<link rel="comments" href="/posts/clojure-data-structures/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Org Plugin Rethink</title>

	<id>http://chrismgray.github.com//posts/org-ikiwiki-plugin-5/</id>

	<link href="http://chrismgray.github.com//posts/org-ikiwiki-plugin-5/"/>






	<category term="emacs" />

	<category term="ikiwiki" />

	<category term="ikiwiki-org-plugin" />

	<category term="lab-notes" />

	<category term="org-mode" />


	<updated>2012-03-14T15:47:03Z</updated>
	<published>2012-03-14T15:47:03Z</published>

	<content type="html" xml:lang="en">
	
&lt;p&gt;I am glad to announce a new version of my &lt;a href=&quot;https://github.com/chrismgray/ikiwiki-org-plugin&quot;&gt;ikiwiki org plugin&lt;/a&gt;.  This is
a major change to the way things had worked previously, and is much
faster than previous versions.
&lt;/p&gt;
&lt;p&gt;
The installation procedure has changed, so please read the
&lt;code&gt;README.org&lt;/code&gt; file in the repository for information about how to
install the plugin.  Also, if you have installed a previous version,
please remove that since it may conflict.  Also be sure that you kill
any daemonized versions of emacs that are running.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Background&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  This version of the plugin is no longer what ikiwiki calls an
  &quot;external plugin&quot;.  The overhead associated with XML-RPC was simply
  too high (at least on the emacs side of things).  I tried
  &lt;a href=&quot;http://chrismgray.github.com//tags/lab-notes/./../../posts/ikiwiki-hacking&quot;&gt;working around&lt;/a&gt; it by having less communication between the compiler
  and the plugin, but the ikiwiki developers &lt;a href=&quot;http://ikiwiki.info/todo/be_more_selective_about_running_hooks/&quot;&gt;didn&#39;t really think it was a great idea&lt;/a&gt;.  So I have basically scrapped the idea of the
  plugin being external.
&lt;/p&gt;
&lt;p&gt;
  The nice thing about that is that it allowed me to remove a lot of
  code on the emacs side.  Instead of communication via XML-RPC, the
  new plugin can put the content to be interpreted in a file and call
  emacsclient directly.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Security&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I note in &lt;code&gt;README.org&lt;/code&gt; that there is a concern about security.  This
  is because any program that calls another program with
  user-generated arguments should be concerned about security.  As far
  as I can tell, the only way that something bad can happen is if
  someone creates a filename with an unmatched double-quote and
  convinces ikiwiki to accept it.  Since ikiwiki doesn&#39;t accept
  filenames with double-quotes anyway, there really shouldn&#39;t be a
  problem.
&lt;/p&gt;
&lt;p&gt;
  However, I would recommend that this plugin not be used in
  situations where untrusted people can create files (such as from the
  CGI interface), unless you personally verify that nothing bad can
  happen.  As always, this is free software and comes with no
  warranty.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Remaining todos&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  I would like to get rid of the potential security hole so that
  people could feel safe running this plugin from the CGI interface.
  I would also like to get rid of the hardcoded org configuration and
  let that be stored in the user&#39;s setup file.  I have a branch that
  does that using the old architecture, so it should not be too
  difficult to port to the new architecture.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/org-ikiwiki-plugin-5/#comments" type="text/html" />


	<link rel="comments" href="/posts/org-ikiwiki-plugin-5/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>A bit of ikiwiki hackery</title>

	<id>http://chrismgray.github.com//posts/ikiwiki-hacking/</id>

	<link href="http://chrismgray.github.com//posts/ikiwiki-hacking/"/>






	<category term="ikiwiki" />

	<category term="lab-notes" />


	<updated>2012-02-09T23:45:17Z</updated>
	<published>2012-02-09T23:45:17Z</published>

	<content type="html" xml:lang="en">
	
&lt;p&gt;Spurred on by the first comment by an actual user of my plugin today,
I tracked down one of the major bottlenecks for external ikiwiki
plugins.  My fix might not be the most elegant, but it works so far.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;The problem&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  Ikiwiki plugins work by calling a function named &lt;code&gt;hook&lt;/code&gt; which lets
  them tell the ikiwiki compiler that they implement a certain
  subroutine.  Whenever that subroutine needs to be called, the
  ikiwiki compiler calls &lt;code&gt;run_hooks&lt;/code&gt;, and that runs all the registered
  functions.
&lt;/p&gt;
&lt;p&gt;
  For most of these hooked functions (&lt;code&gt;htmlize&lt;/code&gt; is the only exception
  I can think of), all of the registered functions are called,
  regardless of file type.  This is normally not a problem, because
  the plugin can check the type of content that it is given and only
  operate on the types of content that it knows anything about.
&lt;/p&gt;
&lt;p&gt;
  For external plugins, however, there is a problem.  Ikiwiki
  communicates with external plugins via xml-rpc on &lt;code&gt;stdin&lt;/code&gt; and
  &lt;code&gt;stdout&lt;/code&gt;.  Every function call that it makes involves writing the
  function&#39;s parameters on &lt;code&gt;stdout&lt;/code&gt;.  When there is a file type that
  is unknown to the external plugin, all that effort (I/O is the main
  time sink I think, but the content must also be encoded correctly
  for xml-rpc) is wasted.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;The solution&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I have added a parameter named &quot;exclusive&quot; to the optional arguments
  that are accepted by the &lt;code&gt;hook&lt;/code&gt; function.  When this argument exists
  (and is true), the registered function is only run when the type of
  file is the same as the type of file that the plugin accepts.  So
  far, it only works with the &lt;code&gt;scan&lt;/code&gt; and &lt;code&gt;linkify&lt;/code&gt; hooks, which were
  the main areas that slowed my plugin down.  However, it is quite
  simple to get it to work with other hooks as well.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/ikiwiki-hacking/#comments" type="text/html" />


	<link rel="comments" href="/posts/ikiwiki-hacking/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Two Small Clojure Packages</title>

	<id>http://chrismgray.github.com//posts/small-clojure-libs/</id>

	<link href="http://chrismgray.github.com//posts/small-clojure-libs/"/>






	<category term="clojure" />

	<category term="lab-notes" />

	<category term="lru-maps" />

	<category term="thrush" />


	<updated>2012-01-07T02:23:15Z</updated>
	<published>2012-01-07T02:23:15Z</published>

	<content type="html" xml:lang="en">
	
&lt;p&gt;I&#39;ve been working on a larger project lately, but in doing so I found
two little things that were independent of the project and useful
enough for me to release as Clojure packages.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Parallel Thrush&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I discussed the Clojure &lt;a href=&quot;http://chrismgray.github.com//tags/lab-notes/./../../posts/luhnybin&quot;&gt;thrush operator&lt;/a&gt; once before.  The way that I
  have been using it lately is to operate on a stream of data, perhaps
  condensing the stream at the end into one value.  This suggested to
  me that I should be able to operate on the stream of data in
  parallel, since all of the functions that I am using are pure.
&lt;/p&gt;
&lt;p&gt;
  What I have done with the new package is to create a new macro
  called &lt;code&gt;||-&amp;gt;&amp;gt;&lt;/code&gt;.  This operates just like the &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; macro already in
  Clojure, except that it splits the data in the stream and runs it in
  parallel.  Behind the scenes, it uses the Clojure &lt;code&gt;pmap&lt;/code&gt; function,
  which advises that it should only be used when the operation being
  done is CPU-intensive enough to exceed the coordination cost.  Since
  multiple functions are put together by my macro before they are
  passed to &lt;code&gt;pmap&lt;/code&gt;, following this advice should become easier.
&lt;/p&gt;
&lt;p&gt;
  As an example:
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(||-&amp;gt;&amp;gt; data
       (map big-function)
       (filter odd?)
       :merge
       (reduce +))
&lt;/pre&gt;


&lt;p&gt;
  is the same as
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(-&amp;gt;&amp;gt; data
     (map big-function)
     (filter odd?)
     (reduce +))
&lt;/pre&gt;


&lt;p&gt;
  but everything before the &lt;code&gt;:merge&lt;/code&gt; statement is executed in
  parallel.
&lt;/p&gt;
&lt;p&gt;
  Of course, the source is on &lt;a href=&quot;https://github.com/chrismgray/parallel-thrush&quot;&gt;my github&lt;/a&gt;.  The jar can also be easily
  downloaded from &lt;a href=&quot;https://clojars.org/parallel-thrush&quot;&gt;clojars&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;LRU maps&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  The project I&#39;ve been working on has partly been a struggle to
  manage resources.  Thus, I&#39;ve needed a good way to keep some of the
  resources in memory and get rid of the ones that are no longer
  relevant.  Using a &lt;code&gt;hash-map&lt;/code&gt; data structure is always nice, so I&#39;ve
  implemented a variant of a &lt;code&gt;hash-map&lt;/code&gt; that has an upper limit on its
  size.  When you try to add an element that would cause the map to
  have too many elements, it kicks out the element that was least
  recently added or modified.
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(apply lru-map 4 (range 20))
;=&amp;gt; {12 13, 14 15, 16 17, 18 19}
&lt;/pre&gt;


&lt;p&gt;
  Sometimes, you want to do something with an element as it gets
  kicked out.  For that, there is &lt;code&gt;lru-map-with&lt;/code&gt;.  This takes two
  extra arguments &amp;ndash; a function that operates on some &quot;state&quot; and the
  element that is getting kicked out and the initial &quot;state&quot;.  (Behind
  the scenes, this &quot;state&quot; isn&#39;t really state, but it is helpful to
  think of it as state.)
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(apply lru-map-with 4 conj [] (range 20))
;=&amp;gt; {12 13, 14 15, 16 17, 18 19, :lru-state [[0 1] [2 3] [4 5] [6 7] [8 9] [10 11]]}
&lt;/pre&gt;


&lt;p&gt;
  Again, this little package is on &lt;a href=&quot;https://github.com/chrismgray/least-recently-used-map&quot;&gt;github&lt;/a&gt; and the jar is on &lt;a href=&quot;https://clojars.org/least-recently-used-map&quot;&gt;clojars&lt;/a&gt;.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/small-clojure-libs/#comments" type="text/html" />


	<link rel="comments" href="/posts/small-clojure-libs/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Lessons learned (so far) from the ikiwiki plugin</title>

	<id>http://chrismgray.github.com//posts/org-ikiwiki-plugin-3/</id>

	<link href="http://chrismgray.github.com//posts/org-ikiwiki-plugin-3/"/>






	<category term="emacs" />

	<category term="ikiwiki" />

	<category term="ikiwiki-org-plugin" />

	<category term="lab-notes" />

	<category term="org-mode" />


	<updated>2011-12-07T22:42:09Z</updated>
	<published>2011-12-07T22:00:36Z</published>

	<content type="html" xml:lang="en">
	
&lt;p&gt;Writing my &lt;a href=&quot;http://chrismgray.github.com//tags/lab-notes/./../../posts/org-ikiwiki-plugin&quot;&gt;new plugin&lt;/a&gt; in Emacs Lisp, I learned a few things.  Here are
some of them, in no particular order.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;xml-rpc.el has some problems&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I don&#39;t mean to be unkind here.  xml-rpc.el seems pretty good if you
  are doing exactly one kind of thing: calling a method on a server
  that can be reached by http.  For anything else, it is very hard to
  use.   My plugin has the following requirements:
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It must be called by another program through xml-rpc.
&lt;/li&gt;
&lt;li&gt;It must read from and write to files (and not http).
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    
  Neither of these things is made easy with xml-rpc.  The first I can
  understand &amp;ndash; xml-rpc would have to somehow insinuate itself into
  the emacs event loop and watch for calls all the time.  The second
  is less easy to understand.  Parsing xml-rpc is not really related
  to reading from http.  So why are the two things tied together?  In
  my opinion, xml-rpc.el would be a much nicer library if parsing the
  xml-rpc was separated completely from the http stuff.  There could
  be convenience functions, but they would be a layer of abstraction
  on top of the other two layers.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;xml.el has some problems&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  There isn&#39;t a function to get a list of all nodes with a given name?
  Are you kidding me?  Here is my implementation, but I bet there is a
  better one somewhere:
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(defun xml-find-nodes-matching (node name)
  &quot;Returns all children of `node&#39; that have an `xml-node-name&#39; equal to `name&#39;.&quot;
  (if (or (eq node &#39;()) (not (listp node)))
      &#39;()
    (if (equal (xml-node-name node) name)
        (cons node (delq nil (mapcar (lambda (nd) (xml-find-nodes-matching nd name)) (xml-node-children node))))
      (delq nil (apply &#39;append (mapcar (lambda (nd) (xml-find-nodes-matching nd name)) (xml-node-children node)))))))
&lt;/pre&gt;


&lt;p&gt;
  In general, both xml-rpc.el and xml.el use a distressing number of
  calls to &lt;code&gt;car&lt;/code&gt;, &lt;code&gt;cdr&lt;/code&gt;, and &lt;code&gt;cdaddr&lt;/code&gt; (and all the versions in
  between).  
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Perl has some problems&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  Ikiwiki sends named parameters as an even-lengthed xml-rpc array
  rather than as an xml-rpc struct.  This is because not all of the
  functions that can be called via xml-rpc take named parameters and I
  guess Perl isn&#39;t smart enough to tell a hash from an even-lengthed
  array.  This isn&#39;t a huge problem, but it does mean that I need to
  convert the input to each of the functions that I write into a hash
  before I use it.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Ikiwiki has some problems&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;


&lt;p&gt;
  I would like to be able to ignore files that don&#39;t have a particular
  extension.  For &lt;code&gt;htmlify&lt;/code&gt;, this is the way it works by default.  It
  seems like most of the functions that plugins can implement are not
  this way by default, though, and that is a shame.  If the plugin is
  not external &amp;ndash; that is, it is written in Perl &amp;ndash; there is really no
  problem.  The function is called, checks the extension of the source
  file, and returns without doing anything.  However, when the plugin
  is external and the call must happen through xml-rpc, ikiwiki must
  transmit the data via xml-rpc and receive the returned data back via
  xml-rpc.  Unnecessary calls take a lot longer in that context.
&lt;/p&gt;
&lt;p&gt;
  So I would like for most calls to &lt;code&gt;hook&lt;/code&gt; to take an optional
  &lt;code&gt;extension&lt;/code&gt; parameter that takes an extension (or even better, a
  regexp), and only call the function if the file name has the same
  extension (or matches the regexp).
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-5&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-5&quot;&gt;Working with emacs buffers is pretty nice&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-5&quot;&gt;


&lt;p&gt;
  Does a function that you&#39;re trying to write in emacs lisp give you a
  string?  It&#39;s pretty easy to throw it in a temporary buffer and then
  tell emacs to do the things that you would normally do while you
  were editing in order to get the proper information out of the
  string.  The &lt;code&gt;with-temporary-buffer&lt;/code&gt; macro makes it especially easy
  to do just that.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-6&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-6&quot;&gt;Getting info from a structured list is easier to do as a recursive function&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-6&quot;&gt;


&lt;p&gt;
  One of the things that took me the longest was to figure out what
  this couple of lines of code was doing:
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(setq valtype (car (caddar xml-list))
      valvalue (caddr (caddar xml-list)))  
&lt;/pre&gt;


&lt;p&gt;
  What should the value of &lt;code&gt;xml-list&lt;/code&gt; look like in order to get the
  correct thing out of it?  It turned out that I needed to take the
  &lt;code&gt;cdr&lt;/code&gt; of the &lt;code&gt;cdaddr&lt;/code&gt; of the &lt;code&gt;caddar&lt;/code&gt; of the parsed xml in order to
  get the correct value.  That only worked when ikiwiki was responding
  to a method call, though.  I had a much easier time getting the
  right values out when I simply started using the
  &lt;code&gt;xml-find-nodes-matching&lt;/code&gt; function that I showed above.
&lt;/p&gt;
&lt;p&gt;
  When you see yourself writing more than a few &lt;code&gt;car&lt;/code&gt; or &lt;code&gt;cdr&lt;/code&gt; calls
  in a row (or &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;rest&lt;/code&gt;, or &lt;code&gt;nth&lt;/code&gt; calls in Clojure), stop and
  try to write a function that finds what you are looking for.  The
  function doesn&#39;t have to be recursive, but that might be the easiest
  way to do it.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-7&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-7&quot;&gt;It&#39;s nice when all calls and responses are dumped to a file&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-7&quot;&gt;


&lt;p&gt;
  In a sense, this is just saying that code can be easier to debug if
  you&#39;re tracing it.  But since the calls between ikiwiki and the
  plugin must go through files anyway, we get the program traced
  automatically.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/org-ikiwiki-plugin-3/#comments" type="text/html" />


	<link rel="comments" href="/posts/org-ikiwiki-plugin-3/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Convex Hulls</title>

	<id>http://chrismgray.github.com//posts/convex-hulls/</id>

	<link href="http://chrismgray.github.com//posts/convex-hulls/"/>






	<category term="clojure" />

	<category term="computational-geometry" />

	<category term="convex-hull" />

	<category term="ikiwiki" />

	<category term="lab-notes" />


	<updated>2011-12-02T22:05:50Z</updated>
	<published>2011-11-30T18:06:31Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Convex Hulls Three Ways&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  Whenever I watch cooking competition shows, they always have chefs
  presenting a foodstuff cooked in multiple different ways.  Today,
  I&#39;m doing that with algorithms.
&lt;/p&gt;
&lt;p&gt;
  The algorithm in question today is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Convex_hull&quot;&gt;convex hull&lt;/a&gt; algorithm.  In
  order of implementation complexity, and descending order of
  theoretical running time, there is the Jarvis March, Graham&#39;s Scan,
  and Chan&#39;s Algorithm.  All three are implemented in Clojure in my
  &lt;a href=&quot;https://github.com/chrismgray/convex-hull&quot;&gt;github repository&lt;/a&gt;.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;Jarvis March&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;


&lt;p&gt;
   The simplest of the algorithms, the Jarvis March was also one of
   the first output-sensitive computational geometry algorithms.  In a
   nutshell, you first find a point that you know to be on the convex
   hull, and then you find the next point by looking at all the rest
   of the points and determining which one has a segment that has the
   property that all the rest of the points are on one side of it.
   You repeatedly find the next point using this procedure until you
   get back to the first point.  There is basically no way to
   implement this algorithm that does not have a running time of
   \(O(hn)\), where \(h\) is the number of points on the convex hull
   and \(n\) is the number of input points.
&lt;/p&gt;
&lt;p&gt;
   The one implementation detail of the Jarvis March that is
   interesting is that whenever you see the concept of &quot;finding the
   next thing&quot; given some previous information, the Clojure
   implementation should almost always be lazy.  It turns out that
   implementing Jarvis March lazily will help in implementing Chan&#39;s
   Algorithm, so keep that in mind.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-1-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-2&quot;&gt;Graham&#39;s Scan&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-2&quot;&gt;


&lt;p&gt;
   Graham&#39;s Scan is one of the algorithms I remember most vividly from
   the undergraduate computational geometry course that I took.  The
   professor, Godfried Toussaint, always referred to it as the &quot;three
   coins&quot; algorithm, so I have kept up that tradition in some of my
   function names in my implementation.
&lt;/p&gt;
&lt;p&gt;
   The algorithm first makes a polygon of the input points by sorting
   them by angle about the bottom-most point.  Then it goes around the
   polygon with a stack, pushing and popping points as it goes.  If
   that sounds familiar, it should &amp;ndash; it&#39;s the same idea as what I was
   talking about when I brought up the idea of &lt;a href=&quot;http://chrismgray.github.com/posts/parsing-polygons/&quot;&gt;parsing polygons&lt;/a&gt; a week
   and a half ago. 
&lt;/p&gt;
&lt;p&gt;
   Thus, I used the same polygon-parsing monad in my implementation as
   when I computed the visibility polygons last week.  It still works
   just as well.
&lt;/p&gt;
&lt;p&gt;
   Since the points must be sorted, Graham&#39;s Scan takes \(\Theta(n
   \log n)\).  Sorting can be reduced to computing convex hulls, so
   computing convex hulls has a \(\Omega(n \log n)\) lower bound,
   meaning that this algorithm is optimal.
&lt;/p&gt;
&lt;p&gt;
   But Chan&#39;s algorithm is better.  Weird huh?
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-1-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-3&quot;&gt;Chan&#39;s Algorithm&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-3&quot;&gt;


&lt;p&gt;
   I must confess that I had always been a little intimidated by
   Chan&#39;s Algorithm.  It was invented by Timothy Chan, who has a
   well-earned reputation for being a genius, so I thought it would be
   really complicated.  It&#39;s not.  There is a decent &lt;a href=&quot;http://en.wikipedia.org/wiki/Chan&#39;s_algorithm&quot;&gt;description&lt;/a&gt; of it
   on Wikipedia, so I won&#39;t go into the details.  The gist is that you
   combine the two previous algorithms that I discussed.  The Jarvis
   March needs to be modified so that the points can be input as a
   list of smaller convex hulls, and the next point on the convex hull
   is found by doing a binary search on the smaller convex hulls.  But
   that is really the hardest part about the algorithm.  I have put
   the whole thing below, because I think it&#39;s pretty beautiful.
&lt;/p&gt;



&lt;pre class=&quot;example&quot;&gt;(defn chans-algorithm
  &quot;Finds the convex hull of a set of points by
   the algorithm known as &#39;Chan&#39;s Algorithm&#39;.&quot;
  [pts]
  (let [bottom-pt (apply min-key :y pts)]
   (loop [m 3] ; start out with triangles
     (let [partitioned-pts (partition m m [] pts)
           c-hs (map grahams-scan partitioned-pts)
           potential-ch (take m (apply jarvis-march pts c-hs))]
       (if (= bottom-pt (last potential-ch)) ; assumes jarvis-march returns bottom-pt last
         potential-ch
         (recur (min (* m m) (count pts))))))))
&lt;/pre&gt;


&lt;p&gt;
   The great thing about Chan&#39;s Algorithm is that it is also
   output-sensitive.  But instead of being \(O(nh)\) (which is
   \(O(n^2)\) in the worst case), it is \(O(n \log h)\), which is at
   least as good as Graham&#39;s Scan, but often better.  It is also quite
   simple to implement, given decent implementations of Jarvis March
   and Graham&#39;s Scan.  
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  Convex hull algorithms are great.  If I was ever to teach a
  computational geometry course (admittedly that&#39;s looking like a long
  shot now), I might start and finish the course with them.  The
  progression from the ultra-simple Jarvis March to the
  more-complicated Chan&#39;s Algorithm is really nice, and there are
  interesting new things to talk about the whole way.  They also show
  that computational geometry is not so hard to do in a functional
  style.  In fact, using laziness is what makes the implementation of
  Chan&#39;s Algorithm so simple.  So this might make a nice talk to give
  people who are already into functional programming as well.
&lt;/p&gt;
&lt;p&gt;
  The next thing I have in mind for this project is to animate the
  algorithms.  Viewing the output of algorithms is already pretty easy
  using Processing, but I would like to be able to see them as they
  are operating.  It would be great if I could do that without
  changing the code too much.  I have a couple of ideas, but I&#39;m not
  sure if they&#39;ll work yet.
&lt;/p&gt;
&lt;p&gt;
  Also, it is slightly embarrassing to admit, but my blogging system
  seems to not support putting images in posts.  So I am going to have
  to figure out how to work around (or even fix) that before I can
  show any results.
&lt;/p&gt;





&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/convex-hulls/#comments" type="text/html" />


	<link rel="comments" href="/posts/convex-hulls/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Lazy Sorting in Clojure</title>

	<id>http://chrismgray.github.com//posts/clojure-sorting/</id>

	<link href="http://chrismgray.github.com//posts/clojure-sorting/"/>






	<category term="clojure" />

	<category term="lab-notes" />

	<category term="sort" />


	<updated>2011-12-01T07:45:44Z</updated>
	<published>2011-11-27T14:23:34Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Penance&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  In a job interview last week I said a couple of things related to
  sorting in Clojure that turned out to be incorrect when I checked
  them.  This is my way of making up for them &amp;ndash; if I can make them
  true, then no one will notice.  Though to be fair, I&#39;m sure that I&#39;m
  the only one that thinks that way.
&lt;/p&gt;
&lt;p&gt;
  The first thing I said was that heap-sort is my favorite sorting
  algorithm, but then I declined to implement it, preferring to
  implement merge-sort instead.  I think this is actually pretty
  reasonable in an interview situation &amp;ndash; heap-sort is a conceptually
  more difficult sorting algorithm, so being able to remember it on
  the spot is more difficult.  The second thing I said was that
  Clojure itself uses heap-sort and that given its love affair with
  laziness that it would not be unreasonable to assume that &lt;code&gt;(first   (sort lst))&lt;/code&gt; was a linear-time operation.  I might have read
  something like this on a mailing list or IRC, but it is not
  correct.  Clojure currently uses Java&#39;s &lt;code&gt;sort&lt;/code&gt; function, which is a
  slightly-modified merge-sort.  There is not much point in making
  that algorithm lazy, because getting the first element from the
  sorted list requires \(O(n \log n)\) time anyway.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Heap Sort&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  For those that are not familiar with it, heap-sort is something that
  is usually taught in a second-year undergraduate Computer Science
  class.  So it&#39;s not &lt;b&gt;that&lt;/b&gt; difficult an algorithm, but it does
  require some thinking, and there is some fancy analysis that goes
  into part of it.  For a full discussion, see the &lt;a href=&quot;http://www.amazon.com/gp/product/0262033844/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;tag=hikiandcodi-20&amp;amp;linkCode=as2&amp;amp;camp=217145&amp;amp;creative=399369&amp;amp;creativeASIN=0262033844&quot;&gt;Introduction to Algorithms&lt;/a&gt; book by Cormen, Lieserson, Rivest, and Stein.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-1&quot;&gt;Heap&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-1&quot;&gt;


&lt;p&gt;
   To start with, a &lt;i&gt;heap&lt;/i&gt; is conceptually a tree where values are
   stored at the nodes.  The largest value of all the values stored in
   subtrees is stored at the root and the two descendant trees are
   heaps.  Heaps are usually required to be as close to balanced as
   possible &amp;ndash; if any level of the tree has leaves, they are all
   bunched to the right, and all the rest of the leaves are at the
   next level.
&lt;/p&gt;
&lt;p&gt;
   Such a tree is usually implemented as an array, where the child
   nodes of a node can be obtained by some simple arithmetic on the
   index of the node in the array.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-2&quot;&gt;Building a Heap&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-2&quot;&gt;


&lt;p&gt;
   Given the definition, there is an intuitive algorithm for building
   such a heap on a set of numbers: first find the largest number in
   your set and have it be the root of the heap, then split the rest
   of the numbers in half, and recursively make heaps on those sets.
&lt;/p&gt;
&lt;p&gt;
   Such an algorithm is clearly correct, but it is also clearly
   \(\Theta(n \log n)\).  We can do better with a bottom-up algorithm.
   If we continue imagining the heap as a tree, we start by putting
   the input numbers into the tree willy-nilly.  This clearly does not
   satisfy the heap properties laid out above.  However, some of it
   does satisfy the heap properties &amp;ndash; the leaves of the tree are
   trivially heaps.  If we go up one level from the leaves, we can fix
   the trees rooted there by exchanging the root of the tree with its
   largest child (or not exchanging it if it&#39;s already the largest of
   the three).  Higher levels are a bit more difficult, because if the
   root of a tree is exchanged, then we must make sure to fix the tree
   that it ends up being the root of.  You can imagine the root of a
   tree traveling down the heap until it is larger than both of its
   children.
&lt;/p&gt;
&lt;p&gt;
   The correctness of this algorithm is a bit harder to see and it
   also appears to take \(O(n \log n)\) time.  It does, but there is a
   slightly more sophisticated analysis that shows that it is really
   \(\Theta(n)\).  I won&#39;t go into the analysis, but a hint is that
   most of the values don&#39;t actually travel very far in the tree.  
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-3&quot;&gt;Using a heap to sort&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-3&quot;&gt;


&lt;p&gt;
   With the heap properties in mind, we can easily see how to get the
   largest value of a set of numbers &amp;ndash; just take the top element from
   the heap.  How can we use the heap properties to sort?  Well, we
   want the largest number, then the largest number that remains, then
   the largest number that remains after that, and so on.  So if we
   can take the largest number from the heap and then fix the heap so
   that it retains the heap properties, then we&#39;d be done.
&lt;/p&gt;
&lt;p&gt;
   We just devised a way to fix heaps when building the heap, so we
   use that.  What we do is to take the very last node in the heap
   (which is not necessarily the smallest, but it doesn&#39;t hurt to
   think about it as the smallest) and put that at the top of the
   heap.  The resulting tree is clearly not a heap, but if we call the
   algorithm to fix heaps on the root of the tree, then we end up with
   a heap again.  The node that we put on top of the heap might end up
   traveling all the way to the bottom, so this update takes
   \(\Theta(\log n)\) time.  Thus if we sort the entire input set, we
   have a \(\Theta(n \log n)\) algorithm.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-4&quot;&gt;Advantages&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-4&quot;&gt;


&lt;p&gt;
   That&#39;s the best we can do theoretically, which is great, but the
   Java &lt;code&gt;sort&lt;/code&gt; algorithm is also \(\Theta(n \log n)\), so why is there
   any advantage to using heap-sort?  In a language where laziness is
   embraced (such as Clojure), heap-sort can be made lazy.  That is,
   the next element of the sorted list can be computed only when it is
   needed.  Since the build-heap procedure described above takes
   linear time, getting the first element from the sorted list takes
   \(O(n)\) time.  Each subsequent element then takes \(O(\log n)\)
   time.  Thus, if only a small number of elements from the sorted
   list are needed, then this lazy version of heap-sort is
   theoretically faster than other sorts.
&lt;/p&gt;
&lt;p&gt;
   I can think of situations where this would actually have practical
   advantages.  For example, what if you were writing a search engine
   and wanted to obtain the \(k\) best results?  You could write an
   ad-hoc function that found the best result, removed it and recursed
   \(k - 1\) times.  Or you could just &lt;code&gt;(take k (heap-sort input))&lt;/code&gt;.
   The first would take \(O(kn)\) time, whereas the second would take
   \(O(k \log n + n)\) time.  In many practical situations, \(k\) is
   \(\Omega(\log n)\), which means that the first takes \(\Omega(n
   \log n)\) time, whereas the second takes only \(O(n)\) time.
   Essentially, the first is no better than the second solution with a
   non-lazy sorting algorithm.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-5&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-5&quot;&gt;Disadvantages&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-5&quot;&gt;


&lt;p&gt;
   Heap-sort has some disadvantages compared to other sorts of &lt;code&gt;sort&lt;/code&gt;
   algorithms.  The least theoretically significant is that the
   constants hidden in the big-O notation are higher than other
   sorting algorithms (tuned versions of quicksort can have extremely
   small constants).
&lt;/p&gt;
&lt;p&gt;
   Another disadvantage can be seen when dealing with data sets so
   large that they no longer fit in the computer&#39;s main memory.
   Something like merge-sort can be modified fairly easily so that the
   number I/O operations is minimized.  I haven&#39;t thought about it too
   deeply, but this doesn&#39;t seem quite so easy with heap-sort.
   However, I think that people dealing with such large datasets
   should probably be using specialized libraries anyway, so perhaps
   that isn&#39;t too bad.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Implementation&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  This whole discussion is a bit useless if it only remains at the
  theoretical level.  I have an implementation &lt;a href=&quot;https://github.com/chrismgray/clojure-heap-sort&quot;&gt;in my github repo&lt;/a&gt; that
  implements most of the ideas that are given above.  The code is
  highly optimized so that it is somewhat competitive with the native
  Java implementation.  This makes the code on the HEAD of the
  &lt;code&gt;master&lt;/code&gt; branch somewhat less than readable.  However, the first
  commit to the repository used Clojure vectors and a functional
  style, so if you would like to understand the code, you might start
  there. 
&lt;/p&gt;
&lt;p&gt;
  I (unfortunately) needed to use Java arrays and mutation rather than
  the more functional style that I have gotten used to, but the
  results speak for themselves.  Finding the first few elements of a
  sorted array is significantly faster than the Java version.  Finding
  the entire sorted list is somewhat slower than the Java version, but
  not too much.  This is not surprising for a couple of reasons.
  First, heap-sort tends to have larger constants than other sorting
  methods.  Secondly, this code is one day old.  The Java sort method
  has had years to be optimized.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;


&lt;p&gt;
  It may be dreaming, but I would love to see this idea (if not this
  implementation) put into Clojure proper.  I think the advantages
  from laziness outweigh the small constant slowdown versus using
  Java&#39;s &lt;code&gt;sort&lt;/code&gt;.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/clojure-sorting/#comments" type="text/html" />


	<link rel="comments" href="/posts/clojure-sorting/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>Processing</title>

	<id>http://chrismgray.github.com//posts/processing/</id>

	<link href="http://chrismgray.github.com//posts/processing/"/>






	<category term="clojure" />

	<category term="lab-notes" />

	<category term="processing" />

	<category term="visibility-polygon" />


	<updated>2011-12-01T07:45:19Z</updated>
	<published>2011-11-22T19:29:29Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Viewing visibility polygons&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I mentioned yesterday that it would be nice to see the output of my
  visibility polygon solution.  To that end, I created an extremely
  simple drawing editor using &lt;a href=&quot;http://processing.org/&quot;&gt;Processing&lt;/a&gt;.  I have to say, I loved it.
&lt;/p&gt;
&lt;p&gt;
  The most important feature to me is the extreme interactivity.  I
  can change functions extremely quickly with my tools &amp;ndash; redefining a
  Clojure function is either one or two keystrokes in emacs, depending
  how I choose to do it &amp;ndash; so I like a graphics environment that
  changes just as quickly.  This is what Processing, and in particular
  &lt;code&gt;clj-processing&lt;/code&gt;, offers.  I was able to define a function that
  draws the various objects (in this case, the polygon, the point
  where the mouse is, and the visibility polygon of the mouse point
  inside the polygon).  If I wanted to make any changes to this
  function &amp;ndash; for example, changing the color of the point where the
  mouse is &amp;ndash; I can simply redefine the function using my emacs tools
  and the change shows up immediately on the drawing.
&lt;/p&gt;
&lt;p&gt;
  I was able to use this to find a couple of minor bugs in my
  visibility-polygon-finding code, but in general, it worked really
  well on the first try.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;Shortcomings&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;


&lt;p&gt;
   There were a couple of things that slightly bothered me about
   &lt;code&gt;clj-processing&lt;/code&gt;.  First, it used quite a lot of CPU just to
   display a simple polygon without too many points.  I am probably
   using it rather naïvely, so it is possible that this is my problem
   and not the problem of &lt;code&gt;clj-processing&lt;/code&gt;.  However, the second
   problem is just that &lt;code&gt;clj-processing&lt;/code&gt; is showing its age.  I think
   it was probably one of the first Clojure libraries out there and
   much of the coding style hasn&#39;t evolved with the Clojure best
   practices that people use.  For example, some of the features do
   not work if you only &lt;code&gt;require&lt;/code&gt; the library &amp;ndash; you must &lt;code&gt;use&lt;/code&gt; it.  I
   try to only &lt;code&gt;require&lt;/code&gt; libraries, to avoid my namespace becoming
   overly populated, so it is frustrating when that doesn&#39;t work.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Going forward&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I need to clean up the code a bit before I can put it up on github,
  but it should be there soon.  It currently needs me to explicitly
  call the function in order to find the visibility polygon.  I would
  really like it to find the visibility polygon of any point where the
  mouse is inside the polygon.  However, determining if a point is
  inside a non-convex polygon tends to be a bit harder than it
  sounds.  You can shoot a ray in one direction from a point, and
  count the number of polygon edges that it crosses &amp;ndash; if it&#39;s even
  you are outside and if it&#39;s odd you are inside &amp;ndash; but what happens
  if the ray crosses a vertex?  There was a good experimental paper on
  this problem at a recent EuroCG.
&lt;/p&gt;
&lt;p&gt;
  So that&#39;s a slightly non-trivial problem.  I also coded an
  implementation of the Voronoi Diagram problem recently.  I should
  add a Processing UI to that as well.  I have a feeling that would be
  the easier task to do next, and I would surely discover some bugs in
  it while I did.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/processing/#comments" type="text/html" />


	<link rel="comments" href="/posts/processing/comments.atom" type="application/atom+xml" />

</entry>

</feed>
