<?xml version="1.0"?>
<rss version="2.0"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:dcterms="http://purl.org/dc/terms/" >
<channel>
<title>pages tagged clojure</title>
<link>http://chrismgray.github.com//tags/clojure/</link>
<description>Hiking and Coding</description>
<item>

	<title>Clojure Data Structures</title>


	<guid isPermaLink="false">http://chrismgray.github.com//posts/clojure-data-structures/</guid>

	<link>http://chrismgray.github.com//posts/clojure-data-structures/</link>


	<category>clojure</category>

	<category>clojurescript</category>

	<category>lab-notes</category>


	<pubDate>Sat, 31 Mar 2012 19:27:15 -0600</pubDate>
	<dcterms:modified>2012-04-01T01:27:15Z</dcterms:modified>

	<description>
&lt;p&gt;This past week, I&#39;ve been knee-deep in Clojure data structures --
mostly persistent vector and hash-map.  The goal has been to provide
replacements written in pure Clojure that can be ported to
ClojureScript, but it has also been a great way to learn about how
these structures work.  So in this post, I&#39;ll try to summarize what I
learned, and give some the results of my hacking.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Vector&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I started this project inspired by a tweet by &lt;a href=&quot;https://twitter.com/#!/swannodette&quot;&gt;David Nolen&lt;/a&gt;.  I can&#39;t
  find it any more, but he mentioned that he had ported the
  persistent-vector data structure to JavaScript and that he was
  hoping to use it in ClojureScript.  That made me think: since
  the ClojureScript compiler now supports languages other than
  JavaScript as its backends, wouldn&#39;t it be helpful, at least for
  those backends, to port the data structure to pure Clojure, so that
  any ClojureScript backend could use it?
&lt;/p&gt;
&lt;p&gt;
  So I did.  The result is &lt;a href=&quot;https://github.com/chrismgray/persistent-data-structures/blob/master/src/persistent_data_structures/vector.clj&quot;&gt;here&lt;/a&gt;.  Instead of merely mechanically
  porting the Java into Clojure, I tried to really understand what was
  going on.  The gist is really simple (and has been talked about
  before): the vector is actually a tree with branching-factor 32, and
  a buffer of size 32.  When you add to the vector, you really add to
  the buffer if you can, copying the buffer before writing to it.
  When the buffer fills up, it is put in the tree, and again nodes are
  copied rather than simply written-to.
&lt;/p&gt;
&lt;p&gt;
  This procedure means that adding an element is a \(O(\log n)\)
  operation, but the constants are really good: for one thing, the
  base of the \(\log\) is 32, so the influence of the \(\log n\) in
  the overall running time is pretty small even for very large \(n\).
  For another thing, the \(\log n\) penalty is only incurred on every
  thirty-second insert.  Most inserts are constant-time.
&lt;/p&gt;
&lt;p&gt;
  Another cool feature is the way that the tree is structured.  Each
  node has its children in an array of length 32.  This means that the
  subtree that contains a given element can be found very quickly by
  simple bit operations.  To find the subtree containing element \(i\)
  in tree level \(k\), you shift \(i\) to the right by \(5k\) places
  and take the rightmost 5 bits.  This procedure would work with
  arrays that are of length of any power of 2, where you replace 5 by
  the \(\log_2\) of the length.
&lt;/p&gt;
&lt;p&gt;
  Anyway, László Török had pretty much the same idea as I did (and the
  author of gvec.clj, which is in the core distribution, had the same
  idea before either of us), and his code was better-tuned than mine,
  so it is what went into the new release of ClojureScript.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;An aside&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;


&lt;p&gt;
   When vectors are created in Clojure (but not yet in ClojureScript),
   they are created by way of a transient vector.  The idea behind this
   is that the transient vector is only around for the creation of the
   vector, so it does not need to be persistent.  Thus, it does not
   need to use the copy-on-write policy that persistent vectors use.
   In order to build a larger vector, it simply adds to an empty vector
   using the same procedure that I outlined above.
&lt;/p&gt;
&lt;p&gt;
   Theoretically at least, that is not the optimal algorithm.  The
   trees can be built from the bottom-up (much like &lt;a href=&quot;http://chrismgray.github.com//tags/clojure/./../../posts/clojure-sorting&quot;&gt;heaps&lt;/a&gt;), giving a
   \(O(n)\) algorithm, which also has very good constants.  I haven&#39;t
   computed the constant, but it should be less than \(1 {1 \over
   16}\).  I implemented this algorithm in Clojure, but the difference
   in constants between Clojure code and pure Java code, and the fact
   that the constants in the Java implementation are &lt;b&gt;so&lt;/b&gt; low meant
   that my implementation was slower even for very large \(n\).  I may
   one day try to port my bottom-up algorithm back to Java, but I kind
   of doubt it would make much difference.  Sometimes the
   theoretically better solution just isn&#39;t better in the real world.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Hash Maps&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I also had a look at hash maps.  The basic idea behind any hash-map
  is to store a key-value pair by first computing the &lt;i&gt;hash&lt;/i&gt; of the
  key to something much smaller &amp;ndash; in Clojure&#39;s case a 32-bit integer
  &amp;ndash; and then storing the pair in a location based on that hash.
  There are many ways that this could be done, and I had a look at the
  Java implementation used in Clojure and decided that I didn&#39;t really
  want to do much more porting.  So I came up with a couple of ideas
  that are related to Clojure&#39;s way of doing it.
&lt;/p&gt;
&lt;p&gt;
  The first idea was to make the same tree as used in the vector
  implementation, but to fill it in only as needed.  In essence, this
  was a sparse vector.  The Clojure implementation does something
  similar to this, but goes one step further by using a bit-map to
  signify which branches of the tree are actually used.  In this way,
  it can avoid copying arrays that are mostly full of placeholders.
&lt;/p&gt;
&lt;p&gt;
  The next idea was a bit more radical.  It involved making a &lt;a href=&quot;https://en.wikipedia.org/wiki/Patricia_trie&quot;&gt;radix tree&lt;/a&gt; of the input data.  Of all my experiments, this might have been
  the most successful.  In Clojure, its performance is very close to
  the built-in data structure.  In ClojureScript, for some reason it
  is much faster at storing new data than the built-in data structure
  but somewhat slower at retrieving data.  I am thinking that there
  must be some JavaScript-specific reason for this, but I haven&#39;t
  found it yet.  It could just be that the ClojureScript data
  structure is asymmetric in the opposite way (I haven&#39;t yet looked
  very deeply at it).
&lt;/p&gt;
&lt;p&gt;
  In all cases, the theoretical running times are pretty much what
  you&#39;d expect.  To either insert a new key-value pair or to find a
  key, it&#39;s basically the sum of the time needed to hash the key, a
  constant to find the place where the key is stored, and then
  something proportional to the number of other keys that have the
  same hash value that have been inserted so far.
&lt;/p&gt;
&lt;p&gt;
  In practice, large collections must be hashed each time they&#39;re
  inserted or searched for, so using them as keys is probably not a
  great idea.  In Clojure, negative numbers hash to one less than
  their absolute value, so there will probably be collisions if you
  use a large number of positive and negative numbers as keys, but
  it&#39;s not that big of a deal, since the number of collisions
  generated by this is at most two.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Conclusions&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  At the very least, this was a good way to learn what&#39;s really going
  on under the hood.  I also did a lot of tuning &amp;ndash; not only adding
  typehints, but re-implementing some lazy functions to be non-lazy --
  which is certainly good experience.  I never made a data structure
  that was faster than one of the ones implemented in Java, but I got
  pretty close in both cases.  In order to get meaningful tests, I had
  to do things in a very big way: putting millions of things in
  vectors, and querying hash-maps hundreds of thousands of times.
  Most programs will not do these operations at such scales, and most
  of the tests still took less than a second on my underpowered
  laptop.  That makes me think pretty highly of the existing data
  structures in Clojure.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
</description>


	<comments>/posts/clojure-data-structures/#comments</comments>

</item>
<item>

	<title>Two Small Clojure Packages</title>


	<guid isPermaLink="false">http://chrismgray.github.com//posts/small-clojure-libs/</guid>

	<link>http://chrismgray.github.com//posts/small-clojure-libs/</link>


	<category>clojure</category>

	<category>lab-notes</category>

	<category>lru-maps</category>

	<category>thrush</category>


	<pubDate>Fri, 06 Jan 2012 19:23:15 -0700</pubDate>
	<dcterms:modified>2012-01-07T02:23:15Z</dcterms:modified>

	<description>
&lt;p&gt;I&#39;ve been working on a larger project lately, but in doing so I found
two little things that were independent of the project and useful
enough for me to release as Clojure packages.
&lt;/p&gt;

&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Parallel Thrush&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I discussed the Clojure &lt;a href=&quot;http://chrismgray.github.com//tags/clojure/./../../posts/luhnybin&quot;&gt;thrush operator&lt;/a&gt; once before.  The way that I
  have been using it lately is to operate on a stream of data, perhaps
  condensing the stream at the end into one value.  This suggested to
  me that I should be able to operate on the stream of data in
  parallel, since all of the functions that I am using are pure.
&lt;/p&gt;
&lt;p&gt;
  What I have done with the new package is to create a new macro
  called &lt;code&gt;||-&amp;gt;&amp;gt;&lt;/code&gt;.  This operates just like the &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; macro already in
  Clojure, except that it splits the data in the stream and runs it in
  parallel.  Behind the scenes, it uses the Clojure &lt;code&gt;pmap&lt;/code&gt; function,
  which advises that it should only be used when the operation being
  done is CPU-intensive enough to exceed the coordination cost.  Since
  multiple functions are put together by my macro before they are
  passed to &lt;code&gt;pmap&lt;/code&gt;, following this advice should become easier.
&lt;/p&gt;
&lt;p&gt;
  As an example:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(||-&amp;gt;&amp;gt; data
       (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;map&lt;/span&gt; big-function)
       (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;filter&lt;/span&gt; odd?)
       &lt;span style=&quot;color: #dca3a3; font-weight: bold;&quot;&gt;:merge&lt;/span&gt;
       (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;reduce&lt;/span&gt; +))
&lt;/pre&gt;


&lt;p&gt;
  is the same as
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(&lt;span style=&quot;color: #8cd0d3;&quot;&gt;-&amp;gt;&amp;gt;&lt;/span&gt; data
     (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;map&lt;/span&gt; big-function)
     (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;filter&lt;/span&gt; odd?)
     (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;reduce&lt;/span&gt; +))
&lt;/pre&gt;


&lt;p&gt;
  but everything before the &lt;code&gt;:merge&lt;/code&gt; statement is executed in
  parallel.
&lt;/p&gt;
&lt;p&gt;
  Of course, the source is on &lt;a href=&quot;https://github.com/chrismgray/parallel-thrush&quot;&gt;my github&lt;/a&gt;.  The jar can also be easily
  downloaded from &lt;a href=&quot;https://clojars.org/parallel-thrush&quot;&gt;clojars&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;LRU maps&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  The project I&#39;ve been working on has partly been a struggle to
  manage resources.  Thus, I&#39;ve needed a good way to keep some of the
  resources in memory and get rid of the ones that are no longer
  relevant.  Using a &lt;code&gt;hash-map&lt;/code&gt; data structure is always nice, so I&#39;ve
  implemented a variant of a &lt;code&gt;hash-map&lt;/code&gt; that has an upper limit on its
  size.  When you try to add an element that would cause the map to
  have too many elements, it kicks out the element that was least
  recently added or modified.
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(&lt;span style=&quot;color: #f0dfaf;&quot;&gt;apply&lt;/span&gt; lru-map 4 (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;range&lt;/span&gt; 20))
&lt;span style=&quot;color: #708070;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color: #7f9f7f;&quot;&gt;=&amp;gt; {12 13, 14 15, 16 17, 18 19}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;
  Sometimes, you want to do something with an element as it gets
  kicked out.  For that, there is &lt;code&gt;lru-map-with&lt;/code&gt;.  This takes two
  extra arguments &amp;ndash; a function that operates on some &quot;state&quot; and the
  element that is getting kicked out and the initial &quot;state&quot;.  (Behind
  the scenes, this &quot;state&quot; isn&#39;t really state, but it is helpful to
  think of it as state.)
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(&lt;span style=&quot;color: #f0dfaf;&quot;&gt;apply&lt;/span&gt; lru-map-with 4 conj [] (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;range&lt;/span&gt; 20))
&lt;span style=&quot;color: #708070;&quot;&gt;;&lt;/span&gt;&lt;span style=&quot;color: #7f9f7f;&quot;&gt;=&amp;gt; {12 13, 14 15, 16 17, 18 19, :lru-state [[0 1] [2 3] [4 5] [6 7] [8 9] [10 11]]}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;
  Again, this little package is on &lt;a href=&quot;https://github.com/chrismgray/least-recently-used-map&quot;&gt;github&lt;/a&gt; and the jar is on &lt;a href=&quot;https://clojars.org/least-recently-used-map&quot;&gt;clojars&lt;/a&gt;.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>


	<comments>/posts/small-clojure-libs/#comments</comments>

</item>
<item>

	<title>Clojure in Elisp</title>


	<guid isPermaLink="false">http://chrismgray.github.com//posts/clojel/</guid>

	<link>http://chrismgray.github.com//posts/clojel/</link>


	<category>clojure</category>

	<category>emacs</category>


	<pubDate>Sat, 03 Dec 2011 17:32:56 -0700</pubDate>
	<dcterms:modified>2011-12-07T18:04:08Z</dcterms:modified>

	<description>&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Probably a bad idea&amp;hellip;&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  File this one in the category of crazy ideas had while running.  I
  was thinking about my new org-mode plugin that I announced &lt;a href=&quot;http://chrismgray.github.com/posts/org-ikiwiki-plugin/&quot;&gt;yesterday&lt;/a&gt;
  and how hard it is to write in Emacs Lisp.  I was wishing that I
  could write it in Clojure instead.  Now, they&#39;re not &lt;b&gt;such&lt;/b&gt;
  different languages &amp;ndash; they both are evolutions of McCarthy&#39;s
  original lisp, but Clojure is a much prettier, less crufty
  language.
&lt;/p&gt;
&lt;p&gt;
  Let&#39;s look at just one construct in both languages: &lt;code&gt;let&lt;/code&gt;.  In both
  languages, this assigns values to variable names locally. In elisp,
  it looks like:
&lt;/p&gt;



&lt;pre class=&quot;src src-elisp&quot;&gt;(&lt;span style=&quot;color: #f0dfaf; font-weight: bold;&quot;&gt;let*&lt;/span&gt; ((foo bar)
       (baz foo)))
&lt;/pre&gt;


&lt;p&gt;
  Instead of calling &lt;code&gt;let&lt;/code&gt; there, I had to call &lt;code&gt;let*&lt;/code&gt;, so that the
  results of the first assignment were known to the second assignment.
  There is also a lot of parentheses there.  (Unparenthesized
  variables become automatically initialized to &lt;code&gt;nil&lt;/code&gt; I believe.  I
  don&#39;t think that&#39;s a great idea.)  Contrast this with Clojure&#39;s
  &lt;code&gt;let&lt;/code&gt;.
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(&lt;span style=&quot;color: #8cd0d3;&quot;&gt;let&lt;/span&gt; [foo bar
      baz foo])
&lt;/pre&gt;


&lt;p&gt;
  To me, that&#39;s much more readable.
&lt;/p&gt;
&lt;p&gt;
  Clojure&#39;s core libraries are also much more readable than most of
  elisp.  It seems to me that elisp was designed in the days where
  computer usage was charged by the letter and has not been updated
  since.  (Don&#39;t get me wrong &amp;ndash; I love Emacs and would rather program
  in elisp than Perl, but it has some warts.)
&lt;/p&gt;

&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Maybe not so crazy&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  Emacs already has a reader that can be used to turn lispy-looking
  things into lispy data structures.  Add some macros on top of that
  and you might be able to produce a &lt;code&gt;def&lt;/code&gt; that&#39;s equivalent to
  Clojure&#39;s.  Since much of Clojure is written in Clojure (and all of
  Clojurescript is), defining the Clojure functions might just be a
  hop, skip, and jump away from that.
&lt;/p&gt;
&lt;p&gt;
  Clojure could intern symbols into emacs (with namespaces prepended)
  and then emacs could use them.  Clojure could also call emacs
  functions directly &amp;ndash; any symbol that isn&#39;t defined in a Clojure
  namespace would be tested to see if it exists in emacs.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Probably pretty crazy after all&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  One of Clojure&#39;s big selling points is its concurrency semantics.
  I don&#39;t follow emacs development very closely, but I don&#39;t think
  emacs is going to support any of that any time soon.  Also, would it
  be possible to compile the new language to elisp bytecode?  How
  would &lt;code&gt;recur&lt;/code&gt; work?
&lt;/p&gt;
&lt;p&gt;
  There are a lot of questions, and here I am working on a plugin for
  a combination of tools that hardly anyone uses.  But everyone has to
  scratch their own itch as they say.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Totally crazy&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;


&lt;p&gt;
  &lt;b&gt;Update:&lt;/b&gt; As I suspected, this idea won&#39;t work: elisp doesn&#39;t have
  reader macros, so the difference in read syntaxes of clojure and
  elisp would be impossible to express to the elisp reader.  Maybe one
  could write a parser in elisp, but that would probably be slow and
  hard to do.  The idea was only attractive when large parts were
  already done.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>


	<comments>/posts/clojel/#comments</comments>

</item>
<item>

	<title>Convex Hulls</title>


	<guid isPermaLink="false">http://chrismgray.github.com//posts/convex-hulls/</guid>

	<link>http://chrismgray.github.com//posts/convex-hulls/</link>


	<category>clojure</category>

	<category>computational-geometry</category>

	<category>convex-hull</category>

	<category>ikiwiki</category>

	<category>lab-notes</category>


	<pubDate>Wed, 30 Nov 2011 11:06:31 -0700</pubDate>
	<dcterms:modified>2011-12-02T22:05:50Z</dcterms:modified>

	<description>
</description>


	<comments>/posts/convex-hulls/#comments</comments>

</item>
<item>

	<title>Lazy Sorting in Clojure</title>


	<guid isPermaLink="false">http://chrismgray.github.com//posts/clojure-sorting/</guid>

	<link>http://chrismgray.github.com//posts/clojure-sorting/</link>


	<category>clojure</category>

	<category>lab-notes</category>

	<category>sort</category>


	<pubDate>Sun, 27 Nov 2011 07:23:34 -0700</pubDate>
	<dcterms:modified>2011-12-01T07:45:44Z</dcterms:modified>

	<description>&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Penance&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  In a job interview last week I said a couple of things related to
  sorting in Clojure that turned out to be incorrect when I checked
  them.  This is my way of making up for them &amp;ndash; if I can make them
  true, then no one will notice.  Though to be fair, I&#39;m sure that I&#39;m
  the only one that thinks that way.
&lt;/p&gt;
&lt;p&gt;
  The first thing I said was that heap-sort is my favorite sorting
  algorithm, but then I declined to implement it, preferring to
  implement merge-sort instead.  I think this is actually pretty
  reasonable in an interview situation &amp;ndash; heap-sort is a conceptually
  more difficult sorting algorithm, so being able to remember it on
  the spot is more difficult.  The second thing I said was that
  Clojure itself uses heap-sort and that given its love affair with
  laziness that it would not be unreasonable to assume that &lt;code&gt;(first   (sort lst))&lt;/code&gt; was a linear-time operation.  I might have read
  something like this on a mailing list or IRC, but it is not
  correct.  Clojure currently uses Java&#39;s &lt;code&gt;sort&lt;/code&gt; function, which is a
  slightly-modified merge-sort.  There is not much point in making
  that algorithm lazy, because getting the first element from the
  sorted list requires \(O(n \log n)\) time anyway.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Heap Sort&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  For those that are not familiar with it, heap-sort is something that
  is usually taught in a second-year undergraduate Computer Science
  class.  So it&#39;s not &lt;b&gt;that&lt;/b&gt; difficult an algorithm, but it does
  require some thinking, and there is some fancy analysis that goes
  into part of it.  For a full discussion, see the &lt;a href=&quot;http://www.amazon.com/gp/product/0262033844/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;tag=hikiandcodi-20&amp;amp;linkCode=as2&amp;amp;camp=217145&amp;amp;creative=399369&amp;amp;creativeASIN=0262033844&quot;&gt;Introduction to Algorithms&lt;/a&gt; book by Cormen, Lieserson, Rivest, and Stein.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-1&quot;&gt;Heap&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-1&quot;&gt;


&lt;p&gt;
   To start with, a &lt;i&gt;heap&lt;/i&gt; is conceptually a tree where values are
   stored at the nodes.  The largest value of all the values stored in
   subtrees is stored at the root and the two descendant trees are
   heaps.  Heaps are usually required to be as close to balanced as
   possible &amp;ndash; if any level of the tree has leaves, they are all
   bunched to the right, and all the rest of the leaves are at the
   next level.
&lt;/p&gt;
&lt;p&gt;
   Such a tree is usually implemented as an array, where the child
   nodes of a node can be obtained by some simple arithmetic on the
   index of the node in the array.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-2&quot;&gt;Building a Heap&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-2&quot;&gt;


&lt;p&gt;
   Given the definition, there is an intuitive algorithm for building
   such a heap on a set of numbers: first find the largest number in
   your set and have it be the root of the heap, then split the rest
   of the numbers in half, and recursively make heaps on those sets.
&lt;/p&gt;
&lt;p&gt;
   Such an algorithm is clearly correct, but it is also clearly
   \(\Theta(n \log n)\).  We can do better with a bottom-up algorithm.
   If we continue imagining the heap as a tree, we start by putting
   the input numbers into the tree willy-nilly.  This clearly does not
   satisfy the heap properties laid out above.  However, some of it
   does satisfy the heap properties &amp;ndash; the leaves of the tree are
   trivially heaps.  If we go up one level from the leaves, we can fix
   the trees rooted there by exchanging the root of the tree with its
   largest child (or not exchanging it if it&#39;s already the largest of
   the three).  Higher levels are a bit more difficult, because if the
   root of a tree is exchanged, then we must make sure to fix the tree
   that it ends up being the root of.  You can imagine the root of a
   tree traveling down the heap until it is larger than both of its
   children.
&lt;/p&gt;
&lt;p&gt;
   The correctness of this algorithm is a bit harder to see and it
   also appears to take \(O(n \log n)\) time.  It does, but there is a
   slightly more sophisticated analysis that shows that it is really
   \(\Theta(n)\).  I won&#39;t go into the analysis, but a hint is that
   most of the values don&#39;t actually travel very far in the tree.  
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-3&quot;&gt;Using a heap to sort&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-3&quot;&gt;


&lt;p&gt;
   With the heap properties in mind, we can easily see how to get the
   largest value of a set of numbers &amp;ndash; just take the top element from
   the heap.  How can we use the heap properties to sort?  Well, we
   want the largest number, then the largest number that remains, then
   the largest number that remains after that, and so on.  So if we
   can take the largest number from the heap and then fix the heap so
   that it retains the heap properties, then we&#39;d be done.
&lt;/p&gt;
&lt;p&gt;
   We just devised a way to fix heaps when building the heap, so we
   use that.  What we do is to take the very last node in the heap
   (which is not necessarily the smallest, but it doesn&#39;t hurt to
   think about it as the smallest) and put that at the top of the
   heap.  The resulting tree is clearly not a heap, but if we call the
   algorithm to fix heaps on the root of the tree, then we end up with
   a heap again.  The node that we put on top of the heap might end up
   traveling all the way to the bottom, so this update takes
   \(\Theta(\log n)\) time.  Thus if we sort the entire input set, we
   have a \(\Theta(n \log n)\) algorithm.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-4&quot;&gt;Advantages&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-4&quot;&gt;


&lt;p&gt;
   That&#39;s the best we can do theoretically, which is great, but the
   Java &lt;code&gt;sort&lt;/code&gt; algorithm is also \(\Theta(n \log n)\), so why is there
   any advantage to using heap-sort?  In a language where laziness is
   embraced (such as Clojure), heap-sort can be made lazy.  That is,
   the next element of the sorted list can be computed only when it is
   needed.  Since the build-heap procedure described above takes
   linear time, getting the first element from the sorted list takes
   \(O(n)\) time.  Each subsequent element then takes \(O(\log n)\)
   time.  Thus, if only a small number of elements from the sorted
   list are needed, then this lazy version of heap-sort is
   theoretically faster than other sorts.
&lt;/p&gt;
&lt;p&gt;
   I can think of situations where this would actually have practical
   advantages.  For example, what if you were writing a search engine
   and wanted to obtain the \(k\) best results?  You could write an
   ad-hoc function that found the best result, removed it and recursed
   \(k - 1\) times.  Or you could just &lt;code&gt;(take k (heap-sort input))&lt;/code&gt;.
   The first would take \(O(kn)\) time, whereas the second would take
   \(O(k \log n + n)\) time.  In many practical situations, \(k\) is
   \(\Omega(\log n)\), which means that the first takes \(\Omega(n
   \log n)\) time, whereas the second takes only \(O(n)\) time.
   Essentially, the first is no better than the second solution with a
   non-lazy sorting algorithm.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-5&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-5&quot;&gt;Disadvantages&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-5&quot;&gt;


&lt;p&gt;
   Heap-sort has some disadvantages compared to other sorts of &lt;code&gt;sort&lt;/code&gt;
   algorithms.  The least theoretically significant is that the
   constants hidden in the big-O notation are higher than other
   sorting algorithms (tuned versions of quicksort can have extremely
   small constants).
&lt;/p&gt;
&lt;p&gt;
   Another disadvantage can be seen when dealing with data sets so
   large that they no longer fit in the computer&#39;s main memory.
   Something like merge-sort can be modified fairly easily so that the
   number I/O operations is minimized.  I haven&#39;t thought about it too
   deeply, but this doesn&#39;t seem quite so easy with heap-sort.
   However, I think that people dealing with such large datasets
   should probably be using specialized libraries anyway, so perhaps
   that isn&#39;t too bad.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Implementation&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  This whole discussion is a bit useless if it only remains at the
  theoretical level.  I have an implementation &lt;a href=&quot;https://github.com/chrismgray/clojure-heap-sort&quot;&gt;in my github repo&lt;/a&gt; that
  implements most of the ideas that are given above.  The code is
  highly optimized so that it is somewhat competitive with the native
  Java implementation.  This makes the code on the HEAD of the
  &lt;code&gt;master&lt;/code&gt; branch somewhat less than readable.  However, the first
  commit to the repository used Clojure vectors and a functional
  style, so if you would like to understand the code, you might start
  there. 
&lt;/p&gt;
&lt;p&gt;
  I (unfortunately) needed to use Java arrays and mutation rather than
  the more functional style that I have gotten used to, but the
  results speak for themselves.  Finding the first few elements of a
  sorted array is significantly faster than the Java version.  Finding
  the entire sorted list is somewhat slower than the Java version, but
  not too much.  This is not surprising for a couple of reasons.
  First, heap-sort tends to have larger constants than other sorting
  methods.  Secondly, this code is one day old.  The Java sort method
  has had years to be optimized.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;


&lt;p&gt;
  It may be dreaming, but I would love to see this idea (if not this
  implementation) put into Clojure proper.  I think the advantages
  from laziness outweigh the small constant slowdown versus using
  Java&#39;s &lt;code&gt;sort&lt;/code&gt;.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>


	<comments>/posts/clojure-sorting/#comments</comments>

</item>
<item>

	<title>Processing</title>


	<guid isPermaLink="false">http://chrismgray.github.com//posts/processing/</guid>

	<link>http://chrismgray.github.com//posts/processing/</link>


	<category>clojure</category>

	<category>lab-notes</category>

	<category>processing</category>

	<category>visibility-polygon</category>


	<pubDate>Tue, 22 Nov 2011 12:29:29 -0700</pubDate>
	<dcterms:modified>2011-12-01T07:45:19Z</dcterms:modified>

	<description>&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Viewing visibility polygons&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I mentioned yesterday that it would be nice to see the output of my
  visibility polygon solution.  To that end, I created an extremely
  simple drawing editor using &lt;a href=&quot;http://processing.org/&quot;&gt;Processing&lt;/a&gt;.  I have to say, I loved it.
&lt;/p&gt;
&lt;p&gt;
  The most important feature to me is the extreme interactivity.  I
  can change functions extremely quickly with my tools &amp;ndash; redefining a
  Clojure function is either one or two keystrokes in emacs, depending
  how I choose to do it &amp;ndash; so I like a graphics environment that
  changes just as quickly.  This is what Processing, and in particular
  &lt;code&gt;clj-processing&lt;/code&gt;, offers.  I was able to define a function that
  draws the various objects (in this case, the polygon, the point
  where the mouse is, and the visibility polygon of the mouse point
  inside the polygon).  If I wanted to make any changes to this
  function &amp;ndash; for example, changing the color of the point where the
  mouse is &amp;ndash; I can simply redefine the function using my emacs tools
  and the change shows up immediately on the drawing.
&lt;/p&gt;
&lt;p&gt;
  I was able to use this to find a couple of minor bugs in my
  visibility-polygon-finding code, but in general, it worked really
  well on the first try.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;Shortcomings&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;


&lt;p&gt;
   There were a couple of things that slightly bothered me about
   &lt;code&gt;clj-processing&lt;/code&gt;.  First, it used quite a lot of CPU just to
   display a simple polygon without too many points.  I am probably
   using it rather naïvely, so it is possible that this is my problem
   and not the problem of &lt;code&gt;clj-processing&lt;/code&gt;.  However, the second
   problem is just that &lt;code&gt;clj-processing&lt;/code&gt; is showing its age.  I think
   it was probably one of the first Clojure libraries out there and
   much of the coding style hasn&#39;t evolved with the Clojure best
   practices that people use.  For example, some of the features do
   not work if you only &lt;code&gt;require&lt;/code&gt; the library &amp;ndash; you must &lt;code&gt;use&lt;/code&gt; it.  I
   try to only &lt;code&gt;require&lt;/code&gt; libraries, to avoid my namespace becoming
   overly populated, so it is frustrating when that doesn&#39;t work.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Going forward&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I need to clean up the code a bit before I can put it up on github,
  but it should be there soon.  It currently needs me to explicitly
  call the function in order to find the visibility polygon.  I would
  really like it to find the visibility polygon of any point where the
  mouse is inside the polygon.  However, determining if a point is
  inside a non-convex polygon tends to be a bit harder than it
  sounds.  You can shoot a ray in one direction from a point, and
  count the number of polygon edges that it crosses &amp;ndash; if it&#39;s even
  you are outside and if it&#39;s odd you are inside &amp;ndash; but what happens
  if the ray crosses a vertex?  There was a good experimental paper on
  this problem at a recent EuroCG.
&lt;/p&gt;
&lt;p&gt;
  So that&#39;s a slightly non-trivial problem.  I also coded an
  implementation of the Voronoi Diagram problem recently.  I should
  add a Processing UI to that as well.  I have a feeling that would be
  the easier task to do next, and I would surely discover some bugs in
  it while I did.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
</description>


	<comments>/posts/processing/#comments</comments>

</item>
<item>

	<title>Visibility Polygons</title>


	<guid isPermaLink="false">http://chrismgray.github.com//posts/visibility-polygon/</guid>

	<link>http://chrismgray.github.com//posts/visibility-polygon/</link>


	<category>clojure</category>

	<category>computational-geometry</category>

	<category>lab-notes</category>

	<category>visibility-polygon</category>


	<pubDate>Mon, 21 Nov 2011 12:44:43 -0700</pubDate>
	<dcterms:modified>2011-12-01T07:45:06Z</dcterms:modified>

	<description>&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Visibility Polygon&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I&#39;ve put up some preliminary code for finding visibility polygons on
  my &lt;a href=&quot;https://github.com/chrismgray/visibility-polygon&quot;&gt;github repo&lt;/a&gt;.  I have only tested it with one polygon, but so far
  things are looking good.  My idea from yesterday of using monads to
  &quot;parse&quot; the polygon seems to be paying off.  Here is the relevant
  code:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(&lt;span style=&quot;color: #f0dfaf; font-weight: bold;&quot;&gt;defn-&lt;/span&gt; &lt;span style=&quot;color: #8cd0d3;&quot;&gt;add-new-pt&lt;/span&gt; [poly]
  (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;fn&lt;/span&gt; [pt stack]
    (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;when&lt;/span&gt; (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;or&lt;/span&gt; (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;empty?&lt;/span&gt; stack) &lt;span style=&quot;color: #708070;&quot;&gt;; &lt;/span&gt;&lt;span style=&quot;color: #7f9f7f;&quot;&gt;First two points are guaranteed to be visible&lt;/span&gt;
              (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;empty?&lt;/span&gt; (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;rest&lt;/span&gt; stack))
              (visible? pt (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; poly) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; stack)))
      [pt (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;rest&lt;/span&gt; poly) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;cons&lt;/span&gt; (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; poly) stack)])))

(&lt;span style=&quot;color: #f0dfaf; font-weight: bold;&quot;&gt;defn-&lt;/span&gt; &lt;span style=&quot;color: #8cd0d3;&quot;&gt;pop-stack&lt;/span&gt; [poly]
  (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;fn&lt;/span&gt; [pt stack]
    (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;let&lt;/span&gt; [the-seg (seg/new-seg pt (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; poly))
          top-seg (seg/new-seg (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; stack) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;second&lt;/span&gt; stack))]
      (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;when&lt;/span&gt; (pt/left-turn? (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;second&lt;/span&gt; stack) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; stack) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; poly))
        (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;if&lt;/span&gt; (seg/intersection-on-seg? the-seg top-seg)
          [pt poly (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;cons&lt;/span&gt; (seg/&lt;span style=&quot;color: #dfdfbf; font-weight: bold;&quot;&gt;intersection&lt;/span&gt; the-seg top-seg) stack)]
          [pt poly (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;rest&lt;/span&gt; stack)])))))

(&lt;span style=&quot;color: #f0dfaf; font-weight: bold;&quot;&gt;defn-&lt;/span&gt; &lt;span style=&quot;color: #8cd0d3;&quot;&gt;skip-pt&lt;/span&gt; [poly]
  (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;fn&lt;/span&gt; [pt stack]
   (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;let&lt;/span&gt; [the-seg (seg/new-seg pt (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; stack))
         poly-seg (seg/new-seg (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; poly) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;second&lt;/span&gt; poly))]
     (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;when&lt;/span&gt; (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;not&lt;/span&gt; (pt/left-turn? (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;second&lt;/span&gt; stack) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; stack) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; poly)))
       (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;if&lt;/span&gt; (seg/intersection-on-seg? the-seg poly-seg)
         [pt (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;cons&lt;/span&gt; (seg/&lt;span style=&quot;color: #dfdfbf; font-weight: bold;&quot;&gt;intersection&lt;/span&gt; the-seg poly-seg) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;rest&lt;/span&gt; poly)) stack]
         [pt (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;rest&lt;/span&gt; poly) stack])))))

(&lt;span style=&quot;color: #f0dfaf; font-weight: bold;&quot;&gt;defn-&lt;/span&gt; &lt;span style=&quot;color: #8cd0d3;&quot;&gt;all-conditions&lt;/span&gt; [poly]
  (with-monad polygon-parser-m
    (m-plus (add-new-pt poly) (pop-stack poly) (skip-pt poly))))
&lt;/pre&gt;


&lt;p&gt;
  This defines three actions to be performed when the polygon and
  stack are in certain configurations.  The first executes when the
  next point on the polygon doesn&#39;t obscure any of the stack.  In that
  case, it removes the point from &lt;code&gt;poly&lt;/code&gt; and puts it on &lt;code&gt;stack&lt;/code&gt;.  The
  second executes by popping points off the stack until the next point
  on the polygon no longer obscures the stack.  The final condition
  activates when the next point on the polygon is hidden by the
  stack.  It skips the points of &lt;code&gt;poly&lt;/code&gt; until it finds one that would
  be visible.  We combine the three conditions using &lt;code&gt;m-plus&lt;/code&gt;, which
  is defined to try the conditions in order until one returns
  something that is not &lt;code&gt;nil&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  Is this solution any better than a functional programming solution
  without monads?  I think it is.  First, the conditions are easy to
  see and very explicitly laid out.  Using a &lt;code&gt;cond&lt;/code&gt; to accomplish the
  same thing is certainly possible, but gets more complicated as the
  number of conditions grows.  Also, we are explicitly managing state
  in this solution.  Doing so in an ad-hoc manner would be much more
  difficult.  In fact, I am not really sure how I would loop until
  there are no more points in &lt;code&gt;poly&lt;/code&gt; in a solution without monads
  (especially since not all the conditions consume a point from
  &lt;code&gt;poly&lt;/code&gt;).  With monads, it is quite simple:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(&lt;span style=&quot;color: #f0dfaf; font-weight: bold;&quot;&gt;defn-&lt;/span&gt; &lt;span style=&quot;color: #8cd0d3;&quot;&gt;visibility-polygon-helper&lt;/span&gt; [pt poly]
  ((with-monad polygon-parser-m
     (m-until empty? all-conditions poly)) pt []))
&lt;/pre&gt;


&lt;p&gt;
  Doing something like that with a &lt;code&gt;reduce&lt;/code&gt; seems like it would veer
  off into unreadability fairly quickly.
&lt;/p&gt;
&lt;p&gt;
  Are there downsides to this solution?  I think there is at least
  one.  That is, the conditions must be functions that return functions.
  This makes them a bit more confusing than they really should be.  I
  needed to do this so that I could have a test in the &lt;code&gt;m-until&lt;/code&gt;
  function above.  On the whole, though, this is a fairly cosmetic
  gripe, and can be hidden by using helper functions like the one
  above.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;On the horizon&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I would like to test the code quite a bit more.  However, doing so
  by drawing out polygons by hand and then figuring out their
  visibility polygons is quite tedious.  Therefore, I need some sort
  of GUI to be able to draw polygons and then I will be able to
  see whether the computed visibility polygon makes sense.
&lt;/p&gt;
&lt;p&gt;
  I am thinking that it might be nice to use the &lt;a href=&quot;https://github.com/rosado/clj-processing&quot;&gt;&lt;code&gt;clj-processing&lt;/code&gt; library&lt;/a&gt; to do this.  Unfortunately, that library is currently only
  using Clojure 1.2.  Since I am using Clojure 1.3, that might be a
  problem.  So I might need to do some porting from 1.2 to 1.3.
  However, doing so should give me a good idea of how processing
  works, and could give a nice tool for more interactive geometry
  programs. 
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>


	<comments>/posts/visibility-polygon/#comments</comments>

</item>
<item>

	<title>The Luhnybin Challenge</title>


	<guid isPermaLink="false">http://chrismgray.github.com//posts/luhnybin/</guid>

	<link>http://chrismgray.github.com//posts/luhnybin/</link>


	<category>clojure</category>

	<category>programming-challenge</category>

	<category>thrush</category>


	<pubDate>Tue, 15 Nov 2011 13:22:19 -0700</pubDate>
	<dcterms:modified>2011-12-01T07:44:18Z</dcterms:modified>

	<description>&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Another programming challenge&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I woke up with another programming challenge in my inbox this
  morning.  This one is from &lt;a href=&quot;http://squareup.com&quot;&gt;Square&lt;/a&gt;.  They are a company that gives
  you a little device so that you can accept credit cards using a
  smart phone.  The challenge is &lt;a href=&quot;http://corner.squareup.com/2011/11/luhny-bin.html&quot;&gt;here&lt;/a&gt; &amp;ndash; basically it&#39;s about removing
  credit cards numbers from logs.  There are some details about what
  constitutes a credit card number, and how they are distinct from
  other numbers.  I won&#39;t repeat that here, but you should read it to
  understand what&#39;s coming up.
&lt;/p&gt;
&lt;p&gt;
  As usual, I implemented my solution in Clojure.  I particularly
  liked the function I called &lt;code&gt;luhn-check&lt;/code&gt;.  Here it is:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(&lt;span style=&quot;color: #f0dfaf; font-weight: bold;&quot;&gt;defn&lt;/span&gt; &lt;span style=&quot;color: #8cd0d3;&quot;&gt;luhn-check&lt;/span&gt;
  &lt;span style=&quot;color: #8fb28f;&quot;&gt;&quot;Takes a sequence of digits and determines whether they pass the Luhn test.&lt;/span&gt;
&lt;span style=&quot;color: #8fb28f;&quot;&gt;   The sequence must be in order from right to left.&quot;&lt;/span&gt;
  [digits]
  (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;-&amp;gt;&amp;gt;&lt;/span&gt; digits
       (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;partition&lt;/span&gt; 2 2 (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;repeat&lt;/span&gt; 0))
       (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;mapcat&lt;/span&gt; #(&lt;span style=&quot;color: #f0dfaf;&quot;&gt;vector&lt;/span&gt; (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;first&lt;/span&gt; %) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;*&lt;/span&gt; 2 (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;second&lt;/span&gt; %))))
       (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;reduce&lt;/span&gt; #(&lt;span style=&quot;color: #f0dfaf;&quot;&gt;+&lt;/span&gt; %1 (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;int&lt;/span&gt; (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;/&lt;/span&gt; %2 10)) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;int&lt;/span&gt; (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;mod&lt;/span&gt; %2 10))))
       (#(&lt;span style=&quot;color: #f0dfaf;&quot;&gt;mod&lt;/span&gt; % 10))
       (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;=&lt;/span&gt; 0)))
&lt;/pre&gt;


&lt;p&gt;
  I think this is a good illustration of the &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; operator in
  Clojure, which is also called the &quot;thrush&quot; operator.  Basically,
  this operator can be thought of as taking the result from one
  expression and putting it at the end of the next expression.
&lt;/p&gt;
&lt;p&gt;
  In this case, we start out with a list of digits.  We then partition
  them into pairs, padding with a zero if necessary.  We then take the
  pairs and double the second number in the pair, concatenating all
  the pairs back into a single list.  We then sum up all the digits in
  the list, using the &lt;code&gt;reduce&lt;/code&gt; function.  This leaves us with a
  number.  We get its value \(\mod 10\) and test whether it is equal
  to zero.  If it is, we return &lt;code&gt;true&lt;/code&gt;, otherwise we return &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  All of this could be written with nested expressions (and the thrush
  operator is simply a macro that rewrites what you see as nested
  expressions), but I think the way it is written nicely shows what
  the data is doing in the function.
&lt;/p&gt;
&lt;p&gt;
  Anyway, I don&#39;t know if this solution will get me a job, but it was
  a bit of fun coding and didn&#39;t take too long.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>


	<comments>/posts/luhnybin/#comments</comments>

</item>
<item>

	<title>Scattered</title>


	<guid isPermaLink="false">http://chrismgray.github.com//posts/scattered/</guid>

	<link>http://chrismgray.github.com//posts/scattered/</link>


	<category>clojure</category>

	<category>clojurescript</category>

	<category>email</category>

	<category>git</category>

	<category>git-annex</category>

	<category>notmuch</category>

	<category>spot</category>


	<pubDate>Mon, 14 Nov 2011 10:11:23 -0700</pubDate>
	<dcterms:modified>2011-12-01T07:43:31Z</dcterms:modified>

	<description>&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Scattered&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I am doing a bunch of things today, all fairly small.  I think it&#39;s
  because I finished working on the time series framework yesterday,
  so I&#39;m kind of at loose ends.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;New programming project&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  One thing that I would like to do is to take all the messages that I
  sent with my &lt;a href=&quot;http://findmespot.com&quot;&gt;SPOT&lt;/a&gt; device while hiking and make a small animation of
  them on Google Maps.  This would be another use of Clojurescript.
  My previous project &amp;ndash; a Clojurescript program for computing the
  Voronoi Diagram of a set of points input by a user &amp;ndash; is a bit
  stalled at the moment, so it&#39;s good to have something else to work
  on.  Also, I feel like adding points to a Google Map is something
  that Clojurescript is better suited to, rather than the fiddly
  numeric stuff that I was trying to make it do.  I will come back to
  the Voronoi Diagram at some point (hopefully fairly soon), but I am
  putting it on the back burner for the moment.
&lt;/p&gt;
&lt;p&gt;
  So far, I see two major tasks:
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-1&quot;&gt;Getting the coordinates and times of the SPOT messages&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-1&quot;&gt;


&lt;p&gt;
   Every SPOT message is an email that contains the coordinates of
   where and when the message was sent.  Parsing the email can be done
   offline, so I will probably just use Clojure for that.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-2&quot;&gt;Putting them on the Google Map&lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-2&quot;&gt;


&lt;p&gt;
   The &lt;a href=&quot;http://code.google.com/apis/maps/documentation/javascript/overlays.html#Markers&quot;&gt;API&lt;/a&gt; for using Google Maps appears to be easy to use and
   well-thought-out.  There&#39;s even a way to drop the markers at
   different intervals &amp;ndash; just what I want to do.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Notmuch&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  I am also playing with the &lt;a href=&quot;http://notmuch.org&quot;&gt;notmuch&lt;/a&gt; email client.  So far I quite
  like it.  It&#39;s a heck of a lot faster than my previous mail client,
  mainly because it doesn&#39;t do as much.  Like gmail, it is optimized
  towards two operations: searching and tagging.  I never really used
  tags in gmail, because doing so involves clicking around, but it&#39;s
  much faster in notmuch.  So far, this seems like the big advantage
  for notmuch.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Git annex&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;


&lt;p&gt;
  In an effort to use all the software written by &lt;a href=&quot;http://joey.kitenet.net/&quot;&gt;Joey Hess&lt;/a&gt; (not
  really, but it seems like it), I am also trying out &lt;a href=&quot;http://git-annex.branchable.com/&quot;&gt;git annex&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
  So far, I have come up with one really compelling use case --
  syncing podcasts to my mp3 player.  My mp3 player has the problem
  that it will delete all the files on it at random times.  Thus, I
  need to keep a backup of all the files on it on my computer.
  However, when I am done listening to a podcast, I like to remove the
  file.  Hopefully, I will be able to sync the files that I remove
  myself (that is, remove them from the laptop), but not the files
  that get removed by the stupid thing crashing.
&lt;/p&gt;
&lt;p&gt;
  Another thing that I would like to do is put my music and video
  collections in git annex.  I&#39;m not sure that anything special would
  come from doing that, but it seems nice to have these things in
  version control.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>


	<comments>/posts/scattered/#comments</comments>

</item>
<item>

	<title>Time Series 2</title>


	<guid isPermaLink="false">http://chrismgray.github.com//posts/time-series-2/</guid>

	<link>http://chrismgray.github.com//posts/time-series-2/</link>


	<category>clojure</category>

	<category>programming-challenge</category>

	<category>time-series</category>


	<pubDate>Sun, 13 Nov 2011 07:12:16 -0700</pubDate>
	<dcterms:modified>2011-12-15T18:14:05Z</dcterms:modified>

	<description>&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;What we have so far&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  Well, yesterday was either a very productive day or a very lucky day
  for me.  I read up on monads &amp;ndash; I found that &lt;a href=&quot;http://onclojure.com/2009/03/05/a-monad-tutorial-for-clojure-programmers-part-1/&quot;&gt;khinsen&#39;s tutorials&lt;/a&gt; and
  &lt;a href=&quot;http://intensivesystems.s3-website-us-east-1.amazonaws.com/tutorials/monads_101.html&quot;&gt;Jim Duey&#39;s tutorials&lt;/a&gt; complemented each other nicely.  Then I went
  for a long run (about 18 miles I think) and let the ideas sink in.
  When I got home, I found &lt;code&gt;state-m&lt;/code&gt; and &lt;code&gt;m-seq&lt;/code&gt; and the job was
  almost done.
&lt;/p&gt;
&lt;p&gt;
  Just as a reminder, &lt;a href=&quot;http://chrismgray.github.com/posts/time-series-1&quot;&gt;yesterday&#39;s task&lt;/a&gt; was to build a time-series
  framework where a function \(f\) accepts the previous \(n\) outputs of
  \(f\) as input to generate a new output.  Here is my solution, edited
  for clarity (the actual solution is in a &lt;a href=&quot;http://github.com/chrismgray/time-series&quot;&gt;github repository&lt;/a&gt;):
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(&lt;span style=&quot;color: #f0dfaf; font-weight: bold;&quot;&gt;defn&lt;/span&gt; &lt;span style=&quot;color: #8cd0d3;&quot;&gt;time-series&lt;/span&gt; [f init-state n num-iterations]
 (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;let&lt;/span&gt; [call-f (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;fn&lt;/span&gt; [state]
                (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;let&lt;/span&gt; [retval (f state)
                      num (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;count&lt;/span&gt; state)
                      new-state (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;vec&lt;/span&gt; (&lt;span style=&quot;color: #8cd0d3;&quot;&gt;if&lt;/span&gt; (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;=&lt;/span&gt; num n) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;drop&lt;/span&gt; 1 (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;conj&lt;/span&gt; state retval)) (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;conj&lt;/span&gt; state retval)))]
                  [retval new-state]))]
   ((with-monad state-m
      (m-seq (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;repeat&lt;/span&gt; num-iterations call-f)))
    (&lt;span style=&quot;color: #f0dfaf;&quot;&gt;vector&lt;/span&gt; init-state))))
&lt;/pre&gt;


&lt;p&gt;
  As you can see, the heavy lifting is done by the &lt;code&gt;state&lt;/code&gt; monad and
  by &lt;code&gt;m-seq&lt;/code&gt;.  What do they do?  Well, &lt;code&gt;m-seq&lt;/code&gt; can be thought of as
  taking a list of functions and calling them in order, returning a
  list of their return values.  The list of functions in this case is
  the same function (&lt;code&gt;call-f&lt;/code&gt;) over and over.  All &lt;code&gt;call-f&lt;/code&gt; does is
  call \(f\) and change the state.
&lt;/p&gt;
&lt;p&gt;
  It might appear that &lt;code&gt;call-f&lt;/code&gt; is an \(O(n)\) function.  After all, we
  call &lt;code&gt;count&lt;/code&gt; on the state, which is a vector of at most \(n\)
  elements.  However, almost all the behind-the-scenes data structures
  that Clojure uses (including the vector data structure) are
  guaranteed to have \(O(1)\) performance for calling &lt;code&gt;count&lt;/code&gt;.  So
  that&#39;s nice, and &lt;code&gt;call-f&lt;/code&gt; has the performance characteristics that I
  desired.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Monads&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  They&#39;re still a slightly confusing and magical-seeming thing to me,
  but monads have some obvious utility.  I guess the way to think
  about them is that if you put your input and output in a common
  format, then they aid you in stringing functions together very
  easily.  I used them in this case to encapsulate state, and that is
  probably the most common use of them in Clojure (judging by the
  number of state functions in the Clojure monads library).  However,
  I think I should probably try to understand all the monads in the
  library and know how to combine them.
&lt;/p&gt;
&lt;p&gt;
  I could have written the function above without monads, but the code
  would not have been nearly as concise, and there probably would have
  been many more edge-cases to consider.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;The rest&lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  I also wrote some stuff to make debugging easier, and used incanter
  to compare multiple time series.  However, neither required me to
  bend my brain as much as monads, so I won&#39;t talk about them very
  much.  In fact, not at all, because that is the end of my post.
&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>


	<comments>/posts/time-series-2/#comments</comments>

</item>

</channel>
</rss>
