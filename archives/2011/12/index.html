<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>12</title>

<link rel="stylesheet" href="../../../style.css" type="text/css" />

<link rel="stylesheet" href="../../../local.css" type="text/css" />





<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>

<div class="page">

<div class="pageheader">
<div class="header">
<span>
<span class="parentlinks">

<a href="../../../">Hiking and Coding</a>/ 

<a href="../../">archives</a>/ 

<a href="../">2011</a>/ 

</span>
<span class="title">
12

</span>
</span>

</div>


<div class="actions">
<ul>


<li><a href="../../../recentchanges/">RecentChanges</a></li>






<li>

<a href="">Comment</a>

</li>

</ul>
</div>




</div>


<div class="sidebar">
<div><div class="calendar"><table class="month-calendar">
    <tr>
    <th class="month-calendar-arrow"><a href="../11/" title="November">&larr;</a></th>
    <th class="month-calendar-head" colspan="5"><span class="selflink">Dec 2011</span></th>
    <th class="month-calendar-arrow"></th>
    </tr>
    <tr>
        <th class="month-calendar-day-head Sunday" title="Sunday">S</th>
        <th class="month-calendar-day-head Monday" title="Monday">M</th>
        <th class="month-calendar-day-head Tuesday" title="Tuesday">T</th>
        <th class="month-calendar-day-head Wednesday" title="Wednesday">W</th>
        <th class="month-calendar-day-head Thursday" title="Thursday">T</th>
        <th class="month-calendar-day-head Friday" title="Friday">F</th>
        <th class="month-calendar-day-head Saturday" title="Saturday">S</th>
    </tr>
    <tr>
        <td class="month-calendar-day-noday Sunday">&nbsp;</td>
        <td class="month-calendar-day-noday Monday">&nbsp;</td>
        <td class="month-calendar-day-noday Tuesday">&nbsp;</td>
        <td class="month-calendar-day-noday Wednesday">&nbsp;</td>
        <td class="month-calendar-day-nolink Thursday">1</td>
        <td class="month-calendar-day-link Friday"><a href="../../../posts/org-ikiwiki-plugin/" title="org-ikiwiki-plugin">2</a></td>
        <td class="month-calendar-day-link Saturday"><a href="../../../posts/clojel/" title="clojel">3</a></td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">4</td>
        <td class="month-calendar-day-nolink Monday">5</td>
        <td class="month-calendar-day-link Tuesday"><a href="../../../posts/org-ikiwiki-plugin-2/" title="org-ikiwiki-plugin-2">6</a></td>
        <td class="month-calendar-day-link Wednesday"><a href="../../../posts/org-ikiwiki-plugin-3/" title="org-ikiwiki-plugin-3">7</a></td>
        <td class="month-calendar-day-nolink Thursday">8</td>
        <td class="month-calendar-day-nolink Friday">9</td>
        <td class="month-calendar-day-nolink Saturday">10</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">11</td>
        <td class="month-calendar-day-this-day Monday"><a href="../../../posts/anything-git-annex/" title="anything-git-annex">12</a></td>
        <td class="month-calendar-day-future Tuesday">13</td>
        <td class="month-calendar-day-nolink Wednesday">14</td>
        <td class="month-calendar-day-nolink Thursday">15</td>
        <td class="month-calendar-day-nolink Friday">16</td>
        <td class="month-calendar-day-nolink Saturday">17</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">18</td>
        <td class="month-calendar-day-nolink Monday">19</td>
        <td class="month-calendar-day-nolink Tuesday">20</td>
        <td class="month-calendar-day-nolink Wednesday">21</td>
        <td class="month-calendar-day-nolink Thursday">22</td>
        <td class="month-calendar-day-nolink Friday">23</td>
        <td class="month-calendar-day-nolink Saturday">24</td>
    </tr>
    <tr>
        <td class="month-calendar-day-nolink Sunday">25</td>
        <td class="month-calendar-day-nolink Monday">26</td>
        <td class="month-calendar-day-nolink Tuesday">27</td>
        <td class="month-calendar-day-nolink Wednesday">28</td>
        <td class="month-calendar-day-nolink Thursday">29</td>
        <td class="month-calendar-day-nolink Friday">30</td>
        <td class="month-calendar-day-nolink Saturday">31</td>
    </tr>
</table>
</div></div>

</div>


<div id="pagebody">

<div id="content">
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="../../../posts/org-ikiwiki-plugin/">Plugin for org files in ikiwiki</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">A new plugin </h2>
<div class="outline-text-2" id="text-1">


<p>
  Ikiwiki users who want to write org-mode files have long only had
  one plugin for ikiwiki to convert their files to html.  That plugin
  is good as it goes, but it is somewhat limited.  Thus, I am happy to
  announce a new plugin for converting org-mode.  It is located in my
  <a href="https://github.com/chrismgray/ikiwiki-org-plugin">github repository</a>.
</p>
<p>
  It is still a bit rough around the edges, but it should be
  completely usable very soon.
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Fri 02 Dec 2011 04:29:47 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="../../../tags/emacs/" rel="tag">emacs</a>

<a href="../../../tags/ikiwiki/" rel="tag">ikiwiki</a>

<a href="../../../tags/ikiwiki-org-plugin/" rel="tag">ikiwiki-org-plugin</a>

<a href="../../../tags/org-mode/" rel="tag">org-mode</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="../../../posts/clojel/">Clojure in Elisp</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Probably a bad idea&hellip; </h2>
<div class="outline-text-2" id="text-1">


<p>
  File this one in the category of crazy ideas had while running.  I
  was thinking about my new org-mode plugin that I announced <a href="http://chrismgray.github.com/posts/org-ikiwiki-plugin/">yesterday</a>
  and how hard it is to write in Emacs Lisp.  I was wishing that I
  could write it in Clojure instead.  Now, they're not <b>such</b>
  different languages &ndash; they both are evolutions of McCarthy's
  original lisp, but Clojure is a much prettier, less crufty
  language.
</p>
<p>
  Let's look at just one construct in both languages: <code>let</code>.  In both
  languages, this assigns values to variable names locally. In elisp,
  it looks like:
</p>



<pre class="src src-elisp">(<span style="color: #f0dfaf; font-weight: bold;">let*</span> ((foo bar)
       (baz foo)))
</pre>




<p>
  Instead of calling <code>let</code> there, I had to call <code>let*</code>, so that the
  results of the first assignment were known to the second assignment.
  There is also a lot of parentheses there.  (Unparenthesized
  variables become automatically initialized to <code>nil</code> I believe.  I
  don't think that's a great idea.)  Contrast this with Clojure's
  <code>let</code>.
</p>



<pre class="src src-clojure">(<span style="color: #8cd0d3;">let</span> [foo bar
      baz foo])
</pre>




<p>
  To me, that's much more readable.
</p>
<p>
  Clojure's core libraries are also much more readable than most of
  elisp.  It seems to me that elisp was designed in the days where
  computer usage was charged by the letter and has not been updated
  since.  (Don't get me wrong &ndash; I love Emacs and would rather program
  in elisp than Perl, but it has some warts.)
</p>

</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Maybe not so crazy </h2>
<div class="outline-text-2" id="text-2">


<p>
  Emacs already has a reader that can be used to turn lispy-looking
  things into lispy data structures.  Add some macros on top of that
  and you might be able to produce a <code>def</code> that's equivalent to
  Clojure's.  Since much of Clojure is written in Clojure (and all of
  Clojurescript is), defining the Clojure functions might just be a
  hop, skip, and jump away from that.
</p>
<p>
  Clojure could intern symbols into emacs (with namespaces prepended)
  and then emacs could use them.  Clojure could also call emacs
  functions directly &ndash; any symbol that isn't defined in a Clojure
  namespace would be tested to see if it exists in emacs.
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Probably pretty crazy after all </h2>
<div class="outline-text-2" id="text-3">


<p>
  One of Clojure's big selling points is its concurrency semantics.
  I don't follow emacs development very closely, but I don't think
  emacs is going to support any of that any time soon.  Also, would it
  be possible to compile the new language to elisp bytecode?  How
  would <code>recur</code> work?
</p>
<p>
  There are a lot of questions, and here I am working on a plugin for
  a combination of tools that hardly anyone uses.  But everyone has to
  scratch their own itch as they say.
</p>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Totally crazy </h2>
<div class="outline-text-2" id="text-4">


<p>
  <b>Update:</b> As I suspected, this idea won't work: elisp doesn't have
  reader macros, so the difference in read syntaxes of clojure and
  elisp would be impossible to express to the elisp reader.  Maybe one
  could write a parser in elisp, but that would probably be slow and
  hard to do.  The idea was only attractive when large parts were
  already done.
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Sat 03 Dec 2011 05:32:56 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="../../../tags/clojure/" rel="tag">clojure</a>

<a href="../../../tags/emacs/" rel="tag">emacs</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="../../../posts/org-ikiwiki-plugin-2/">Updates on the ikiwiki plugin</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Progress </h2>
<div class="outline-text-2" id="text-1">


<p>  
  Progress on the <a href="./../../../posts/org-ikiwiki-plugin">plugin</a> is proceeding apace.  In fact, the link in the
  last sentence is a major milestone &ndash; for the first time, I can use
  what ikiwiki calls <a href="http://ikiwiki.info/ikiwiki/wikilink/">wikilinks</a>.  What would happen previously is that
  ikiwiki would stick some raw HTML into an org file when it thought
  it saw a wikilink.  Org wouldn't know what to do with this, and
  would escape the HTML so that it would show up in the browser.  This
  is the reason that I couldn't include images in the posts &ndash; they
  would get interpreted as wikilinks and then org would choke on the
  resulting HTML.
</p>
<p>
  I'm not sure that inserting local picture files works yet, but
  inserting pictures from other servers works okay.  For example, here
  is a picture of me standing at the US/Mexico border:
  <img src="https://lh5.googleusercontent.com/-JiFi6diO5zM/Tgziytt-fwI/AAAAAAAACDc/dQXeYi-7odI/s144/DSCF0494.JPG"  alt="https://lh5.googleusercontent.com/-JiFi6diO5zM/Tgziytt-fwI/AAAAAAAACDc/dQXeYi-7odI/s144/DSCF0494.JPG" />
  and here is me after hiking to the US/Canada border:
  <img src="https://lh3.googleusercontent.com/-j-b_h7_SSlo/TnyPfTGVCyI/AAAAAAAADWA/cFvVuP1QvB8/s144/DSCF0597.JPG"  alt="https://lh3.googleusercontent.com/-j-b_h7_SSlo/TnyPfTGVCyI/AAAAAAAADWA/cFvVuP1QvB8/s144/DSCF0597.JPG" />
</p>
<p>
  I think I have ironed out most of the kinks that caused things to
  hang previously when updating the site, but more testing is
  certainly needed.  Things that remain on my todo list include
  figuring out why it doesn't work when the emacs doing the compiling
  is daemonized, and testing whether locally hosted pictures work.
</p>
<p>
  Any feedback would be appreciated!
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Tue 06 Dec 2011 02:55:28 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="../../../tags/emacs/" rel="tag">emacs</a>

<a href="../../../tags/ikiwiki-org-plugin/" rel="tag">ikiwiki-org-plugin</a>

<a href="../../../tags/org-mode/" rel="tag">org-mode</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="../../../posts/org-ikiwiki-plugin-3/">Lessons learned (so far) from the ikiwiki plugin</a>

</span>
</div>

<div class="inlinecontent">

<p>Writing my <a href="./../../../posts/org-ikiwiki-plugin">new plugin</a> in Emacs Lisp, I learned a few things.  Here are
some of them, in no particular order.
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">xml-rpc.el has some problems </h2>
<div class="outline-text-2" id="text-1">


<p>
  I don't mean to be unkind here.  xml-rpc.el seems pretty good if you
  are doing exactly one kind of thing: calling a method on a server
  that can be reached by http.  For anything else, it is very hard to
  use.   My plugin has the following requirements:
</p>
<ul>
<li>It must be called by another program through xml-rpc.
</li>
<li>It must read from and write to files (and not http).
</li>
</ul>


<p>    
  Neither of these things is made easy with xml-rpc.  The first I can
  understand &ndash; xml-rpc would have to somehow insinuate itself into
  the emacs event loop and watch for calls all the time.  The second
  is less easy to understand.  Parsing xml-rpc is not really related
  to reading from http.  So why are the two things tied together?  In
  my opinion, xml-rpc.el would be a much nicer library if parsing the
  xml-rpc was separated completely from the http stuff.  There could
  be convenience functions, but they would be a layer of abstraction
  on top of the other two layers.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">xml.el has some problems </h2>
<div class="outline-text-2" id="text-2">


<p>
  There isn't a function to get a list of all nodes with a given name?
  Are you kidding me?  Here is my implementation, but I bet there is a
  better one somewhere:
</p>



<pre class="src src-elisp">(<span style="color: #f0dfaf; font-weight: bold;">defun</span> <span style="color: #8cd0d3;">xml-find-nodes-matching</span> (node name)
  <span style="color: #8fb28f;">"Returns all children of `</span><span style="color: #dca3a3; font-weight: bold;">node</span><span style="color: #8fb28f;">' that have an `</span><span style="color: #dca3a3; font-weight: bold;">xml-node-name</span><span style="color: #8fb28f;">' equal to `</span><span style="color: #dca3a3; font-weight: bold;">name</span><span style="color: #8fb28f;">'."</span>
  (<span style="color: #f0dfaf; font-weight: bold;">if</span> (or (eq node '()) (not (listp node)))
      '()
    (<span style="color: #f0dfaf; font-weight: bold;">if</span> (equal (xml-node-name node) name)
        (cons node (delq nil (mapcar (<span style="color: #f0dfaf; font-weight: bold;">lambda</span> (nd) (xml-find-nodes-matching nd name)) (xml-node-children node))))
      (delq nil (apply 'append (mapcar (<span style="color: #f0dfaf; font-weight: bold;">lambda</span> (nd) (xml-find-nodes-matching nd name)) (xml-node-children node)))))))
</pre>




<p>
  In general, both xml-rpc.el and xml.el use a distressing number of
  calls to <code>car</code>, <code>cdr</code>, and <code>cdaddr</code> (and all the versions in
  between).  
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Perl has some problems </h2>
<div class="outline-text-2" id="text-3">


<p>
  Ikiwiki sends named parameters as an even-lengthed xml-rpc array
  rather than as an xml-rpc struct.  This is because not all of the
  functions that can be called via xml-rpc take named parameters and I
  guess Perl isn't smart enough to tell a hash from an even-lengthed
  array.  This isn't a huge problem, but it does mean that I need to
  convert the input to each of the functions that I write into a hash
  before I use it.
</p>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Ikiwiki has some problems </h2>
<div class="outline-text-2" id="text-4">


<p>
  I would like to be able to ignore files that don't have a particular
  extension.  For <code>htmlify</code>, this is the way it works by default.  It
  seems like most of the functions that plugins can implement are not
  this way by default, though, and that is a shame.  If the plugin is
  not external &ndash; that is, it is written in Perl &ndash; there is really no
  problem.  The function is called, checks the extension of the source
  file, and returns without doing anything.  However, when the plugin
  is external and the call must happen through xml-rpc, ikiwiki must
  transmit the data via xml-rpc and receive the returned data back via
  xml-rpc.  Unnecessary calls take a lot longer in that context.
</p>
<p>
  So I would like for most calls to <code>hook</code> to take an optional
  <code>extension</code> parameter that takes an extension (or even better, a
  regexp), and only call the function if the file name has the same
  extension (or matches the regexp).
</p>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">Working with emacs buffers is pretty nice </h2>
<div class="outline-text-2" id="text-5">


<p>
  Does a function that you're trying to write in emacs lisp give you a
  string?  It's pretty easy to throw it in a temporary buffer and then
  tell emacs to do the things that you would normally do while you
  were editing in order to get the proper information out of the
  string.  The <code>with-temporary-buffer</code> macro makes it especially easy
  to do just that.
</p>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">Getting info from a structured list is easier to do as a recursive function </h2>
<div class="outline-text-2" id="text-6">


<p>
  One of the things that took me the longest was to figure out what
  this couple of lines of code was doing:
</p>



<pre class="src src-elisp">(setq valtype (car (caddar xml-list))
      valvalue (caddr (caddar xml-list)))  
</pre>




<p>
  What should the value of <code>xml-list</code> look like in order to get the
  correct thing out of it?  It turned out that I needed to take the
  <code>cdr</code> of the <code>cdaddr</code> of the <code>caddar</code> of the parsed xml in order to
  get the correct value.  That only worked when ikiwiki was responding
  to a method call, though.  I had a much easier time getting the
  right values out when I simply started using the
  <code>xml-find-nodes-matching</code> function that I showed above.
</p>
<p>
  When you see yourself writing more than a few <code>car</code> or <code>cdr</code> calls
  in a row (or <code>first</code>, <code>rest</code>, or <code>nth</code> calls in Clojure), stop and
  try to write a function that finds what you are looking for.  The
  function doesn't have to be recursive, but that might be the easiest
  way to do it.
</p>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">It's nice when all calls and responses are dumped to a file </h2>
<div class="outline-text-2" id="text-7">


<p>
  In a sense, this is just saying that code can be easier to debug if
  you're tracing it.  But since the calls between ikiwiki and the
  plugin must go through files anyway, we get the program traced
  automatically.
</p>

</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Wed 07 Dec 2011 03:00:36 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="../../../tags/emacs/" rel="tag">emacs</a>

<a href="../../../tags/ikiwiki/" rel="tag">ikiwiki</a>

<a href="../../../tags/ikiwiki-org-plugin/" rel="tag">ikiwiki-org-plugin</a>

<a href="../../../tags/lab-notes/" rel="tag">lab-notes</a>

<a href="../../../tags/org-mode/" rel="tag">org-mode</a>

</span>








</div>

</div>
<div class="inlinepage">

<div class="inlineheader">

<span class="header">

<a href="../../../posts/anything-git-annex/">Git Annex in Anything</a>

</span>
</div>

<div class="inlinecontent">
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">More fun with emacs </h2>
<div class="outline-text-2" id="text-1">


<p>
  Lately, I've been playing around with <a href="http://www.emacswiki.org/emacs/Anything">anything.el</a>, which has been
  described as "Quicksilver for emacs".  I've played around with it
  before, but have had a hard time changing my habits so that it's the
  first thing I think of doing when changing buffers or finding
  files.  The main reason, I think, is that <a href="http://www.emacswiki.org/emacs/IswitchBuffers">iswitch</a> is usually just as
  fast.
</p>
<p>
  However, I have started using <a href="./../../../posts/git-annex">git annex</a> to store my music and
  videos, and that has added some complexity to the way that I deal
  with them.  My usual flow is to do a <code>git annex find</code> to see what
  files I have on my laptop, after which I play one of them with
  <code>smplayer</code>.  When I am done with the file, I either use <code>git annex   drop</code> or <code>git annex move</code> to get rid of the file from my laptop.
</p>
<p>
  All of that takes a lot of typing in the shell, so I wondered
  whether I could speed it up using <code>anything</code>.  If you guessed that I
  could (given that I am writing this article), give yourself a gold
  star.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">How I did it </h2>
<div class="outline-text-2" id="text-2">


<p>
  <code>anything</code> is highly extensible.  Anyone can define their own setup
  with a command like this:
</p>



<pre class="src src-emacs-lisp">(<span style="color: #f0dfaf; font-weight: bold;">defun</span> <span style="color: #8cd0d3;">my-anything</span> ()
  (interactive)
  (anything-other-buffer
   '(anything-c-source-buffers+
     anything-c-source-recentf
     anything-c-source-files-in-current-dir+
     anything-c-source-git-annex
     anything-c-source-org-headline
     anything-c-source-bookmarks
     anything-c-source-bookmark-set
     anything-c-source-emms-files)
    <span style="color: #cc9393;">"*anything*"</span>))
</pre>




<p>
  which is just a function that tells <code>anything</code> to use a bunch of
  different "sources" as possible interesting things that you might
  want to interact with.  For example, <code>anything-c-source-recentf</code>
  gives a list of files that you recently had open.  That comes with
  the <code>anything</code> package, though, so it's not too interesting from our
  point of view.  What is interesting is
  <code>anything-c-source-git-annex</code>.  It looks like this:
</p>



<pre class="src src-emacs-lisp">(<span style="color: #f0dfaf; font-weight: bold;">defvar</span> <span style="color: #f0dfaf;">anything-c-source-git-annex</span>
  '((name . <span style="color: #cc9393;">"Git Annex"</span>)
    (candidates . (<span style="color: #f0dfaf; font-weight: bold;">lambda</span> ()
                    (<span style="color: #f0dfaf; font-weight: bold;">with-current-buffer</span> anything-current-buffer
                     (<span style="color: #f0dfaf; font-weight: bold;">with-temp-buffer</span>
                       (call-process <span style="color: #cc9393;">"git"</span> nil t nil <span style="color: #cc9393;">"annex"</span> <span style="color: #cc9393;">"find"</span>)
                       (goto-char (point-min))
                       (split-string (buffer-string) <span style="color: #cc9393;">"\n"</span>)))))
    (volatile)
    (action . ((<span style="color: #cc9393;">"Watch"</span> . anything-c-git-annex-play)
               (<span style="color: #cc9393;">"Drop"</span> . anything-c-git-annex-drop)
               (<span style="color: #cc9393;">"Move"</span> . anything-c-git-annex-move)
               (<span style="color: #cc9393;">"Copy"</span> . anything-c-git-annex-copy)))))
</pre>




<p>
  It should hopefully be fairly easy to understand.  There are two
  interesting parts: getting candidate files, and the actions on the
  candidate files.  Getting the candidate files is as simple as
  putting the results of <code>git annex find</code> into a temporary buffer
  (which must be in the same directory as the current buffer) and then
  putting the lines of the buffer into a list.  (This wouldn't work if
  the file names contained newlines, but I don't have any of those.
  If you wanted to be really careful, you could add the "&ndash;print0"
  option to <code>call-process</code> and split the string on "\0".)
</p>
<p>
  The actions are all functions.  The simplest is
  <code>anything-c-git-annex-drop</code>, which just looks like
</p>



<pre class="src src-emacs-lisp">(<span style="color: #f0dfaf; font-weight: bold;">defun</span> <span style="color: #8cd0d3;">anything-c-git-annex-drop</span> (candidate)
  (anything-git-annex-command <span style="color: #cc9393;">"drop"</span> (concat <span style="color: #cc9393;">"\""</span> candidate <span style="color: #cc9393;">"\""</span>)))
</pre>




<p>
  where <code>anything-git-annex-command</code> just starts a shell command.
  More interesting is <code>anything-c-git-annex-copy</code>, which is defined as
  follows
</p>



<pre class="src src-emacs-lisp">(<span style="color: #f0dfaf; font-weight: bold;">defun</span> <span style="color: #8cd0d3;">anything-c-git-annex-copy</span> (candidate)
  (<span style="color: #f0dfaf; font-weight: bold;">let*</span> ((to (anything-comp-read
              <span style="color: #cc9393;">"To Git Annex: "</span>
              (anything-c-git-remotes)
              <span style="color: #8cd0d3;">:must-match</span> nil)))
    (anything-git-annex-command <span style="color: #cc9393;">"copy"</span> (concat <span style="color: #cc9393;">"\""</span> candidate <span style="color: #cc9393;">"\""</span>)
                                <span style="color: #cc9393;">"--to"</span> (concat <span style="color: #cc9393;">"\""</span> to <span style="color: #cc9393;">"\""</span>))))

(<span style="color: #f0dfaf; font-weight: bold;">defun</span> <span style="color: #8cd0d3;">anything-c-git-remotes</span> ()
  (<span style="color: #f0dfaf; font-weight: bold;">with-temp-buffer</span>
    (call-process <span style="color: #cc9393;">"git"</span> nil (current-buffer) nil <span style="color: #cc9393;">"remote"</span>)
    (delete <span style="color: #cc9393;">""</span> (split-string (buffer-string) <span style="color: #cc9393;">"\n"</span>))))
</pre>




<p>
  The <code>anything-c-git-annex-copy</code> command needs to know to which
  repository it should copy the candidate that has been selected.  I
  find out which one I want to copy to by listing the remotes that are
  known about by the git repository that the file is in.  Using
  <code>anything-comp-read</code> means that the remotes are listed in the same
  style all of the <code>anything</code> candidates are listed in.  It's pretty
  nice, because it keeps me in the same mode of operation as before.
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Wrapping up </h2>
<div class="outline-text-2" id="text-3">


<p>
  It's a bit hard to write about what makes <code>anything.el</code> an
  interesting way of doing things in emacs &ndash; a screencast might be
  more helpful &ndash; but I hope some of the power is evident from this
  little writeup.  I'm going to try to train myself to use <code>anything</code>
  more often.  We'll see how it goes.
</p>



</div>
</div>

</div>

<div class="inlinefooter">

<span class="pagedate">
Posted <span class="date">Mon 12 Dec 2011 01:03:17 PM MST</span>
</span>


<span class="tags">
Tags:

<a href="../../../tags/anything.el/" rel="tag">anything.el</a>

<a href="../../../tags/emacs/" rel="tag">emacs</a>

<a href="../../../tags/git-annex/" rel="tag">git-annex</a>

</span>








</div>

</div>


</div>

</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'hikingandcoding'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


<div id="footer" class="pagefooter">

<div id="pageinfo">









<div class="pagedate">
Last edited <span class="date">Thu 10 Nov 2011 08:38:47 PM MST</span>
<!-- Created <span class="date">Thu 10 Nov 2011 07:21:15 PM MST</span> -->
</div>

</div>


<!-- from Hiking and Coding -->
</div>

</div>

</body>
</html>
