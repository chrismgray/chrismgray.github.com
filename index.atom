<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom">
<title>Hiking and Coding</title>
<link href="http://chrismgray.github.com//"/>
<link href="http://chrismgray.github.com//index.atom" rel="self" type="application/atom+xml"/>
<author>

<name>Hiking and Coding</name>

</author>




<id>http://chrismgray.github.com//</id>

<subtitle type="html">Hiking and Coding</subtitle>
<generator uri="http://ikiwiki.info/" version="3.20111106">ikiwiki</generator>
<updated>2011-11-27T17:07:34Z</updated>
<entry>
	<title>clojure-sorting</title>

	<id>http://chrismgray.github.com//posts/clojure-sorting/</id>

	<link href="http://chrismgray.github.com//posts/clojure-sorting/"/>






	<category term="clojure" />

	<category term="lab-notes" />

	<category term="sort" />


	<updated>2011-11-27T17:07:34Z</updated>
	<published>2011-11-27T14:23:34Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Penance &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  In a job interview last week I said a couple of things related to
  sorting in Clojure that turned out to be incorrect when I checked
  them.  This is my way of making up for them &amp;ndash; if I can make them
  true, then no one will notice.  Though to be fair, I&#39;m sure that I&#39;m
  the only one that thinks that way.
&lt;/p&gt;
&lt;p&gt;
  The first thing I said was that heap-sort is my favorite sorting
  algorithm, but then I declined to implement it, preferring to
  implement merge-sort instead.  I think this is actually pretty
  reasonable in an interview situation &amp;ndash; heap-sort is a conceptually
  more difficult sorting algorithm, so being able to remember it on
  the spot is more difficult.  The second thing I said was that
  Clojure itself uses heap-sort and that given its love affair with
  laziness that it would not be unreasonable to assume that &lt;code&gt;(first   (sort lst))&lt;/code&gt; was a linear-time operation.  I might have read
  something like this on a mailing list or IRC, but it is not
  correct.  Clojure currently uses Java&#39;s &lt;code&gt;sort&lt;/code&gt; function, which is a
  slightly-modified merge-sort.  There is not much point in making
  that algorithm lazy, because getting the first element from the
  sorted list requires \(O(n \log n)\) time anyway.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Heap Sort &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  For those that are not familiar with it, heap-sort is something that
  is usually taught in a second-year undergraduate Computer Science
  class.  So it&#39;s not &lt;b&gt;that&lt;/b&gt; difficult an algorithm, but it does
  require some thinking, and there is some fancy analysis that goes
  into part of it.  For a full discussion, see the &lt;a href=&quot;http://www.amazon.com/gp/product/0262033844/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;tag=hikiandcodi-20&amp;amp;linkCode=as2&amp;amp;camp=217145&amp;amp;creative=399369&amp;amp;creativeASIN=0262033844&quot;&gt;Introduction to Algorithms&lt;/a&gt; book by Cormen, Lieserson, Rivest, and Stein.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-1&quot;&gt;Heap &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-1&quot;&gt;


&lt;p&gt;
   To start with, a &lt;i&gt;heap&lt;/i&gt; is conceptually a tree where values are
   stored at the nodes.  The largest value of all the values stored in
   subtrees is stored at the root and the two descendant trees are
   heaps.  Heaps are usually required to be as close to balanced as
   possible &amp;ndash; if any level of the tree has leaves, they are all
   bunched to the right, and all the rest of the leaves are at the
   next level.
&lt;/p&gt;
&lt;p&gt;
   Such a tree is usually implemented as an array, where the child
   nodes of a node can be obtained by some simple arithmetic on the
   index of the node in the array.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-2&quot;&gt;Building a Heap &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-2&quot;&gt;


&lt;p&gt;
   Given the definition, there is an intuitive algorithm for building
   such a heap on a set of numbers: first find the largest number in
   your set and have it be the root of the heap, then split the rest
   of the numbers in half, and recursively make heaps on those sets.
&lt;/p&gt;
&lt;p&gt;
   Such an algorithm is clearly correct, but it is also clearly
   \(\Theta(n \log n)\).  We can do better with a bottom-up algorithm.
   If we continue imagining the heap as a tree, we start by putting
   the input numbers into the tree willy-nilly.  This clearly does not
   satisfy the heap properties laid out above.  However, some of it
   does satisfy the heap properties &amp;ndash; the leaves of the tree are
   trivially heaps.  If we go up one level from the leaves, we can fix
   the trees rooted there by exchanging the root of the tree with its
   largest child (or not exchanging it if it&#39;s already the largest of
   the three).  Higher levels are a bit more difficult, because if the
   root of a tree is exchanged, then we must make sure to fix the tree
   that it ends up being the root of.  You can imagine the root of a
   tree traveling down the heap until it is larger than both of its
   children.
&lt;/p&gt;
&lt;p&gt;
   The correctness of this algorithm is a bit harder to see and it
   also appears to take \(O(n \log n)\) time.  It does, but there is a
   slightly more sophisticated analysis that shows that it is really
   \(\Theta(n)\).  I won&#39;t go into the analysis, but a hint is that
   most of the values don&#39;t actually travel very far in the tree.  
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-3&quot;&gt;Using a heap to sort &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-3&quot;&gt;


&lt;p&gt;
   With the heap properties in mind, we can easily see how to get the
   largest value of a set of numbers &amp;ndash; just take the top element from
   the heap.  How can we use the heap properties to sort?  Well, we
   want the largest number, then the largest number that remains, then
   the largest number that remains after that, and so on.  So if we
   can take the largest number from the heap and then fix the heap so
   that it retains the heap properties, then we&#39;d be done.
&lt;/p&gt;
&lt;p&gt;
   We just devised a way to fix heaps when building the heap, so we
   use that.  What we do is to take the very last node in the heap
   (which is not necessarily the smallest, but it doesn&#39;t hurt to
   think about it as the smallest) and put that at the top of the
   heap.  The resulting tree is clearly not a heap, but if we call the
   algorithm to fix heaps on the root of the tree, then we end up with
   a heap again.  The node that we put on top of the heap might end up
   traveling all the way to the bottom, so this update takes
   \(\Theta(\log n)\) time.  Thus if we sort the entire input set, we
   have a \(\Theta(n \log n)\) algorithm.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-4&quot;&gt;Advantages &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-4&quot;&gt;


&lt;p&gt;
   That&#39;s the best we can do theoretically, which is great, but the
   Java &lt;code&gt;sort&lt;/code&gt; algorithm is also \(\Theta(n \log n)\), so why is there
   any advantage to using heap-sort?  In a language where laziness is
   embraced (such as Clojure), heap-sort can be made lazy.  That is,
   the next element of the sorted list can be computed only when it is
   needed.  Since the build-heap procedure described above takes
   linear time, getting the first element from the sorted list takes
   \(O(n)\) time.  Each subsequent element then takes \(O(\log n)\)
   time.  Thus, if only a small number of elements from the sorted
   list are needed, then this lazy version of heap-sort is
   theoretically faster than other sorts.
&lt;/p&gt;
&lt;p&gt;
   I can think of situations where this would actually have practical
   advantages.  For example, what if you were writing a search engine
   and wanted to obtain the \(k\) best results?  You could write an
   ad-hoc function that found the best result, removed it and recursed
   \(k - 1\) times.  Or you could just &lt;code&gt;(take k (heap-sort input))&lt;/code&gt;.
   The first would take \(O(kn)\) time, whereas the second would take
   \(O(k \log n + n)\) time.  In many practical situations, \(k\) is
   \(O(\log n)\), which means that the first takes \(O(n \log n)\)
   time, whereas the second takes only \(O(n)\) time.  Essentially,
   the first is no better than the second solution with a non-lazy
   sorting algorithm.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-5&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-5&quot;&gt;Disadvantages &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-5&quot;&gt;


&lt;p&gt;
   Heap-sort has some disadvantages compared to other sorts of &lt;code&gt;sort&lt;/code&gt;
   algorithms.  The least theoretically significant is that the
   constants hidden in the big-O notation are higher than other
   sorting algorithms (tuned versions of quicksort can have extremely
   small constants).
&lt;/p&gt;
&lt;p&gt;
   Another disadvantage can be seen when dealing with data sets so
   large that they no longer fit in the computer&#39;s main memory.
   Something like merge-sort can be modified fairly easily so that the
   number I/O operations is minimized.  I haven&#39;t thought about it too
   deeply, but this doesn&#39;t seem quite so easy with heap-sort.
   However, I think that people dealing with such large datasets
   should probably be using specialized libraries anyway, so perhaps
   that isn&#39;t too bad.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Implementation &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  This whole discussion is a bit useless if it only remains at the
  theoretical level.  I have an implementation &lt;a href=&quot;https://github.com/chrismgray/clojure-heap-sort&quot;&gt;in my github repo&lt;/a&gt; that
  implements most of the ideas that are given above.  The code is
  highly optimized so that it is somewhat competitive with the native
  Java implementation.  This makes the code on the HEAD of the
  &lt;code&gt;master&lt;/code&gt; branch somewhat less than readable.  However, the first
  commit to the repository used Clojure vectors and a functional
  style, so if you would like to understand the code, you might start
  there. 
&lt;/p&gt;
&lt;p&gt;
  I (unfortunately) needed to use Java arrays and mutation rather than
  the more functional style that I have gotten used to, but the
  results speak for themselves.  Finding the first few elements of a
  sorted array is significantly faster than the Java version.  Finding
  the entire sorted list is somewhat slower than the Java version, but
  not too much.  This is not surprising for a couple of reasons.
  First, heap-sort tends to have larger constants than other sorting
  methods.  Secondly, this code is one day old.  The Java sort method
  has had years to be optimized.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Conclusion &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;


&lt;p&gt;
  It may be dreaming, but I would love to see this idea (if not this
  implementation) put into Clojure proper.  I think the advantages
  from laziness outweigh the small constant slowdown versus using
  Java&#39;s &lt;code&gt;sort&lt;/code&gt;.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/clojure-sorting/#comments" type="text/html" />


	<link rel="comments" href="/posts/clojure-sorting/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>git-annex</title>

	<id>http://chrismgray.github.com//posts/git-annex/</id>

	<link href="http://chrismgray.github.com//posts/git-annex/"/>






	<category term="git" />

	<category term="git-annex" />


	<updated>2011-11-24T05:55:10Z</updated>
	<published>2011-11-24T03:02:00Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Using git annex &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I remember being a young pup using Debian and reading the mailing
  lists.  I was always seeing the name &lt;a href=&quot;http://joey.kitenet.net/blog/&quot;&gt;Joey Hess&lt;/a&gt; answering the tough
  questions.  I had great respect for him then, and it has remained to
  this day.  I have probably used his &lt;code&gt;unclutter&lt;/code&gt; program for ten
  years and it has never crashed.  I recently installed &lt;code&gt;ikiwiki&lt;/code&gt; to
  run this blog, &lt;code&gt;etckeeper&lt;/code&gt; to track changes in my config files, and
  I figured that I should try his other recent software: &lt;code&gt;git-annex&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  I came at it with two objectives: to be able to sync my podcasts and
  to be able to manage my media files better.  The second has worked
  really well, and the first &lt;a href=&quot;http://git-annex.branchable.com/forum/Podcast_syncing_use-case/&quot;&gt;is hopefully getting there soon&lt;/a&gt;.  I will
  concentrate on the second for the moment, since that is what I have
  working the best.  There are multiple use-cases described on
  &lt;a href=&quot;http://git-annex.branchable.com&quot;&gt;git-annex&#39;s website&lt;/a&gt; &amp;ndash; I will just go through mine.
&lt;/p&gt;
&lt;p&gt;
  All of my media files are on a terabyte external drive.  When I am
  at home, I have it mounted as an NFS drive on &lt;code&gt;/media/mybook&lt;/code&gt;.  I
  have videos there, split into &lt;code&gt;tv&lt;/code&gt; and &lt;code&gt;movies&lt;/code&gt; folders, as well as
  music in the &lt;code&gt;music&lt;/code&gt; folder.  All of the folders are treated the
  same, so I will just go through the procedure I used in the &lt;code&gt;music&lt;/code&gt;
  folder.
&lt;/p&gt;
&lt;p&gt;
  First, I set up the annex:
&lt;/p&gt;



&lt;pre class=&quot;src src-shell&quot;&gt;~ $ cd /media/mybook/music
/media/mybook/music $ git init .
/media/mybook/music $ git annex init mybook-music
/media/mybook/music $ emacs .git/config
&lt;/pre&gt;




&lt;p&gt;
  at this point, I set the &lt;code&gt;backends&lt;/code&gt; keyword in the &lt;code&gt;[annex]&lt;/code&gt; section
  to either &lt;code&gt;SHA1E&lt;/code&gt; or &lt;code&gt;SHA256E&lt;/code&gt;.  There is a tradeoff there between
  speed and safety &amp;ndash; it is a bit more likely that two files hash to
  the same file with &lt;code&gt;SHA1E&lt;/code&gt;, but it is faster than &lt;code&gt;SHA256E&lt;/code&gt;.  The
  &lt;code&gt;E&lt;/code&gt; at the end of the hash means that the filename extension is
  preserved in the hashing.  This is important for some mp3 players
  and other programs that can not tell what type a file is without an
  extension.  The next command takes a long time with a lot of files:
&lt;/p&gt;



&lt;pre class=&quot;src src-shell&quot;&gt;/media/mybook/music $ git annex add .
[All the files are hashed and their contents are put into .git/annex]
[You will see that all your files are now symlinks to files in .git/annex]
/media/mybook/music $ git commit -m &lt;span&gt;&quot;Added my files&quot;&lt;/span&gt;
&lt;/pre&gt;




&lt;p&gt;
  Now it is possible to clone this repository back on the laptop
&lt;/p&gt;



&lt;pre class=&quot;src src-shell&quot;&gt;~ $ git clone /media/mybook/music
~ $ cd music
~/music $ git annex init laptop-music
~/music $ git remote add mybook-music /media/mybook/music
~/music $ cd /media/mybook/music
/media/mybook/music $ git remote add laptop-music ~/music
&lt;/pre&gt;




&lt;p&gt;
  And now all of the cool stuff can begin.  You can look inside the
  &lt;code&gt;~/music&lt;/code&gt; directory and see that it appears that all your files are
  there.  However, they are not taking up any space.  What is
  happening is that they are broken symlinks to objects in
  &lt;code&gt;~/music/.git/annex&lt;/code&gt;.  If I want to listen to some of the music, I
  move it over to the laptop with the following command
&lt;/p&gt;



&lt;pre class=&quot;src src-shell&quot;&gt;~/music $ git annex get --from mybook-music Beatles/
&lt;/pre&gt;




&lt;p&gt;
  I can now take my laptop on the plane and listen to the Beatles.
  When I&#39;m back from my trip, I can free up the space by doing
&lt;/p&gt;



&lt;pre class=&quot;src src-shell&quot;&gt;~/music $ git annex drop Beatles/
&lt;/pre&gt;




&lt;p&gt;
  Suppose I obtain some new music, getting into the Rolling Stones.
  Then I can use &lt;code&gt;git annex add&lt;/code&gt; to add the Stones into my collection,
  &lt;code&gt;git commit&lt;/code&gt; them and &lt;code&gt;git pull&lt;/code&gt; in the correct repository to
  duplicate the information.  I can then use &lt;code&gt;git annex copy&lt;/code&gt; or &lt;code&gt;git   annex move&lt;/code&gt; to put the files where I want them.
&lt;/p&gt;
&lt;p&gt;
  For now, I have a queue of unseen videos and music that I want to
  hear on my laptop, while the bulk of my media collection sits on my
  external drive.  I can take what I want with me and not worry about
  my whole collection using up all of my hard drive.  I can see what I
  have in a particular repository with the &lt;code&gt;git annex find&lt;/code&gt; command.
&lt;/p&gt;
&lt;p&gt;
  As I said, there are many other uses for git-annex and features that
  I have not yet learned.  One thing that I am interested in trying
  out is using the &lt;a href=&quot;http://git-annex.branchable.com/special_remotes/web/&quot;&gt;web&lt;/a&gt; as a repository.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/git-annex/#comments" type="text/html" />


	<link rel="comments" href="/posts/git-annex/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>processing</title>

	<id>http://chrismgray.github.com//posts/processing/</id>

	<link href="http://chrismgray.github.com//posts/processing/"/>






	<category term="clojure" />

	<category term="lab-notes" />

	<category term="processing" />

	<category term="visibility-polygon" />


	<updated>2011-11-22T21:06:52Z</updated>
	<published>2011-11-22T19:29:29Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Viewing visibility polygons &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I mentioned yesterday that it would be nice to see the output of my
  visibility polygon solution.  To that end, I created an extremely
  simple drawing editor using &lt;a href=&quot;http://processing.org/&quot;&gt;Processing&lt;/a&gt;.  I have to say, I loved it.
&lt;/p&gt;
&lt;p&gt;
  The most important feature to me is the extreme interactivity.  I
  can change functions extremely quickly with my tools &amp;ndash; redefining a
  Clojure function is either one or two keystrokes in emacs, depending
  how I choose to do it &amp;ndash; so I like a graphics environment that
  changes just as quickly.  This is what Processing, and in particular
  &lt;code&gt;clj-processing&lt;/code&gt;, offers.  I was able to define a function that
  draws the various objects (in this case, the polygon, the point
  where the mouse is, and the visibility polygon of the mouse point
  inside the polygon).  If I wanted to make any changes to this
  function &amp;ndash; for example, changing the color of the point where the
  mouse is &amp;ndash; I can simply redefine the function using my emacs tools
  and the change shows up immediately on the drawing.
&lt;/p&gt;
&lt;p&gt;
  I was able to use this to find a couple of minor bugs in my
  visibility-polygon-finding code, but in general, it worked really
  well on the first try.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-1-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-1-1&quot;&gt;Shortcomings &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-1-1&quot;&gt;


&lt;p&gt;
   There were a couple of things that slightly bothered me about
   &lt;code&gt;clj-processing&lt;/code&gt;.  First, it used quite a lot of CPU just to
   display a simple polygon without too many points.  I am probably
   using it rather na√Øvely, so it is possible that this is my problem
   and not the problem of &lt;code&gt;clj-processing&lt;/code&gt;.  However, the second
   problem is just that &lt;code&gt;clj-processing&lt;/code&gt; is showing its age.  I think
   it was probably one of the first Clojure libraries out there and
   much of the coding style hasn&#39;t evolved with the Clojure best
   practices that people use.  For example, some of the features do
   not work if you only &lt;code&gt;require&lt;/code&gt; the library &amp;ndash; you must &lt;code&gt;use&lt;/code&gt; it.  I
   try to only &lt;code&gt;require&lt;/code&gt; libraries, to avoid my namespace becoming
   overly populated, so it is frustrating when that doesn&#39;t work.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Going forward &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I need to clean up the code a bit before I can put it up on github,
  but it should be there soon.  It currently needs me to explicitly
  call the function in order to find the visibility polygon.  I would
  really like it to find the visibility polygon of any point where the
  mouse is inside the polygon.  However, determining if a point is
  inside a non-convex polygon tends to be a bit harder than it
  sounds.  You can shoot a ray in one direction from a point, and
  count the number of polygon edges that it crosses &amp;ndash; if it&#39;s even
  you are outside and if it&#39;s odd you are inside &amp;ndash; but what happens
  if the ray crosses a vertex?  There was a good experimental paper on
  this problem at a recent EuroCG.
&lt;/p&gt;
&lt;p&gt;
  So that&#39;s a slightly non-trivial problem.  I also coded an
  implementation of the Voronoi Diagram problem recently.  I should
  add a Processing UI to that as well.  I have a feeling that would be
  the easier task to do next, and I would surely discover some bugs in
  it while I did.
&lt;/p&gt;



&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/processing/#comments" type="text/html" />


	<link rel="comments" href="/posts/processing/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>visibility-polygon</title>

	<id>http://chrismgray.github.com//posts/visibility-polygon/</id>

	<link href="http://chrismgray.github.com//posts/visibility-polygon/"/>






	<category term="clojure" />

	<category term="computational-geometry" />

	<category term="lab-notes" />

	<category term="visibility-polygon" />


	<updated>2011-11-21T19:58:03Z</updated>
	<published>2011-11-21T19:44:43Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Visibility Polygon &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I&#39;ve put up some preliminary code for finding visibility polygons on
  my &lt;a href=&quot;https://github.com/chrismgray/visibility-polygon&quot;&gt;github repo&lt;/a&gt;.  I have only tested it with one polygon, but so far
  things are looking good.  My idea from yesterday of using monads to
  &quot;parse&quot; the polygon seems to be paying off.  Here is the relevant
  code:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(defn- add-new-pt [poly]
  (fn [pt stack]
    (when (or (empty? stack) ; First two points are guaranteed to be visible
              (empty? (rest stack))
              (visible? pt (first poly) (first stack)))
      [pt (rest poly) (cons (first poly) stack)])))

(defn- pop-stack [poly]
  (fn [pt stack]
    (let [the-seg (seg/new-seg pt (first poly))
          top-seg (seg/new-seg (first stack) (second stack))]
      (when (pt/left-turn? (second stack) (first stack) (first poly))
        (if (seg/intersection-on-seg? the-seg top-seg)
          [pt poly (cons (seg/intersection the-seg top-seg) stack)]
          [pt poly (rest stack)])))))

(defn- skip-pt [poly]
  (fn [pt stack]
   (let [the-seg (seg/new-seg pt (first stack))
         poly-seg (seg/new-seg (first poly) (second poly))]
     (when (not (pt/left-turn? (second stack) (first stack) (first poly)))
       (if (seg/intersection-on-seg? the-seg poly-seg)
         [pt (cons (seg/intersection the-seg poly-seg) (rest poly)) stack]
         [pt (rest poly) stack])))))

(defn- all-conditions [poly]
  (with-monad polygon-parser-m
    (m-plus (add-new-pt poly) (pop-stack poly) (skip-pt poly))))
&lt;/pre&gt;




&lt;p&gt;
  This defines three actions to be performed when the polygon and
  stack are in certain configurations.  The first executes when the
  next point on the polygon doesn&#39;t obscure any of the stack.  In that
  case, it removes the point from &lt;code&gt;poly&lt;/code&gt; and puts it on &lt;code&gt;stack&lt;/code&gt;.  The
  second executes by popping points off the stack until the next point
  on the polygon no longer obscures the stack.  The final condition
  activates when the next point on the polygon is hidden by the
  stack.  It skips the points of &lt;code&gt;poly&lt;/code&gt; until it finds one that would
  be visible.  We combine the three conditions using &lt;code&gt;m-plus&lt;/code&gt;, which
  is defined to try the conditions in order until one returns
  something that is not &lt;code&gt;nil&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  Is this solution any better than a functional programming solution
  without monads?  I think it is.  First, the conditions are easy to
  see and very explicitly laid out.  Using a &lt;code&gt;cond&lt;/code&gt; to accomplish the
  same thing is certainly possible, but gets more complicated as the
  number of conditions grows.  Also, we are explicitly managing state
  in this solution.  Doing so in an ad-hoc manner would be much more
  difficult.  In fact, I am not really sure how I would loop until
  there are no more points in &lt;code&gt;poly&lt;/code&gt; in a solution without monads
  (especially since not all the conditions consume a point from
  &lt;code&gt;poly&lt;/code&gt;).  With monads, it is quite simple:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(defn- visibility-polygon-helper [pt poly]
  ((with-monad polygon-parser-m
     (m-until empty? all-conditions poly)) pt []))
&lt;/pre&gt;




&lt;p&gt;
  Doing something like that with a &lt;code&gt;reduce&lt;/code&gt; seems like it would veer
  off into unreadability fairly quickly.
&lt;/p&gt;
&lt;p&gt;
  Are there downsides to this solution?  I think there is at least
  one.  That is, the conditions must be functions that return functions.
  This makes them a bit more confusing than they really should be.  I
  needed to do this so that I could have a test in the &lt;code&gt;m-until&lt;/code&gt;
  function above.  On the whole, though, this is a fairly cosmetic
  gripe, and can be hidden by using helper functions like the one
  above.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;On the horizon &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I would like to test the code quite a bit more.  However, doing so
  by drawing out polygons by hand and then figuring out their
  visibility polygons is quite tedious.  Therefore, I need some sort
  of GUI to be able to draw polygons and then I will be able to
  see whether the computed visibility polygon makes sense.
&lt;/p&gt;
&lt;p&gt;
  I am thinking that it might be nice to use the &lt;a href=&quot;https://github.com/rosado/clj-processing&quot;&gt;&lt;code&gt;clj-processing&lt;/code&gt; library&lt;/a&gt; to do this.  Unfortunately, that library is currently only
  using Clojure 1.2.  Since I am using Clojure 1.3, that might be a
  problem.  So I might need to do some porting from 1.2 to 1.3.
  However, doing so should give me a good idea of how processing
  works, and could give a nice tool for more interactive geometry
  programs. 
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/visibility-polygon/#comments" type="text/html" />


	<link rel="comments" href="/posts/visibility-polygon/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>parsing-polygons</title>

	<id>http://chrismgray.github.com//posts/parsing-polygons/</id>

	<link href="http://chrismgray.github.com//posts/parsing-polygons/"/>






	<category term="computational-geometry" />

	<category term="lab-notes" />

	<category term="visibility-polygon" />


	<updated>2011-11-21T01:16:32Z</updated>
	<published>2011-11-21T00:58:28Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Functional programming &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I&#39;ve gotten a bit obsessed by functional programming over the last
  couple of years.  I have even seriously thought about writing a book
  that looks at computational geometry (which is the subject in which
  I was trained) in the light of functional programming.  Most of the
  standard computational-geometry texts these days approach the
  writing of code from an imperative standpoint.
&lt;/p&gt;
&lt;p&gt;
  I think functional programming is a good way to think about
  computational geometry for a couple of reasons.  First, most
  problems in computational geometry can be expressed in a purely
  functional manner.  That is, the answers to the problems are usually
  the same given the same inputs.  Secondly, I have bought into the
  idea that parallel and distributed computing are much easier when
  state is not being modified.  Functional programming forces you to
  think this way.  While many problems in computational geometry are
  inherently sequential, not all of them are.  Using a programming
  method that allows for the easy addition of more cores seems like a
  good practice when a problem is encountered that is easily made
  parallel. 
&lt;/p&gt;
&lt;p&gt;
  One of the things I have been thinking about as a final chapter for
  the book that I would like to write is the introduction of monads as
  a way to &quot;parse&quot; polygons.  Monads are commonly used (well, commonly
  in the functional programming world) to parse strings.  They
  generally scan through with the aid of a stack.  There are many
  algorithms that scan through the points of a polygon with a stack --
  the example that I have thought about the most is the visibility
  polygon.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;Visibility polygons &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  A &lt;i&gt;visibility polygon&lt;/i&gt; is the subset of a polygon that can be &quot;seen&quot;
  from a point inside the polygon.  Here, we regard the segments of
  the polygon as opaque walls.
&lt;/p&gt;
&lt;p&gt;
  The standard algorithm for computing the visibility polygon is not
  too difficult to implement in an imperative language.  In fact, I
  &lt;a href=&quot;http://www.win.tue.nl/~cgray/ipelets.html&quot;&gt;implemented&lt;/a&gt; it already in C++ for the drawing editor &lt;a href=&quot;http://tclab.kaist.ac.kr/ipe/&quot;&gt;ipe&lt;/a&gt;.  (Though I
  think that code is now obsolete since the release of ipe 7.)
&lt;/p&gt;
&lt;p&gt;
  I&#39;ve already tipped my hand at how I would think about implementing
  such an algorithm in a functional language.  I would use a variant
  of a monadic parser to go through the polygon and find the parts
  that are visible.  (That last sentence doesn&#39;t give much of a hint
  about how it&#39;s done, but the whole algorithm would take too much
  space to describe.  Suffice it to say that a stack is kept with the
  &quot;currently visible&quot; portion of the polygon always on the stack.)
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Monads &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  I used monads &lt;a href=&quot;http://chrismgray.github.com/posts/time-series-2/&quot;&gt;earlier&lt;/a&gt; to make a framework for creating and comparing
  time-series.  However, I only used a monad that was already defined
  by someone else.  I think I might need to define a monad on my own
  this time &amp;ndash; a slightly daunting idea.  I definitely need to read
  the rest of &lt;a href=&quot;http://intensivesystems.s3-website-us-east-1.amazonaws.com/tutorials/monads_201.html&quot;&gt;Jim Duey&#39;s tutorial&lt;/a&gt; to make sense of how to do it.
&lt;/p&gt;



&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/parsing-polygons/#comments" type="text/html" />


	<link rel="comments" href="/posts/parsing-polygons/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>100-mile-wilderness</title>

	<id>http://chrismgray.github.com//posts/hiking/100-mile-wilderness/</id>

	<link href="http://chrismgray.github.com//posts/hiking/100-mile-wilderness/"/>






	<category term="at" />

	<category term="hiking" />


	<updated>2011-11-21T00:31:34Z</updated>
	<published>2011-11-19T20:34:35Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Introduction &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
I&#39;m sitting in an airport, breathing the recycled air and jet exhaust,
so I thought I&#39;d write a bit more about my hiking experiences.  I
don&#39;t have my trail guide with me, so I won&#39;t be able to include as
many details as I would like, but hopefully I can recall the things
that made the biggest impression on me. 
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;The 100-Mile Wilderness &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  Right after the huge challenge of climbing Mount Katahdin,
  southbound hikers on the Appalachian Trail must deal with about 100
  miles without any stores or conveniences.  As I mentioned in my &lt;a href=&quot;http://chrismgray.github.com/posts/hiking/at-01/&quot;&gt;last hiking post&lt;/a&gt;, this means big and heavy packs for the hikers.  Also,
  my lack of experience meant that I was carrying things that I didn&#39;t
  really need, so when I set out on the first morning I was really
  loaded down.
&lt;/p&gt;
&lt;p&gt;
  I got out of camp a bit later than Oblio and his dad, and walked out
  of Baxter Park.  I don&#39;t remember too much about the first day.
  There was a decent-sized river that we walked beside for a while and
  I thought I saw a beaver or some other water animal, but I couldn&#39;t
  get close enough to get a picture.
&lt;/p&gt;
&lt;p&gt;
  We officially entered the 100-mile wilderness when we passed this
  &lt;a href=&quot;https://picasaweb.google.com/lh/photo/PZEL0R-SlLrRdqSIKN-5UHIQdffm0dM4kWIdDklkn2s?feat=directlink&quot;&gt;sign&lt;/a&gt;, and didn&#39;t walk more than 100 yards before we saw some moose
  dung.  That seemed like a good sign to me.  Where there&#39;s dung,
  there&#39;s animals.  A couple of miles later, it was time to call it a
  day at the first shelter on the AT.  The log in the shelter warned
  of rodents, so I immediately decided not to sleep in it.  We also
  met some northbounders (nobos in AT parlance).  At that time, I
  viewed them as something like heroes.  These were people that were
  just 10 or 12 miles from finishing the same hike that I was on.
  Wow!  They were so close to the finish line that they were going
  on.  They would probably do half the miles that we had done in the
  entire day in that evening.
&lt;/p&gt;
&lt;p&gt;
  The next day, I got up fairly early.  There was a small hill, and
  then the trail goes around a lake.  The trail was mucky and the
  boards (called &quot;bog boards&quot;) that were placed for people to walk on
  were disintegrating.  Finally we got away from the lake and the
  trail conditions became a bit better.  We crossed &lt;a href=&quot;https://picasaweb.google.com/lh/photo/mv9x4neQvulRVGCYQzUTNHIQdffm0dM4kWIdDklkn2s?feat=directlink&quot;&gt;this bridge&lt;/a&gt; and
  got to &lt;a href=&quot;https://picasaweb.google.com/lh/photo/D2nJ4h_FzubDnoCOSgy6u3IQdffm0dM4kWIdDklkn2s?feat=directlink&quot;&gt;the Rainbow Stream shelter&lt;/a&gt; (I see that Picker and Grinner got
  there before me).  I took a small nap on the pine needles behind the
  shelter and cleaned off my legs in the pool below &lt;a href=&quot;https://picasaweb.google.com/lh/photo/GFBLdt6vU4QgYQIJRgkYinIQdffm0dM4kWIdDklkn2s?feat=directlink&quot;&gt;this waterfall&lt;/a&gt;.
  Finally, I started walking again.  About two miles later, I stumbled
  and decided that I must be getting tired and that I should look for
  a place to camp.  Luckily, I found that Oblio and his dad camped
  just a few hundred yards later, so I stopped there for the night.
&lt;/p&gt;
&lt;p&gt;
  I don&#39;t really remember much about the next couple of days.  On one
  of them, I got bitten by a mosquito on the lip, and my lip swelled
  to twice its normal size.  There was also a river that was reputed
  to have good swimming, but the water was quite warm because it is
  lake-fed.  I hiked a couple of miles past it and camped at the lake
  that was the source.  A float plane landed on the lake while I was
  there, but it was all the way on the other side of the lake, so it
  wasn&#39;t too bothersome.  I had a quiet night, but Picker and Grinner
  didn&#39;t; there was a group of Quebecois Girl Scouts at the campsite
  next to the river and they stayed up late chattering.
&lt;/p&gt;
&lt;p&gt;
  Picker and Grinner passed me early the next morning in what would
  become a pattern.  The two of them were much more efficient than me
  in the morning, especially while I was still cooking oatmeal for
  breakfast.  That day was the first where I had a big choice to
  make.  Would I hike fast and get over White Cap or would I stop just
  before it?  I didn&#39;t have a data book at that point, so I had no
  real way of knowing how hard White Cap would be, but people had been
  hyping it for a while as a pretty hard climb.
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-1&quot;&gt;White Cap &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-1&quot;&gt;


&lt;p&gt;
   When I got to the shelter just before White Cap, I made the choice
   to go on.  The next shelter was just two or three miles away and it
   wasn&#39;t yet late.  This turned out to be a slight mistake.  The
   climb up White Cap wasn&#39;t too bad (though it would turn out to be
   too much for Oblio&#39;s dad &amp;ndash; he had to be helped down the mountain
   and he and Oblio called it quits there), but there were about three
   more mountains to go over before I got to the campsite.  It was in
   that moment that I first learned the value of having a data book,
   though I don&#39;t think it quite sunk in until I got through with
   Maine.
&lt;/p&gt;
&lt;p&gt;
   Another reason that hiking over White Cap that evening was a
   mistake was that there was a large group of Quebecois boys at the
   campsite and they kept making noise until about one the next
   morning.  However, I did get woken up by a moose, so maybe that&#39;s a
   wash.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-2&quot;&gt;Chairback &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-2&quot;&gt;


&lt;p&gt;
   The next day was probably my shortest full day of hiking on the
   trail.  I was clearly tired from my adventure (and the noise made
   by the boys) the night before and I just walked pretty slow in the
   morning.  I also had not counted on the climb up the next mountain
   &amp;ndash; Chairback Mountain &amp;ndash; being &lt;b&gt;straight up&lt;/b&gt;.  People in Maine have
   clearly not heard of switchbacks, because there were none.  When I
   was getting very close to the shelter at Chairback Mountain, there
   was a large climb on talus (big rocks that are just sitting on each
   other with nothing to keep them from falling).  That&#39;s also not my
   favorite thing.
&lt;/p&gt;
&lt;p&gt;
   I had told myself that if I didn&#39;t get to the shelter by 3, then I
   would stay there.  I met an older man that was already staying at
   the shelter and asked him what time it was &amp;ndash; he said that it was
   after three, and I was quite relieved.  We talked for a while --
   his trail name was Frosty and had been on the trail for a day
   longer than me.  I was a bit proud of myself for passing someone
   already, but Frosty had taken a bit of a side trip.
&lt;/p&gt;
&lt;p&gt;
   I went to set up my hammock, and while I was doing that, I heard
   Picker and Grinner arrive.  They had stayed at the shelter before
   White Cap and we had not seen each other that day.  She asked
   Frosty if he&#39;d seen me, and when he pointed me out, Grinner came
   running over and gave me a big hug.  That was a huge help for me to
   have someone glad to see me at the end of what was my first really
   hard day on the trail.  It was just one of the reasons that I give
   a lot of credit for my success on the trail to Picker and Grinner.  
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-3&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-3&quot;&gt;The rest &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-3&quot;&gt;


&lt;p&gt;
   I stayed with Picker, Grinner, and Frosty for the rest of the
   100-mile wilderness.  There were more mountains and campsites, but
   nothing that stands out too vividly in my memory (though this
   &lt;a href=&quot;https://picasaweb.google.com/lh/photo/bUFnjNFdRFDtm2PT7cNbdnIQdffm0dM4kWIdDklkn2s?feat=directlink&quot;&gt;waterfall&lt;/a&gt; is pretty nice).  Frosty turned out to be a great hiking
   companion as well.  His pack was lighter than everyone else&#39;s, so
   he had no problems keeping up, and he has a great sense of humor.
   He had planned a lot better than I had, and finished all the food
   in his pack by breakfast on the final day before we got to Monson.
   I think he had to eat turkey stuffing because he had eaten some
   breakfasts for supper on an earlier night.  Luckily, we were only a
   few miles from the road, so no one starved.  (That being said,
   everyone was talking about food at that point &amp;ndash; we were getting
   pretty hungry and all of us lost quite a bit of weight.)
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-4&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-4&quot;&gt;Monson &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-4&quot;&gt;


&lt;p&gt;
   We called Shaw&#39;s in Monson from the road and they came and picked
   us up.  It was great to get out of the wilderness.  The people at
   Shaw&#39;s were so nice and especially great at dealing with tired
   hikers.  They quickly got us into the showers and gave us a nice
   all-you-can-eat pancake breakfast.
&lt;/p&gt;
&lt;p&gt;
   I think I won&#39;t get into all that happened in Monson today, but
   leave that until the next installment of the saga, where we&#39;ll meet
   Wounded Knee.  Stay tuned.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/hiking/100-mile-wilderness/#comments" type="text/html" />


	<link rel="comments" href="/posts/hiking/100-mile-wilderness/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>spot-tracks</title>

	<id>http://chrismgray.github.com//posts/spot-tracks/</id>

	<link href="http://chrismgray.github.com//posts/spot-tracks/"/>






	<category term="clojurescript" />

	<category term="hiking" />

	<category term="spot" />


	<updated>2011-11-16T16:20:05Z</updated>
	<published>2011-11-16T16:20:05Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Where I was &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I finally have a Clojurescript application that works basically the
  way I want it to.  It shows a Google Map of the US onto which is
  added a series of markers.  The markers are placed at the positions
  that I sent a SPOT message on one of my hikes.  They are dropped at
  intervals that correspond to the intervals between me sending them
  out.  The whole thing takes a minute to watch.  There are a couple
  of parts where it seems like nothing is happening &amp;ndash; those are
  winter when I wasn&#39;t hiking and a period of time between when the
  SPOT stopped working and when I got the replacement.  The app is
  &lt;a href=&quot;http://chrismgray.github.com/posts/spot-tracks/view.html&quot;&gt;here&lt;/a&gt;.  The &lt;a href=&quot;https://github.com/chrismgray/spot-tracks&quot;&gt;source code&lt;/a&gt; is on my github page, but it is mostly
  unedifying. 
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/spot-tracks/#comments" type="text/html" />


	<link rel="comments" href="/posts/spot-tracks/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>luhnybin</title>

	<id>http://chrismgray.github.com//posts/luhnybin/</id>

	<link href="http://chrismgray.github.com//posts/luhnybin/"/>






	<category term="clojure" />

	<category term="programming-challenge" />

	<category term="thrush" />


	<updated>2011-11-15T22:18:05Z</updated>
	<published>2011-11-15T20:22:19Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Another programming challenge &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I woke up with another programming challenge in my inbox this
  morning.  This one is from &lt;a href=&quot;http://squareup.com&quot;&gt;Square&lt;/a&gt;.  They are a company that gives
  you a little device so that you can accept credit cards using a
  smart phone.  The challenge is &lt;a href=&quot;http://corner.squareup.com/2011/11/luhny-bin.html&quot;&gt;here&lt;/a&gt; &amp;ndash; basically it&#39;s about removing
  credit cards numbers from logs.  There are some details about what
  constitutes a credit card number, and how they are distinct from
  other numbers.  I won&#39;t repeat that here, but you should read it to
  understand what&#39;s coming up.
&lt;/p&gt;
&lt;p&gt;
  As usual, I implemented my solution in Clojure.  I particularly
  liked the function I called &lt;code&gt;luhn-check&lt;/code&gt;.  Here it is:
&lt;/p&gt;



&lt;pre class=&quot;src src-clojure&quot;&gt;(defn luhn-check
  &lt;span&gt;&quot;Takes a sequence of digits and determines whether they pass the Luhn test.&lt;/span&gt;
&lt;span&gt;   The sequence must be in order from right to left.&quot;&lt;/span&gt;
  [digits]
  (-&amp;gt;&amp;gt; digits
       (partition 2 2 (repeat 0))
       (mapcat #(vector (first %) (* 2 (second %))))
       (reduce #(+ %1 (int (/ %2 10)) (int (mod %2 10))))
       (#(mod % 10))
       (= 0)))
&lt;/pre&gt;




&lt;p&gt;
  I think this is a good illustration of the &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; operator in
  Clojure, which is also called the &quot;thrush&quot; operator.  Basically,
  this operator can be thought of as taking the result from one
  expression and putting it at the end of the next expression.
&lt;/p&gt;
&lt;p&gt;
  In this case, we start out with a list of digits.  We then partition
  them into pairs, padding with a zero if necessary.  We then take the
  pairs and double the second number in the pair, concatenating all
  the pairs back into a single list.  We then sum up all the digits in
  the list, using the &lt;code&gt;reduce&lt;/code&gt; function.  This leaves us with a
  number.  We get its value \(\mod 10\) and test whether it is equal
  to zero.  If it is, we return &lt;code&gt;true&lt;/code&gt;, otherwise we return &lt;code&gt;false&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
  All of this could be written with nested expressions (and the thrush
  operator is simply a macro that rewrites what you see as nested
  expressions), but I think the way it is written nicely shows what
  the data is doing in the function.
&lt;/p&gt;
&lt;p&gt;
  Anyway, I don&#39;t know if this solution will get me a job, but it was
  a bit of fun coding and didn&#39;t take too long.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/luhnybin/#comments" type="text/html" />


	<link rel="comments" href="/posts/luhnybin/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>scattered</title>

	<id>http://chrismgray.github.com//posts/scattered/</id>

	<link href="http://chrismgray.github.com//posts/scattered/"/>






	<category term="clojure" />

	<category term="clojurescript" />

	<category term="email" />

	<category term="git" />

	<category term="git-annex" />

	<category term="notmuch" />

	<category term="spot" />


	<updated>2011-11-14T18:14:04Z</updated>
	<published>2011-11-14T17:11:23Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Scattered &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  I am doing a bunch of things today, all fairly small.  I think it&#39;s
  because I finished working on the time series framework yesterday,
  so I&#39;m kind of at loose ends.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;New programming project &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  One thing that I would like to do is to take all the messages that I
  sent with my &lt;a href=&quot;http://findmespot.com&quot;&gt;SPOT&lt;/a&gt; device while hiking and make a small animation of
  them on Google Maps.  This would be another use of Clojurescript.
  My previous project &amp;ndash; a Clojurescript program for computing the
  Voronoi Diagram of a set of points input by a user &amp;ndash; is a bit
  stalled at the moment, so it&#39;s good to have something else to work
  on.  Also, I feel like adding points to a Google Map is something
  that Clojurescript is better suited to, rather than the fiddly
  numeric stuff that I was trying to make it do.  I will come back to
  the Voronoi Diagram at some point (hopefully fairly soon), but I am
  putting it on the back burner for the moment.
&lt;/p&gt;
&lt;p&gt;
  So far, I see two major tasks:
&lt;/p&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-1&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-1&quot;&gt;Getting the coordinates and times of the SPOT messages &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-1&quot;&gt;


&lt;p&gt;
   Every SPOT message is an email that contains the coordinates of
   where and when the message was sent.  Parsing the email can be done
   offline, so I will probably just use Clojure for that.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2-2&quot; class=&quot;outline-3&quot;&gt;
&lt;h3 id=&quot;sec-2-2&quot;&gt;Putting them on the Google Map &lt;/h3&gt;
&lt;div class=&quot;outline-text-3&quot; id=&quot;text-2-2&quot;&gt;


&lt;p&gt;
   The &lt;a href=&quot;http://code.google.com/apis/maps/documentation/javascript/overlays.html#Markers&quot;&gt;API&lt;/a&gt; for using Google Maps appears to be easy to use and
   well-thought-out.  There&#39;s even a way to drop the markers at
   different intervals &amp;ndash; just what I want to do.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;Notmuch &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  I am also playing with the &lt;a href=&quot;http://notmuch.org&quot;&gt;notmuch&lt;/a&gt; email client.  So far I quite
  like it.  It&#39;s a heck of a lot faster than my previous mail client,
  mainly because it doesn&#39;t do as much.  Like gmail, it is optimized
  towards two operations: searching and tagging.  I never really used
  tags in gmail, because doing so involves clicking around, but it&#39;s
  much faster in notmuch.  So far, this seems like the big advantage
  for notmuch.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-4&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-4&quot;&gt;Git annex &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-4&quot;&gt;


&lt;p&gt;
  In an effort to use all the software written by &lt;a href=&quot;http://joey.kitenet.net/&quot;&gt;Joey Hess&lt;/a&gt; (not
  really, but it seems like it), I am also trying out &lt;a href=&quot;http://git-annex.branchable.com/&quot;&gt;git annex&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
  So far, I have come up with one really compelling use case --
  syncing podcasts to my mp3 player.  My mp3 player has the problem
  that it will delete all the files on it at random times.  Thus, I
  need to keep a backup of all the files on it on my computer.
  However, when I am done listening to a podcast, I like to remove the
  file.  Hopefully, I will be able to sync the files that I remove
  myself (that is, remove them from the laptop), but not the files
  that get removed by the stupid thing crashing.
&lt;/p&gt;
&lt;p&gt;
  Another thing that I would like to do is put my music and video
  collections in git annex.  I&#39;m not sure that anything special would
  come from doing that, but it seems nice to have these things in
  version control.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/scattered/#comments" type="text/html" />


	<link rel="comments" href="/posts/scattered/comments.atom" type="application/atom+xml" />

</entry>
<entry>
	<title>at-01</title>

	<id>http://chrismgray.github.com//posts/hiking/at-01/</id>

	<link href="http://chrismgray.github.com//posts/hiking/at-01/"/>






	<category term="AT" />

	<category term="hiking" />


	<updated>2011-11-13T16:05:46Z</updated>
	<published>2011-11-13T15:57:32Z</published>

	<content type="html" xml:lang="en">
	&lt;div id=&quot;outline-container-1&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-1&quot;&gt;Starting on the Appalachian Trail &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-1&quot;&gt;


&lt;p&gt;
  This is my first post about hiking, so I think it should be about my
  first days really hiking.  That would be July 1 and 2, 2010.  It
  already seems like an eternity ago, so much has happened since
  then.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-2&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-2&quot;&gt;July 1 &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-2&quot;&gt;


&lt;p&gt;
  I had been at a conference in Quebec City in the days leading up to
  July 1.  It had gone well and I had given a talk that I thought was
  pretty well-received.  But more important for me on that day was
  that I had gone to &lt;a href=&quot;http://mec.ca&quot;&gt;MEC&lt;/a&gt; and bought a bunch of backpacking gear.  In
  fact, I had mailed all my possessions home from Germany to Calgary
  the week before, so I was really planning to live on the trail.  I
  had no alternative.
&lt;/p&gt;
&lt;p&gt;
  I shaved one last time before my trip, took my new gear, and walked
  to the rental-car agency.  I had booked a car the day before and
  knew it would be open, even though it was Canada Day.  The drive
  from Quebec to Maine was long and pretty boring.  The only
  slightly-eventful thing that happened was that the border guards
  really gave me a hard time, eventually saying something like &quot;Well,
  we have to let him in, he&#39;s a citizen.&quot;  I guess they don&#39;t have
  much to do at that particular crossing, so they make the most of it
  when they get someone with even a slightly strange story.
&lt;/p&gt;
&lt;p&gt;
  I arrived in Bangor, Maine and needed to do some food shopping.  I
  knew that I had the dreaded 100-mile wilderness ahead of me, meaning
  that I might not get to a store for 10 days.  The stuff I bought
  then seems rather comical now.  I had a pound of rice and four or
  five Indian meals that were not dehydrated.  Also a full jar of
  peanut butter and a full jar of jelly.  And two different kinds of
  non-dehydrated hummus.  I&#39;m pretty sure it all fit into my
  food bag eventually, but it took some doing.
&lt;/p&gt;
&lt;p&gt;
  I returned the car at the airport and then took the airport bus from
  the airport to the bus terminal.  It turned out that the bus
  terminal was walking distance from the rental-car agency, but I
  didn&#39;t find that out until I was already on the bus.
&lt;/p&gt;
&lt;p&gt;
  I got to the bus terminal and asked for a ticket to Millinocket.  It
  turned out that I wasn&#39;t the first to do that on that day: two other
  people were already there that were going to the trailhead.  They
  would become known to me as Picker and Grinner, and I would walk
  with them for about 1000 miles.  They obviously knew what they were
  doing.  They had sent their food ahead to the Inn at Millinocket and
  had booked a ride there.  Grinner had also already hiked the trail,
  so I was sure that I was safe tagging along with them.
&lt;/p&gt;
&lt;p&gt;
  At the inn, I met a couple more people that were starting the same
  day as me: Oblio and his dad.  We had a beer at the bar down the
  street and discussed the trail ahead.
&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;outline-container-3&quot; class=&quot;outline-2&quot;&gt;
&lt;h2 id=&quot;sec-3&quot;&gt;July 2 &lt;/h2&gt;
&lt;div class=&quot;outline-text-2&quot; id=&quot;text-3&quot;&gt;


&lt;p&gt;
  After a night of pretty poor sleep (I was excited and there were
  snorers), we got up bright and early at 5:30 the next morning.  The
  inn came with a deal that you get breakfast at the diner, so I met
  up with Oblio and his dad, and we came up with trail names for
  ourselves. Since I had been doing my postdoc in Computational
  Geometry just before the trail, I became known as Dr. Geo.  Oblio&#39;s
  dad was in marketing, and assured me that this was a fine name.
&lt;/p&gt;
&lt;p&gt;
  We piled into the innkeeper&#39;s truck and headed for the trail.  The
  first task of a southbound AT thru-hike is to climb Mount Katahdin.
  In fact, the climb doesn&#39;t even count, because the trail starts at
  the top.  Since we would be coming back, we left our full packs at
  the Baxter Park ranger station, and took the loaner day-packs that
  they provide.  That would be the only time that I hiked without my
  full pack over the next 4500 miles.
&lt;/p&gt;
&lt;p&gt;
  It was a good thing that we had light packs, because Katahdin is a
  monster.  It is probably the most technical climbing on the trail,
  requiring you to pull yourself up with your hands at many points.
  However, the &lt;a href=&quot;https://picasaweb.google.com/lh/photo/xaCB5S_gJwWabCsdMwPVU3IQdffm0dM4kWIdDklkn2s?feat=directlink&quot;&gt;views&lt;/a&gt; are great.  At some points, you &lt;a href=&quot;https://picasaweb.google.com/lh/photo/om0LnphpOAtHNxIX9QwkqHIQdffm0dM4kWIdDklkn2s?feat=directlink&quot;&gt;feel&lt;/a&gt; like you are
  in an &lt;a href=&quot;https://picasaweb.google.com/lh/photo/8rHwtx0OcApK-34CYXmkM3IQdffm0dM4kWIdDklkn2s?feat=directlink&quot;&gt;airplane&lt;/a&gt;, you can see so far.  There are even great &lt;a href=&quot;https://picasaweb.google.com/lh/photo/ig4QqEE10V3TTXk9BfL9TXIQdffm0dM4kWIdDklkn2s?feat=directlink&quot;&gt;waterfalls&lt;/a&gt;
  near the base.  I know some people bathed in the pools beneath the
  falls, but the water was far too cold for me.  However, I did get my
  &lt;a href=&quot;https://picasaweb.google.com/lh/photo/betCZRWpaGuJGmFtjulKJnIQdffm0dM4kWIdDklkn2s?feat=directlink&quot;&gt;picture&lt;/a&gt; taken at the summit so that I could prove that I had started
  the trail.
&lt;/p&gt;
&lt;p&gt;
  We started our hike from the summit back down the mountain.  It was
  even harder going down than going up.  When we got to the bottom,
  everyone was pretty tired.  Especially for the first day of hiking,
  Katahdin is really hard.  We made our camp at Baxter Park.  Of
  course, I was very poorly organized and hadn&#39;t realized that you
  must book a campsite there, so I shared with Oblio and his dad.
&lt;/p&gt;
&lt;p&gt;
  It was a night of firsts for me.  I hadn&#39;t lit my stove before.  It
  didn&#39;t want to work with my flint, so I had to borrow a lighter.  I
  hadn&#39;t used a water filter before, so I needed to do that for the
  first time as well.  Cooking outside was also a new experience, and
  I undercooked the rice pretty woefully.  But after a hard day of
  hiking, any warm food is pretty good.  After that, I set up my
  brand-new hammock for the first time and climbed into my brand-new
  sleeping bag.  The hammock sagged so much that my bum almost touched
  the ground, but I didn&#39;t care &amp;ndash; I was in bed and my journey had
  started.
&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

	</content>


	<link rel="comments" href="/posts/hiking/at-01/#comments" type="text/html" />


	<link rel="comments" href="/posts/hiking/at-01/comments.atom" type="application/atom+xml" />

</entry>

</feed>
